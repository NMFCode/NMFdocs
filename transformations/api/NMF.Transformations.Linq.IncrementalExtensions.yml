### YamlMime:ManagedReference
items:
- uid: NMF.Transformations.Linq.IncrementalExtensions
  commentId: T:NMF.Transformations.Linq.IncrementalExtensions
  id: IncrementalExtensions
  parent: NMF.Transformations.Linq
  children:
  - NMF.Transformations.Linq.IncrementalExtensions.Select``2(System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{``0}},System.Linq.Expressions.Expression{System.Func{``0,``1}})
  - NMF.Transformations.Linq.IncrementalExtensions.SelectMany``2(System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{``0}},System.Linq.Expressions.Expression{System.Func{``0,System.Func{NMF.Transformations.Core.ITransformationContext,System.Collections.Generic.IEnumerable{``1}}}})
  - NMF.Transformations.Linq.IncrementalExtensions.SelectMany``3(System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{``0}},System.Linq.Expressions.Expression{System.Func{``0,System.Func{NMF.Transformations.Core.ITransformationContext,System.Collections.Generic.IEnumerable{``1}}}},System.Linq.Expressions.Expression{System.Func{``0,``1,``2}})
  - NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``1(NMF.Transformations.InPlaceTransformationRuleBase{``0})
  - NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``1(NMF.Transformations.InPlaceTransformationRuleBase{``0},NMF.Transformations.Core.ITransformationContext)
  - NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``1(NMF.Transformations.InPlaceTransformationRuleBase{``0},NMF.Transformations.Core.ITransformationContext,System.Boolean)
  - NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``1(NMF.Transformations.InPlaceTransformationRuleBase{``0},NMF.Transformations.Core.ITransformationContext,System.Boolean,System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{``0},System.Boolean})
  - NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``1(NMF.Transformations.InPlaceTransformationRuleBase{``0},NMF.Transformations.Core.ITransformationContext,System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{``0},System.Boolean})
  - NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``1(NMF.Transformations.InPlaceTransformationRuleBase{``0},System.Boolean)
  - NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``1(NMF.Transformations.InPlaceTransformationRuleBase{``0},System.Boolean,System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{``0},System.Boolean})
  - NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``1(NMF.Transformations.InPlaceTransformationRuleBase{``0},System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{``0},System.Boolean})
  - NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.InPlaceTransformationRuleBase{``0,``1})
  - NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.InPlaceTransformationRuleBase{``0,``1},NMF.Transformations.Core.ITransformationContext)
  - NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.InPlaceTransformationRuleBase{``0,``1},NMF.Transformations.Core.ITransformationContext,System.Boolean)
  - NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.InPlaceTransformationRuleBase{``0,``1},NMF.Transformations.Core.ITransformationContext,System.Boolean,System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{``0,``1},System.Boolean})
  - NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.InPlaceTransformationRuleBase{``0,``1},NMF.Transformations.Core.ITransformationContext,System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{``0,``1},System.Boolean})
  - NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.InPlaceTransformationRuleBase{``0,``1},System.Boolean)
  - NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.InPlaceTransformationRuleBase{``0,``1},System.Boolean,System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{``0,``1},System.Boolean})
  - NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.InPlaceTransformationRuleBase{``0,``1},System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{``0,``1},System.Boolean})
  - NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.TransformationRuleBase{``0,``1})
  - NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.TransformationRuleBase{``0,``1},NMF.Transformations.Core.ITransformationContext)
  - NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.TransformationRuleBase{``0,``1},NMF.Transformations.Core.ITransformationContext,System.Boolean)
  - NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.TransformationRuleBase{``0,``1},NMF.Transformations.Core.ITransformationContext,System.Boolean,System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{``0,``1},System.Boolean})
  - NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.TransformationRuleBase{``0,``1},NMF.Transformations.Core.ITransformationContext,System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{``0,``1},System.Boolean})
  - NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.TransformationRuleBase{``0,``1},System.Boolean)
  - NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.TransformationRuleBase{``0,``1},System.Boolean,System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{``0,``1},System.Boolean})
  - NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.TransformationRuleBase{``0,``1},System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{``0,``1},System.Boolean})
  - NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2})
  - NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},NMF.Transformations.Core.ITransformationContext)
  - NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},NMF.Transformations.Core.ITransformationContext,System.Boolean)
  - NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},NMF.Transformations.Core.ITransformationContext,System.Boolean,System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{``0,``1,``2},System.Boolean})
  - NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},NMF.Transformations.Core.ITransformationContext,System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{``0,``1,``2},System.Boolean})
  - NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Boolean)
  - NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Boolean,System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{``0,``1,``2},System.Boolean})
  - NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{``0,``1,``2},System.Boolean})
  - NMF.Transformations.Linq.IncrementalExtensions.Where``1(System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{``0}},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})
  langs:
  - csharp
  - vb
  name: IncrementalExtensions
  nameWithType: IncrementalExtensions
  fullName: NMF.Transformations.Linq.IncrementalExtensions
  type: Class
  source:
    remote:
      path: Transformations/Transformations/Linq/IncrementalExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: IncrementalExtensions
    path: src/Transformations/Transformations/Linq/IncrementalExtensions.cs
    startLine: 14
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations.Linq
  summary: "\nThis class contains the extension methods necessary for the NMF Transformations relational extensions\n"
  example: []
  syntax:
    content: public static class IncrementalExtensions
    content.vb: Public Module IncrementalExtensions
  inheritance:
  - System.Object
  inheritedMembers:
  - System.Object.ToString
  - System.Object.Equals(System.Object)
  - System.Object.Equals(System.Object,System.Object)
  - System.Object.ReferenceEquals(System.Object,System.Object)
  - System.Object.GetHashCode
  - System.Object.GetType
  - System.Object.MemberwiseClone
  modifiers.csharp:
  - public
  - static
  - class
  modifiers.vb:
  - Public
  - Module
- uid: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.TransformationRuleBase{``0,``1},NMF.Transformations.Core.ITransformationContext)
  commentId: M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.TransformationRuleBase{``0,``1},NMF.Transformations.Core.ITransformationContext)
  id: ToComputationSource``2(NMF.Transformations.TransformationRuleBase{``0,``1},NMF.Transformations.Core.ITransformationContext)
  isExtensionMethod: true
  parent: NMF.Transformations.Linq.IncrementalExtensions
  langs:
  - csharp
  - vb
  name: ToComputationSource<TInput, TOutput>(TransformationRuleBase<TInput, TOutput>, ITransformationContext)
  nameWithType: IncrementalExtensions.ToComputationSource<TInput, TOutput>(TransformationRuleBase<TInput, TOutput>, ITransformationContext)
  fullName: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource<TInput, TOutput>(NMF.Transformations.TransformationRuleBase<TInput, TOutput>, NMF.Transformations.Core.ITransformationContext)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/Linq/IncrementalExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ToComputationSource
    path: src/Transformations/Transformations/Linq/IncrementalExtensions.cs
    startLine: 24
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations.Linq
  summary: "\nCreates a new computation source from a transformation rule\n"
  example: []
  syntax:
    content: >-
      public static INotifyEnumerable<TransformationComputationWrapper<TInput, TOutput>> ToComputationSource<TInput, TOutput>(this TransformationRuleBase<TInput, TOutput> rule, ITransformationContext context)

          where TInput : class where TOutput : class
    parameters:
    - id: rule
      type: NMF.Transformations.TransformationRuleBase{{TInput},{TOutput}}
      description: The rule that should be taken as a source of computation objects
    - id: context
      type: NMF.Transformations.Core.ITransformationContext
      description: The context in which the rule is used as source of computations
    typeParameters:
    - id: TInput
      description: The type of the input arguments for the transformation rule
    - id: TOutput
      description: The output type of the transformation rule
    return:
      type: INotifyEnumerable{NMF.Transformations.Linq.TransformationComputationWrapper{{TInput},{TOutput}}}
      description: A source of computations that can further be dealt with
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToComputationSource(Of TInput As Class, TOutput As Class)(rule As TransformationRuleBase(Of TInput, TOutput), context As ITransformationContext) As INotifyEnumerable(Of TransformationComputationWrapper(Of TInput, TOutput))
  overload: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource*
  nameWithType.vb: IncrementalExtensions.ToComputationSource(Of TInput, TOutput)(TransformationRuleBase(Of TInput, TOutput), ITransformationContext)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource(Of TInput, TOutput)(NMF.Transformations.TransformationRuleBase(Of TInput, TOutput), NMF.Transformations.Core.ITransformationContext)
  name.vb: ToComputationSource(Of TInput, TOutput)(TransformationRuleBase(Of TInput, TOutput), ITransformationContext)
- uid: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.TransformationRuleBase{``0,``1},NMF.Transformations.Core.ITransformationContext,System.Boolean)
  commentId: M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.TransformationRuleBase{``0,``1},NMF.Transformations.Core.ITransformationContext,System.Boolean)
  id: ToComputationSource``2(NMF.Transformations.TransformationRuleBase{``0,``1},NMF.Transformations.Core.ITransformationContext,System.Boolean)
  isExtensionMethod: true
  parent: NMF.Transformations.Linq.IncrementalExtensions
  langs:
  - csharp
  - vb
  name: ToComputationSource<TInput, TOutput>(TransformationRuleBase<TInput, TOutput>, ITransformationContext, Boolean)
  nameWithType: IncrementalExtensions.ToComputationSource<TInput, TOutput>(TransformationRuleBase<TInput, TOutput>, ITransformationContext, Boolean)
  fullName: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource<TInput, TOutput>(NMF.Transformations.TransformationRuleBase<TInput, TOutput>, NMF.Transformations.Core.ITransformationContext, System.Boolean)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/Linq/IncrementalExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ToComputationSource
    path: src/Transformations/Transformations/Linq/IncrementalExtensions.cs
    startLine: 43
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations.Linq
  summary: "\nCreates a new computation source from a transformation rule\n"
  example: []
  syntax:
    content: >-
      public static INotifyEnumerable<TransformationComputationWrapper<TInput, TOutput>> ToComputationSource<TInput, TOutput>(this TransformationRuleBase<TInput, TOutput> rule, ITransformationContext context, bool allowNull)

          where TInput : class where TOutput : class
    parameters:
    - id: rule
      type: NMF.Transformations.TransformationRuleBase{{TInput},{TOutput}}
      description: The rule that should be taken as a source of computation objects
    - id: context
      type: NMF.Transformations.Core.ITransformationContext
      description: The context in which the rule is used as source of computations
    - id: allowNull
      type: System.Boolean
      description: A boolean value indicating whether null values should be allowed
    typeParameters:
    - id: TInput
      description: The type of the input arguments for the transformation rule
    - id: TOutput
      description: The output type of the transformation rule
    return:
      type: INotifyEnumerable{NMF.Transformations.Linq.TransformationComputationWrapper{{TInput},{TOutput}}}
      description: A source of computations that can further be dealt with
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToComputationSource(Of TInput As Class, TOutput As Class)(rule As TransformationRuleBase(Of TInput, TOutput), context As ITransformationContext, allowNull As Boolean) As INotifyEnumerable(Of TransformationComputationWrapper(Of TInput, TOutput))
  overload: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource*
  nameWithType.vb: IncrementalExtensions.ToComputationSource(Of TInput, TOutput)(TransformationRuleBase(Of TInput, TOutput), ITransformationContext, Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource(Of TInput, TOutput)(NMF.Transformations.TransformationRuleBase(Of TInput, TOutput), NMF.Transformations.Core.ITransformationContext, System.Boolean)
  name.vb: ToComputationSource(Of TInput, TOutput)(TransformationRuleBase(Of TInput, TOutput), ITransformationContext, Boolean)
- uid: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.TransformationRuleBase{``0,``1},NMF.Transformations.Core.ITransformationContext,System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{``0,``1},System.Boolean})
  commentId: M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.TransformationRuleBase{``0,``1},NMF.Transformations.Core.ITransformationContext,System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{``0,``1},System.Boolean})
  id: ToComputationSource``2(NMF.Transformations.TransformationRuleBase{``0,``1},NMF.Transformations.Core.ITransformationContext,System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{``0,``1},System.Boolean})
  isExtensionMethod: true
  parent: NMF.Transformations.Linq.IncrementalExtensions
  langs:
  - csharp
  - vb
  name: ToComputationSource<TInput, TOutput>(TransformationRuleBase<TInput, TOutput>, ITransformationContext, Func<TransformationComputationWrapper<TInput, TOutput>, Boolean>)
  nameWithType: IncrementalExtensions.ToComputationSource<TInput, TOutput>(TransformationRuleBase<TInput, TOutput>, ITransformationContext, Func<TransformationComputationWrapper<TInput, TOutput>, Boolean>)
  fullName: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource<TInput, TOutput>(NMF.Transformations.TransformationRuleBase<TInput, TOutput>, NMF.Transformations.Core.ITransformationContext, System.Func<NMF.Transformations.Linq.TransformationComputationWrapper<TInput, TOutput>, System.Boolean>)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/Linq/IncrementalExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ToComputationSource
    path: src/Transformations/Transformations/Linq/IncrementalExtensions.cs
    startLine: 64
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations.Linq
  summary: "\nCreates a new computation source from a transformation rule\n"
  example: []
  syntax:
    content: >-
      public static INotifyEnumerable<TransformationComputationWrapper<TInput, TOutput>> ToComputationSource<TInput, TOutput>(this TransformationRuleBase<TInput, TOutput> rule, ITransformationContext context, Func<TransformationComputationWrapper<TInput, TOutput>, bool> filter)

          where TInput : class where TOutput : class
    parameters:
    - id: rule
      type: NMF.Transformations.TransformationRuleBase{{TInput},{TOutput}}
      description: The rule that should be taken as a source of computation objects
    - id: context
      type: NMF.Transformations.Core.ITransformationContext
      description: The context in which the rule is used as source of computations
    - id: filter
      type: System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{{TInput},{TOutput}},System.Boolean}
      description: A method or lambda expression to filter the computation objects
    typeParameters:
    - id: TInput
      description: The type of the input arguments for the transformation rule
    - id: TOutput
      description: The output type of the transformation rule
    return:
      type: INotifyEnumerable{NMF.Transformations.Linq.TransformationComputationWrapper{{TInput},{TOutput}}}
      description: A source of computations that can further be dealt with
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToComputationSource(Of TInput As Class, TOutput As Class)(rule As TransformationRuleBase(Of TInput, TOutput), context As ITransformationContext, filter As Func(Of TransformationComputationWrapper(Of TInput, TOutput), Boolean)) As INotifyEnumerable(Of TransformationComputationWrapper(Of TInput, TOutput))
  overload: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource*
  nameWithType.vb: IncrementalExtensions.ToComputationSource(Of TInput, TOutput)(TransformationRuleBase(Of TInput, TOutput), ITransformationContext, Func(Of TransformationComputationWrapper(Of TInput, TOutput), Boolean))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource(Of TInput, TOutput)(NMF.Transformations.TransformationRuleBase(Of TInput, TOutput), NMF.Transformations.Core.ITransformationContext, System.Func(Of NMF.Transformations.Linq.TransformationComputationWrapper(Of TInput, TOutput), System.Boolean))
  name.vb: ToComputationSource(Of TInput, TOutput)(TransformationRuleBase(Of TInput, TOutput), ITransformationContext, Func(Of TransformationComputationWrapper(Of TInput, TOutput), Boolean))
- uid: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.TransformationRuleBase{``0,``1},NMF.Transformations.Core.ITransformationContext,System.Boolean,System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{``0,``1},System.Boolean})
  commentId: M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.TransformationRuleBase{``0,``1},NMF.Transformations.Core.ITransformationContext,System.Boolean,System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{``0,``1},System.Boolean})
  id: ToComputationSource``2(NMF.Transformations.TransformationRuleBase{``0,``1},NMF.Transformations.Core.ITransformationContext,System.Boolean,System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{``0,``1},System.Boolean})
  isExtensionMethod: true
  parent: NMF.Transformations.Linq.IncrementalExtensions
  langs:
  - csharp
  - vb
  name: ToComputationSource<TInput, TOutput>(TransformationRuleBase<TInput, TOutput>, ITransformationContext, Boolean, Func<TransformationComputationWrapper<TInput, TOutput>, Boolean>)
  nameWithType: IncrementalExtensions.ToComputationSource<TInput, TOutput>(TransformationRuleBase<TInput, TOutput>, ITransformationContext, Boolean, Func<TransformationComputationWrapper<TInput, TOutput>, Boolean>)
  fullName: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource<TInput, TOutput>(NMF.Transformations.TransformationRuleBase<TInput, TOutput>, NMF.Transformations.Core.ITransformationContext, System.Boolean, System.Func<NMF.Transformations.Linq.TransformationComputationWrapper<TInput, TOutput>, System.Boolean>)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/Linq/IncrementalExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ToComputationSource
    path: src/Transformations/Transformations/Linq/IncrementalExtensions.cs
    startLine: 84
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations.Linq
  summary: "\nCreates a new computation source from a transformation rule\n"
  example: []
  syntax:
    content: >-
      public static INotifyEnumerable<TransformationComputationWrapper<TInput, TOutput>> ToComputationSource<TInput, TOutput>(this TransformationRuleBase<TInput, TOutput> rule, ITransformationContext context, bool allowNull, Func<TransformationComputationWrapper<TInput, TOutput>, bool> filter)

          where TInput : class where TOutput : class
    parameters:
    - id: rule
      type: NMF.Transformations.TransformationRuleBase{{TInput},{TOutput}}
      description: The rule that should be taken as a source of computation objects
    - id: context
      type: NMF.Transformations.Core.ITransformationContext
      description: The context in which the rule is used as source of computations
    - id: allowNull
      type: System.Boolean
      description: A boolean value indicating whether null values should be allowed
    - id: filter
      type: System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{{TInput},{TOutput}},System.Boolean}
      description: A method or lambda expression to filter the computation objects
    typeParameters:
    - id: TInput
      description: The type of the input arguments for the transformation rule
    - id: TOutput
      description: The output type of the transformation rule
    return:
      type: INotifyEnumerable{NMF.Transformations.Linq.TransformationComputationWrapper{{TInput},{TOutput}}}
      description: A source of computations that can further be dealt with
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToComputationSource(Of TInput As Class, TOutput As Class)(rule As TransformationRuleBase(Of TInput, TOutput), context As ITransformationContext, allowNull As Boolean, filter As Func(Of TransformationComputationWrapper(Of TInput, TOutput), Boolean)) As INotifyEnumerable(Of TransformationComputationWrapper(Of TInput, TOutput))
  overload: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource*
  nameWithType.vb: IncrementalExtensions.ToComputationSource(Of TInput, TOutput)(TransformationRuleBase(Of TInput, TOutput), ITransformationContext, Boolean, Func(Of TransformationComputationWrapper(Of TInput, TOutput), Boolean))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource(Of TInput, TOutput)(NMF.Transformations.TransformationRuleBase(Of TInput, TOutput), NMF.Transformations.Core.ITransformationContext, System.Boolean, System.Func(Of NMF.Transformations.Linq.TransformationComputationWrapper(Of TInput, TOutput), System.Boolean))
  name.vb: ToComputationSource(Of TInput, TOutput)(TransformationRuleBase(Of TInput, TOutput), ITransformationContext, Boolean, Func(Of TransformationComputationWrapper(Of TInput, TOutput), Boolean))
- uid: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},NMF.Transformations.Core.ITransformationContext)
  commentId: M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},NMF.Transformations.Core.ITransformationContext)
  id: ToComputationSource``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},NMF.Transformations.Core.ITransformationContext)
  isExtensionMethod: true
  parent: NMF.Transformations.Linq.IncrementalExtensions
  langs:
  - csharp
  - vb
  name: ToComputationSource<TInput1, TInput2, TOutput>(TransformationRuleBase<TInput1, TInput2, TOutput>, ITransformationContext)
  nameWithType: IncrementalExtensions.ToComputationSource<TInput1, TInput2, TOutput>(TransformationRuleBase<TInput1, TInput2, TOutput>, ITransformationContext)
  fullName: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource<TInput1, TInput2, TOutput>(NMF.Transformations.TransformationRuleBase<TInput1, TInput2, TOutput>, NMF.Transformations.Core.ITransformationContext)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/Linq/IncrementalExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ToComputationSource
    path: src/Transformations/Transformations/Linq/IncrementalExtensions.cs
    startLine: 105
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations.Linq
  summary: "\nCreates a new computation source from a transformation rule\n"
  example: []
  syntax:
    content: >-
      public static INotifyEnumerable<TransformationComputationWrapper<TInput1, TInput2, TOutput>> ToComputationSource<TInput1, TInput2, TOutput>(this TransformationRuleBase<TInput1, TInput2, TOutput> rule, ITransformationContext context)

          where TInput1 : class where TInput2 : class where TOutput : class
    parameters:
    - id: rule
      type: NMF.Transformations.TransformationRuleBase{{TInput1},{TInput2},{TOutput}}
      description: The rule that should be taken as a source of computation objects
    - id: context
      type: NMF.Transformations.Core.ITransformationContext
      description: The context in which the rule is used as source of computations
    typeParameters:
    - id: TInput1
      description: The type of the first input arguments for the transformation rule
    - id: TInput2
      description: The type of the second input arguments for the transformation rule
    - id: TOutput
      description: The output type of the transformation rule
    return:
      type: INotifyEnumerable{NMF.Transformations.Linq.TransformationComputationWrapper{{TInput1},{TInput2},{TOutput}}}
      description: A source of computations that can further be dealt with
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToComputationSource(Of TInput1 As Class, TInput2 As Class, TOutput As Class)(rule As TransformationRuleBase(Of TInput1, TInput2, TOutput), context As ITransformationContext) As INotifyEnumerable(Of TransformationComputationWrapper(Of TInput1, TInput2, TOutput))
  overload: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource*
  nameWithType.vb: IncrementalExtensions.ToComputationSource(Of TInput1, TInput2, TOutput)(TransformationRuleBase(Of TInput1, TInput2, TOutput), ITransformationContext)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource(Of TInput1, TInput2, TOutput)(NMF.Transformations.TransformationRuleBase(Of TInput1, TInput2, TOutput), NMF.Transformations.Core.ITransformationContext)
  name.vb: ToComputationSource(Of TInput1, TInput2, TOutput)(TransformationRuleBase(Of TInput1, TInput2, TOutput), ITransformationContext)
- uid: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},NMF.Transformations.Core.ITransformationContext,System.Boolean)
  commentId: M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},NMF.Transformations.Core.ITransformationContext,System.Boolean)
  id: ToComputationSource``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},NMF.Transformations.Core.ITransformationContext,System.Boolean)
  isExtensionMethod: true
  parent: NMF.Transformations.Linq.IncrementalExtensions
  langs:
  - csharp
  - vb
  name: ToComputationSource<TInput1, TInput2, TOutput>(TransformationRuleBase<TInput1, TInput2, TOutput>, ITransformationContext, Boolean)
  nameWithType: IncrementalExtensions.ToComputationSource<TInput1, TInput2, TOutput>(TransformationRuleBase<TInput1, TInput2, TOutput>, ITransformationContext, Boolean)
  fullName: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource<TInput1, TInput2, TOutput>(NMF.Transformations.TransformationRuleBase<TInput1, TInput2, TOutput>, NMF.Transformations.Core.ITransformationContext, System.Boolean)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/Linq/IncrementalExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ToComputationSource
    path: src/Transformations/Transformations/Linq/IncrementalExtensions.cs
    startLine: 126
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations.Linq
  summary: "\nCreates a new computation source from a transformation rule\n"
  example: []
  syntax:
    content: >-
      public static INotifyEnumerable<TransformationComputationWrapper<TInput1, TInput2, TOutput>> ToComputationSource<TInput1, TInput2, TOutput>(this TransformationRuleBase<TInput1, TInput2, TOutput> rule, ITransformationContext context, bool allowNull)

          where TInput1 : class where TInput2 : class where TOutput : class
    parameters:
    - id: rule
      type: NMF.Transformations.TransformationRuleBase{{TInput1},{TInput2},{TOutput}}
      description: The rule that should be taken as a source of computation objects
    - id: context
      type: NMF.Transformations.Core.ITransformationContext
      description: The context in which the rule is used as source of computations
    - id: allowNull
      type: System.Boolean
      description: A boolean value indicating whether null values should be allowed
    typeParameters:
    - id: TInput1
      description: The type of the first input arguments for the transformation rule
    - id: TInput2
      description: The type of the second input arguments for the transformation rule
    - id: TOutput
      description: The output type of the transformation rule
    return:
      type: INotifyEnumerable{NMF.Transformations.Linq.TransformationComputationWrapper{{TInput1},{TInput2},{TOutput}}}
      description: A source of computations that can further be dealt with
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToComputationSource(Of TInput1 As Class, TInput2 As Class, TOutput As Class)(rule As TransformationRuleBase(Of TInput1, TInput2, TOutput), context As ITransformationContext, allowNull As Boolean) As INotifyEnumerable(Of TransformationComputationWrapper(Of TInput1, TInput2, TOutput))
  overload: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource*
  nameWithType.vb: IncrementalExtensions.ToComputationSource(Of TInput1, TInput2, TOutput)(TransformationRuleBase(Of TInput1, TInput2, TOutput), ITransformationContext, Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource(Of TInput1, TInput2, TOutput)(NMF.Transformations.TransformationRuleBase(Of TInput1, TInput2, TOutput), NMF.Transformations.Core.ITransformationContext, System.Boolean)
  name.vb: ToComputationSource(Of TInput1, TInput2, TOutput)(TransformationRuleBase(Of TInput1, TInput2, TOutput), ITransformationContext, Boolean)
- uid: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},NMF.Transformations.Core.ITransformationContext,System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{``0,``1,``2},System.Boolean})
  commentId: M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},NMF.Transformations.Core.ITransformationContext,System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{``0,``1,``2},System.Boolean})
  id: ToComputationSource``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},NMF.Transformations.Core.ITransformationContext,System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{``0,``1,``2},System.Boolean})
  isExtensionMethod: true
  parent: NMF.Transformations.Linq.IncrementalExtensions
  langs:
  - csharp
  - vb
  name: ToComputationSource<TInput1, TInput2, TOutput>(TransformationRuleBase<TInput1, TInput2, TOutput>, ITransformationContext, Func<TransformationComputationWrapper<TInput1, TInput2, TOutput>, Boolean>)
  nameWithType: IncrementalExtensions.ToComputationSource<TInput1, TInput2, TOutput>(TransformationRuleBase<TInput1, TInput2, TOutput>, ITransformationContext, Func<TransformationComputationWrapper<TInput1, TInput2, TOutput>, Boolean>)
  fullName: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource<TInput1, TInput2, TOutput>(NMF.Transformations.TransformationRuleBase<TInput1, TInput2, TOutput>, NMF.Transformations.Core.ITransformationContext, System.Func<NMF.Transformations.Linq.TransformationComputationWrapper<TInput1, TInput2, TOutput>, System.Boolean>)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/Linq/IncrementalExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ToComputationSource
    path: src/Transformations/Transformations/Linq/IncrementalExtensions.cs
    startLine: 149
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations.Linq
  summary: "\nCreates a new computation source from a transformation rule\n"
  example: []
  syntax:
    content: >-
      public static INotifyEnumerable<TransformationComputationWrapper<TInput1, TInput2, TOutput>> ToComputationSource<TInput1, TInput2, TOutput>(this TransformationRuleBase<TInput1, TInput2, TOutput> rule, ITransformationContext context, Func<TransformationComputationWrapper<TInput1, TInput2, TOutput>, bool> filter)

          where TInput1 : class where TInput2 : class where TOutput : class
    parameters:
    - id: rule
      type: NMF.Transformations.TransformationRuleBase{{TInput1},{TInput2},{TOutput}}
      description: The rule that should be taken as a source of computation objects
    - id: context
      type: NMF.Transformations.Core.ITransformationContext
      description: The context in which the rule is used as source of computations
    - id: filter
      type: System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{{TInput1},{TInput2},{TOutput}},System.Boolean}
      description: A method or lambda expression to filter the computation objects
    typeParameters:
    - id: TInput1
      description: The type of the first input arguments for the transformation rule
    - id: TInput2
      description: The type of the second input arguments for the transformation rule
    - id: TOutput
      description: The output type of the transformation rule
    return:
      type: INotifyEnumerable{NMF.Transformations.Linq.TransformationComputationWrapper{{TInput1},{TInput2},{TOutput}}}
      description: A source of computations that can further be dealt with
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToComputationSource(Of TInput1 As Class, TInput2 As Class, TOutput As Class)(rule As TransformationRuleBase(Of TInput1, TInput2, TOutput), context As ITransformationContext, filter As Func(Of TransformationComputationWrapper(Of TInput1, TInput2, TOutput), Boolean)) As INotifyEnumerable(Of TransformationComputationWrapper(Of TInput1, TInput2, TOutput))
  overload: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource*
  nameWithType.vb: IncrementalExtensions.ToComputationSource(Of TInput1, TInput2, TOutput)(TransformationRuleBase(Of TInput1, TInput2, TOutput), ITransformationContext, Func(Of TransformationComputationWrapper(Of TInput1, TInput2, TOutput), Boolean))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource(Of TInput1, TInput2, TOutput)(NMF.Transformations.TransformationRuleBase(Of TInput1, TInput2, TOutput), NMF.Transformations.Core.ITransformationContext, System.Func(Of NMF.Transformations.Linq.TransformationComputationWrapper(Of TInput1, TInput2, TOutput), System.Boolean))
  name.vb: ToComputationSource(Of TInput1, TInput2, TOutput)(TransformationRuleBase(Of TInput1, TInput2, TOutput), ITransformationContext, Func(Of TransformationComputationWrapper(Of TInput1, TInput2, TOutput), Boolean))
- uid: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},NMF.Transformations.Core.ITransformationContext,System.Boolean,System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{``0,``1,``2},System.Boolean})
  commentId: M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},NMF.Transformations.Core.ITransformationContext,System.Boolean,System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{``0,``1,``2},System.Boolean})
  id: ToComputationSource``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},NMF.Transformations.Core.ITransformationContext,System.Boolean,System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{``0,``1,``2},System.Boolean})
  isExtensionMethod: true
  parent: NMF.Transformations.Linq.IncrementalExtensions
  langs:
  - csharp
  - vb
  name: ToComputationSource<TInput1, TInput2, TOutput>(TransformationRuleBase<TInput1, TInput2, TOutput>, ITransformationContext, Boolean, Func<TransformationComputationWrapper<TInput1, TInput2, TOutput>, Boolean>)
  nameWithType: IncrementalExtensions.ToComputationSource<TInput1, TInput2, TOutput>(TransformationRuleBase<TInput1, TInput2, TOutput>, ITransformationContext, Boolean, Func<TransformationComputationWrapper<TInput1, TInput2, TOutput>, Boolean>)
  fullName: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource<TInput1, TInput2, TOutput>(NMF.Transformations.TransformationRuleBase<TInput1, TInput2, TOutput>, NMF.Transformations.Core.ITransformationContext, System.Boolean, System.Func<NMF.Transformations.Linq.TransformationComputationWrapper<TInput1, TInput2, TOutput>, System.Boolean>)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/Linq/IncrementalExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ToComputationSource
    path: src/Transformations/Transformations/Linq/IncrementalExtensions.cs
    startLine: 171
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations.Linq
  summary: "\nCreates a new computation source from a transformation rule\n"
  example: []
  syntax:
    content: >-
      public static INotifyEnumerable<TransformationComputationWrapper<TInput1, TInput2, TOutput>> ToComputationSource<TInput1, TInput2, TOutput>(this TransformationRuleBase<TInput1, TInput2, TOutput> rule, ITransformationContext context, bool allowNull, Func<TransformationComputationWrapper<TInput1, TInput2, TOutput>, bool> filter)

          where TInput1 : class where TInput2 : class where TOutput : class
    parameters:
    - id: rule
      type: NMF.Transformations.TransformationRuleBase{{TInput1},{TInput2},{TOutput}}
      description: The rule that should be taken as a source of computation objects
    - id: context
      type: NMF.Transformations.Core.ITransformationContext
      description: The context in which the rule is used as source of computations
    - id: allowNull
      type: System.Boolean
      description: A boolean value indicating whether null values should be allowed
    - id: filter
      type: System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{{TInput1},{TInput2},{TOutput}},System.Boolean}
      description: A method or lambda expression to filter the computation objects
    typeParameters:
    - id: TInput1
      description: The type of the first input arguments for the transformation rule
    - id: TInput2
      description: The type of the second input arguments for the transformation rule
    - id: TOutput
      description: The output type of the transformation rule
    return:
      type: INotifyEnumerable{NMF.Transformations.Linq.TransformationComputationWrapper{{TInput1},{TInput2},{TOutput}}}
      description: A source of computations that can further be dealt with
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToComputationSource(Of TInput1 As Class, TInput2 As Class, TOutput As Class)(rule As TransformationRuleBase(Of TInput1, TInput2, TOutput), context As ITransformationContext, allowNull As Boolean, filter As Func(Of TransformationComputationWrapper(Of TInput1, TInput2, TOutput), Boolean)) As INotifyEnumerable(Of TransformationComputationWrapper(Of TInput1, TInput2, TOutput))
  overload: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource*
  nameWithType.vb: IncrementalExtensions.ToComputationSource(Of TInput1, TInput2, TOutput)(TransformationRuleBase(Of TInput1, TInput2, TOutput), ITransformationContext, Boolean, Func(Of TransformationComputationWrapper(Of TInput1, TInput2, TOutput), Boolean))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource(Of TInput1, TInput2, TOutput)(NMF.Transformations.TransformationRuleBase(Of TInput1, TInput2, TOutput), NMF.Transformations.Core.ITransformationContext, System.Boolean, System.Func(Of NMF.Transformations.Linq.TransformationComputationWrapper(Of TInput1, TInput2, TOutput), System.Boolean))
  name.vb: ToComputationSource(Of TInput1, TInput2, TOutput)(TransformationRuleBase(Of TInput1, TInput2, TOutput), ITransformationContext, Boolean, Func(Of TransformationComputationWrapper(Of TInput1, TInput2, TOutput), Boolean))
- uid: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.TransformationRuleBase{``0,``1})
  commentId: M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.TransformationRuleBase{``0,``1})
  id: ToComputationSource``2(NMF.Transformations.TransformationRuleBase{``0,``1})
  isExtensionMethod: true
  parent: NMF.Transformations.Linq.IncrementalExtensions
  langs:
  - csharp
  - vb
  name: ToComputationSource<TInput, TOutput>(TransformationRuleBase<TInput, TOutput>)
  nameWithType: IncrementalExtensions.ToComputationSource<TInput, TOutput>(TransformationRuleBase<TInput, TOutput>)
  fullName: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource<TInput, TOutput>(NMF.Transformations.TransformationRuleBase<TInput, TOutput>)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/Linq/IncrementalExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ToComputationSource
    path: src/Transformations/Transformations/Linq/IncrementalExtensions.cs
    startLine: 191
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations.Linq
  summary: "\nCreates a new computation source from a transformation rule\n"
  example: []
  syntax:
    content: >-
      public static Func<ITransformationContext, INotifyEnumerable<TransformationComputationWrapper<TInput, TOutput>>> ToComputationSource<TInput, TOutput>(this TransformationRuleBase<TInput, TOutput> rule)

          where TInput : class where TOutput : class
    parameters:
    - id: rule
      type: NMF.Transformations.TransformationRuleBase{{TInput},{TOutput}}
      description: The rule that should be taken as a source of computation objects
    typeParameters:
    - id: TInput
      description: The type of the input arguments for the transformation rule
    - id: TOutput
      description: The output type of the transformation rule
    return:
      type: System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{NMF.Transformations.Linq.TransformationComputationWrapper{{TInput},{TOutput}}}}
      description: A source of computations that can further be dealt with
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToComputationSource(Of TInput As Class, TOutput As Class)(rule As TransformationRuleBase(Of TInput, TOutput)) As Func(Of ITransformationContext, INotifyEnumerable(Of TransformationComputationWrapper(Of TInput, TOutput)))
  overload: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource*
  nameWithType.vb: IncrementalExtensions.ToComputationSource(Of TInput, TOutput)(TransformationRuleBase(Of TInput, TOutput))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource(Of TInput, TOutput)(NMF.Transformations.TransformationRuleBase(Of TInput, TOutput))
  name.vb: ToComputationSource(Of TInput, TOutput)(TransformationRuleBase(Of TInput, TOutput))
- uid: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.TransformationRuleBase{``0,``1},System.Boolean)
  commentId: M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.TransformationRuleBase{``0,``1},System.Boolean)
  id: ToComputationSource``2(NMF.Transformations.TransformationRuleBase{``0,``1},System.Boolean)
  isExtensionMethod: true
  parent: NMF.Transformations.Linq.IncrementalExtensions
  langs:
  - csharp
  - vb
  name: ToComputationSource<TInput, TOutput>(TransformationRuleBase<TInput, TOutput>, Boolean)
  nameWithType: IncrementalExtensions.ToComputationSource<TInput, TOutput>(TransformationRuleBase<TInput, TOutput>, Boolean)
  fullName: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource<TInput, TOutput>(NMF.Transformations.TransformationRuleBase<TInput, TOutput>, System.Boolean)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/Linq/IncrementalExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ToComputationSource
    path: src/Transformations/Transformations/Linq/IncrementalExtensions.cs
    startLine: 208
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations.Linq
  summary: "\nCreates a new computation source from a transformation rule\n"
  example: []
  syntax:
    content: >-
      public static Func<ITransformationContext, INotifyEnumerable<TransformationComputationWrapper<TInput, TOutput>>> ToComputationSource<TInput, TOutput>(this TransformationRuleBase<TInput, TOutput> rule, bool allowNull)

          where TInput : class where TOutput : class
    parameters:
    - id: rule
      type: NMF.Transformations.TransformationRuleBase{{TInput},{TOutput}}
      description: The rule that should be taken as a source of computation objects
    - id: allowNull
      type: System.Boolean
      description: A boolean value indicating whether null values should be allowed
    typeParameters:
    - id: TInput
      description: The type of the input arguments for the transformation rule
    - id: TOutput
      description: The output type of the transformation rule
    return:
      type: System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{NMF.Transformations.Linq.TransformationComputationWrapper{{TInput},{TOutput}}}}
      description: A source of computations that can further be dealt with
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToComputationSource(Of TInput As Class, TOutput As Class)(rule As TransformationRuleBase(Of TInput, TOutput), allowNull As Boolean) As Func(Of ITransformationContext, INotifyEnumerable(Of TransformationComputationWrapper(Of TInput, TOutput)))
  overload: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource*
  nameWithType.vb: IncrementalExtensions.ToComputationSource(Of TInput, TOutput)(TransformationRuleBase(Of TInput, TOutput), Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource(Of TInput, TOutput)(NMF.Transformations.TransformationRuleBase(Of TInput, TOutput), System.Boolean)
  name.vb: ToComputationSource(Of TInput, TOutput)(TransformationRuleBase(Of TInput, TOutput), Boolean)
- uid: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.TransformationRuleBase{``0,``1},System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{``0,``1},System.Boolean})
  commentId: M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.TransformationRuleBase{``0,``1},System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{``0,``1},System.Boolean})
  id: ToComputationSource``2(NMF.Transformations.TransformationRuleBase{``0,``1},System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{``0,``1},System.Boolean})
  isExtensionMethod: true
  parent: NMF.Transformations.Linq.IncrementalExtensions
  langs:
  - csharp
  - vb
  name: ToComputationSource<TInput, TOutput>(TransformationRuleBase<TInput, TOutput>, Func<TransformationComputationWrapper<TInput, TOutput>, Boolean>)
  nameWithType: IncrementalExtensions.ToComputationSource<TInput, TOutput>(TransformationRuleBase<TInput, TOutput>, Func<TransformationComputationWrapper<TInput, TOutput>, Boolean>)
  fullName: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource<TInput, TOutput>(NMF.Transformations.TransformationRuleBase<TInput, TOutput>, System.Func<NMF.Transformations.Linq.TransformationComputationWrapper<TInput, TOutput>, System.Boolean>)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/Linq/IncrementalExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ToComputationSource
    path: src/Transformations/Transformations/Linq/IncrementalExtensions.cs
    startLine: 225
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations.Linq
  summary: "\nCreates a new computation source from a transformation rule\n"
  example: []
  syntax:
    content: >-
      public static Func<ITransformationContext, INotifyEnumerable<TransformationComputationWrapper<TInput, TOutput>>> ToComputationSource<TInput, TOutput>(this TransformationRuleBase<TInput, TOutput> rule, Func<TransformationComputationWrapper<TInput, TOutput>, bool> filter)

          where TInput : class where TOutput : class
    parameters:
    - id: rule
      type: NMF.Transformations.TransformationRuleBase{{TInput},{TOutput}}
      description: The rule that should be taken as a source of computation objects
    - id: filter
      type: System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{{TInput},{TOutput}},System.Boolean}
      description: A method or lambda expression to filter the computation objects
    typeParameters:
    - id: TInput
      description: The type of the input arguments for the transformation rule
    - id: TOutput
      description: The output type of the transformation rule
    return:
      type: System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{NMF.Transformations.Linq.TransformationComputationWrapper{{TInput},{TOutput}}}}
      description: A source of computations that can further be dealt with
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToComputationSource(Of TInput As Class, TOutput As Class)(rule As TransformationRuleBase(Of TInput, TOutput), filter As Func(Of TransformationComputationWrapper(Of TInput, TOutput), Boolean)) As Func(Of ITransformationContext, INotifyEnumerable(Of TransformationComputationWrapper(Of TInput, TOutput)))
  overload: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource*
  nameWithType.vb: IncrementalExtensions.ToComputationSource(Of TInput, TOutput)(TransformationRuleBase(Of TInput, TOutput), Func(Of TransformationComputationWrapper(Of TInput, TOutput), Boolean))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource(Of TInput, TOutput)(NMF.Transformations.TransformationRuleBase(Of TInput, TOutput), System.Func(Of NMF.Transformations.Linq.TransformationComputationWrapper(Of TInput, TOutput), System.Boolean))
  name.vb: ToComputationSource(Of TInput, TOutput)(TransformationRuleBase(Of TInput, TOutput), Func(Of TransformationComputationWrapper(Of TInput, TOutput), Boolean))
- uid: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.TransformationRuleBase{``0,``1},System.Boolean,System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{``0,``1},System.Boolean})
  commentId: M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.TransformationRuleBase{``0,``1},System.Boolean,System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{``0,``1},System.Boolean})
  id: ToComputationSource``2(NMF.Transformations.TransformationRuleBase{``0,``1},System.Boolean,System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{``0,``1},System.Boolean})
  isExtensionMethod: true
  parent: NMF.Transformations.Linq.IncrementalExtensions
  langs:
  - csharp
  - vb
  name: ToComputationSource<TInput, TOutput>(TransformationRuleBase<TInput, TOutput>, Boolean, Func<TransformationComputationWrapper<TInput, TOutput>, Boolean>)
  nameWithType: IncrementalExtensions.ToComputationSource<TInput, TOutput>(TransformationRuleBase<TInput, TOutput>, Boolean, Func<TransformationComputationWrapper<TInput, TOutput>, Boolean>)
  fullName: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource<TInput, TOutput>(NMF.Transformations.TransformationRuleBase<TInput, TOutput>, System.Boolean, System.Func<NMF.Transformations.Linq.TransformationComputationWrapper<TInput, TOutput>, System.Boolean>)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/Linq/IncrementalExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ToComputationSource
    path: src/Transformations/Transformations/Linq/IncrementalExtensions.cs
    startLine: 243
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations.Linq
  summary: "\nCreates a new computation source from a transformation rule\n"
  example: []
  syntax:
    content: >-
      public static Func<ITransformationContext, INotifyEnumerable<TransformationComputationWrapper<TInput, TOutput>>> ToComputationSource<TInput, TOutput>(this TransformationRuleBase<TInput, TOutput> rule, bool allowNull, Func<TransformationComputationWrapper<TInput, TOutput>, bool> filter)

          where TInput : class where TOutput : class
    parameters:
    - id: rule
      type: NMF.Transformations.TransformationRuleBase{{TInput},{TOutput}}
      description: The rule that should be taken as a source of computation objects
    - id: allowNull
      type: System.Boolean
      description: A boolean value indicating whether null values should be allowed
    - id: filter
      type: System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{{TInput},{TOutput}},System.Boolean}
      description: A method or lambda expression to filter the computation objects
    typeParameters:
    - id: TInput
      description: The type of the input arguments for the transformation rule
    - id: TOutput
      description: The output type of the transformation rule
    return:
      type: System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{NMF.Transformations.Linq.TransformationComputationWrapper{{TInput},{TOutput}}}}
      description: A source of computations that can further be dealt with
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToComputationSource(Of TInput As Class, TOutput As Class)(rule As TransformationRuleBase(Of TInput, TOutput), allowNull As Boolean, filter As Func(Of TransformationComputationWrapper(Of TInput, TOutput), Boolean)) As Func(Of ITransformationContext, INotifyEnumerable(Of TransformationComputationWrapper(Of TInput, TOutput)))
  overload: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource*
  nameWithType.vb: IncrementalExtensions.ToComputationSource(Of TInput, TOutput)(TransformationRuleBase(Of TInput, TOutput), Boolean, Func(Of TransformationComputationWrapper(Of TInput, TOutput), Boolean))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource(Of TInput, TOutput)(NMF.Transformations.TransformationRuleBase(Of TInput, TOutput), System.Boolean, System.Func(Of NMF.Transformations.Linq.TransformationComputationWrapper(Of TInput, TOutput), System.Boolean))
  name.vb: ToComputationSource(Of TInput, TOutput)(TransformationRuleBase(Of TInput, TOutput), Boolean, Func(Of TransformationComputationWrapper(Of TInput, TOutput), Boolean))
- uid: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2})
  commentId: M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2})
  id: ToComputationSource``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2})
  isExtensionMethod: true
  parent: NMF.Transformations.Linq.IncrementalExtensions
  langs:
  - csharp
  - vb
  name: ToComputationSource<TInput1, TInput2, TOutput>(TransformationRuleBase<TInput1, TInput2, TOutput>)
  nameWithType: IncrementalExtensions.ToComputationSource<TInput1, TInput2, TOutput>(TransformationRuleBase<TInput1, TInput2, TOutput>)
  fullName: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource<TInput1, TInput2, TOutput>(NMF.Transformations.TransformationRuleBase<TInput1, TInput2, TOutput>)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/Linq/IncrementalExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ToComputationSource
    path: src/Transformations/Transformations/Linq/IncrementalExtensions.cs
    startLine: 260
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations.Linq
  summary: "\nCreates a new computation source from a transformation rule\n"
  example: []
  syntax:
    content: >-
      public static Func<ITransformationContext, INotifyEnumerable<TransformationComputationWrapper<TInput1, TInput2, TOutput>>> ToComputationSource<TInput1, TInput2, TOutput>(this TransformationRuleBase<TInput1, TInput2, TOutput> rule)

          where TInput1 : class where TInput2 : class where TOutput : class
    parameters:
    - id: rule
      type: NMF.Transformations.TransformationRuleBase{{TInput1},{TInput2},{TOutput}}
      description: The rule that should be taken as a source of computation objects
    typeParameters:
    - id: TInput1
      description: The type of the first input arguments for the transformation rule
    - id: TInput2
      description: The type of the second input arguments for the transformation rule
    - id: TOutput
      description: The output type of the transformation rule
    return:
      type: System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{NMF.Transformations.Linq.TransformationComputationWrapper{{TInput1},{TInput2},{TOutput}}}}
      description: A source of computations that can further be dealt with
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToComputationSource(Of TInput1 As Class, TInput2 As Class, TOutput As Class)(rule As TransformationRuleBase(Of TInput1, TInput2, TOutput)) As Func(Of ITransformationContext, INotifyEnumerable(Of TransformationComputationWrapper(Of TInput1, TInput2, TOutput)))
  overload: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource*
  nameWithType.vb: IncrementalExtensions.ToComputationSource(Of TInput1, TInput2, TOutput)(TransformationRuleBase(Of TInput1, TInput2, TOutput))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource(Of TInput1, TInput2, TOutput)(NMF.Transformations.TransformationRuleBase(Of TInput1, TInput2, TOutput))
  name.vb: ToComputationSource(Of TInput1, TInput2, TOutput)(TransformationRuleBase(Of TInput1, TInput2, TOutput))
- uid: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Boolean)
  commentId: M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Boolean)
  id: ToComputationSource``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Boolean)
  isExtensionMethod: true
  parent: NMF.Transformations.Linq.IncrementalExtensions
  langs:
  - csharp
  - vb
  name: ToComputationSource<TInput1, TInput2, TOutput>(TransformationRuleBase<TInput1, TInput2, TOutput>, Boolean)
  nameWithType: IncrementalExtensions.ToComputationSource<TInput1, TInput2, TOutput>(TransformationRuleBase<TInput1, TInput2, TOutput>, Boolean)
  fullName: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource<TInput1, TInput2, TOutput>(NMF.Transformations.TransformationRuleBase<TInput1, TInput2, TOutput>, System.Boolean)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/Linq/IncrementalExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ToComputationSource
    path: src/Transformations/Transformations/Linq/IncrementalExtensions.cs
    startLine: 279
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations.Linq
  summary: "\nCreates a new computation source from a transformation rule\n"
  example: []
  syntax:
    content: >-
      public static Func<ITransformationContext, INotifyEnumerable<TransformationComputationWrapper<TInput1, TInput2, TOutput>>> ToComputationSource<TInput1, TInput2, TOutput>(this TransformationRuleBase<TInput1, TInput2, TOutput> rule, bool allowNull)

          where TInput1 : class where TInput2 : class where TOutput : class
    parameters:
    - id: rule
      type: NMF.Transformations.TransformationRuleBase{{TInput1},{TInput2},{TOutput}}
      description: The rule that should be taken as a source of computation objects
    - id: allowNull
      type: System.Boolean
      description: A boolean value indicating whether null values should be allowed
    typeParameters:
    - id: TInput1
      description: The type of the first input arguments for the transformation rule
    - id: TInput2
      description: The type of the second input arguments for the transformation rule
    - id: TOutput
      description: The output type of the transformation rule
    return:
      type: System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{NMF.Transformations.Linq.TransformationComputationWrapper{{TInput1},{TInput2},{TOutput}}}}
      description: A source of computations that can further be dealt with
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToComputationSource(Of TInput1 As Class, TInput2 As Class, TOutput As Class)(rule As TransformationRuleBase(Of TInput1, TInput2, TOutput), allowNull As Boolean) As Func(Of ITransformationContext, INotifyEnumerable(Of TransformationComputationWrapper(Of TInput1, TInput2, TOutput)))
  overload: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource*
  nameWithType.vb: IncrementalExtensions.ToComputationSource(Of TInput1, TInput2, TOutput)(TransformationRuleBase(Of TInput1, TInput2, TOutput), Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource(Of TInput1, TInput2, TOutput)(NMF.Transformations.TransformationRuleBase(Of TInput1, TInput2, TOutput), System.Boolean)
  name.vb: ToComputationSource(Of TInput1, TInput2, TOutput)(TransformationRuleBase(Of TInput1, TInput2, TOutput), Boolean)
- uid: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{``0,``1,``2},System.Boolean})
  commentId: M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{``0,``1,``2},System.Boolean})
  id: ToComputationSource``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{``0,``1,``2},System.Boolean})
  isExtensionMethod: true
  parent: NMF.Transformations.Linq.IncrementalExtensions
  langs:
  - csharp
  - vb
  name: ToComputationSource<TInput1, TInput2, TOutput>(TransformationRuleBase<TInput1, TInput2, TOutput>, Func<TransformationComputationWrapper<TInput1, TInput2, TOutput>, Boolean>)
  nameWithType: IncrementalExtensions.ToComputationSource<TInput1, TInput2, TOutput>(TransformationRuleBase<TInput1, TInput2, TOutput>, Func<TransformationComputationWrapper<TInput1, TInput2, TOutput>, Boolean>)
  fullName: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource<TInput1, TInput2, TOutput>(NMF.Transformations.TransformationRuleBase<TInput1, TInput2, TOutput>, System.Func<NMF.Transformations.Linq.TransformationComputationWrapper<TInput1, TInput2, TOutput>, System.Boolean>)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/Linq/IncrementalExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ToComputationSource
    path: src/Transformations/Transformations/Linq/IncrementalExtensions.cs
    startLine: 298
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations.Linq
  summary: "\nCreates a new computation source from a transformation rule\n"
  example: []
  syntax:
    content: >-
      public static Func<ITransformationContext, INotifyEnumerable<TransformationComputationWrapper<TInput1, TInput2, TOutput>>> ToComputationSource<TInput1, TInput2, TOutput>(this TransformationRuleBase<TInput1, TInput2, TOutput> rule, Func<TransformationComputationWrapper<TInput1, TInput2, TOutput>, bool> filter)

          where TInput1 : class where TInput2 : class where TOutput : class
    parameters:
    - id: rule
      type: NMF.Transformations.TransformationRuleBase{{TInput1},{TInput2},{TOutput}}
      description: The rule that should be taken as a source of computation objects
    - id: filter
      type: System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{{TInput1},{TInput2},{TOutput}},System.Boolean}
      description: A method or lambda expression to filter the computation objects
    typeParameters:
    - id: TInput1
      description: The type of the first input arguments for the transformation rule
    - id: TInput2
      description: The type of the second input arguments for the transformation rule
    - id: TOutput
      description: The output type of the transformation rule
    return:
      type: System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{NMF.Transformations.Linq.TransformationComputationWrapper{{TInput1},{TInput2},{TOutput}}}}
      description: A source of computations that can further be dealt with
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToComputationSource(Of TInput1 As Class, TInput2 As Class, TOutput As Class)(rule As TransformationRuleBase(Of TInput1, TInput2, TOutput), filter As Func(Of TransformationComputationWrapper(Of TInput1, TInput2, TOutput), Boolean)) As Func(Of ITransformationContext, INotifyEnumerable(Of TransformationComputationWrapper(Of TInput1, TInput2, TOutput)))
  overload: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource*
  nameWithType.vb: IncrementalExtensions.ToComputationSource(Of TInput1, TInput2, TOutput)(TransformationRuleBase(Of TInput1, TInput2, TOutput), Func(Of TransformationComputationWrapper(Of TInput1, TInput2, TOutput), Boolean))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource(Of TInput1, TInput2, TOutput)(NMF.Transformations.TransformationRuleBase(Of TInput1, TInput2, TOutput), System.Func(Of NMF.Transformations.Linq.TransformationComputationWrapper(Of TInput1, TInput2, TOutput), System.Boolean))
  name.vb: ToComputationSource(Of TInput1, TInput2, TOutput)(TransformationRuleBase(Of TInput1, TInput2, TOutput), Func(Of TransformationComputationWrapper(Of TInput1, TInput2, TOutput), Boolean))
- uid: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Boolean,System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{``0,``1,``2},System.Boolean})
  commentId: M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Boolean,System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{``0,``1,``2},System.Boolean})
  id: ToComputationSource``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Boolean,System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{``0,``1,``2},System.Boolean})
  isExtensionMethod: true
  parent: NMF.Transformations.Linq.IncrementalExtensions
  langs:
  - csharp
  - vb
  name: ToComputationSource<TInput1, TInput2, TOutput>(TransformationRuleBase<TInput1, TInput2, TOutput>, Boolean, Func<TransformationComputationWrapper<TInput1, TInput2, TOutput>, Boolean>)
  nameWithType: IncrementalExtensions.ToComputationSource<TInput1, TInput2, TOutput>(TransformationRuleBase<TInput1, TInput2, TOutput>, Boolean, Func<TransformationComputationWrapper<TInput1, TInput2, TOutput>, Boolean>)
  fullName: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource<TInput1, TInput2, TOutput>(NMF.Transformations.TransformationRuleBase<TInput1, TInput2, TOutput>, System.Boolean, System.Func<NMF.Transformations.Linq.TransformationComputationWrapper<TInput1, TInput2, TOutput>, System.Boolean>)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/Linq/IncrementalExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ToComputationSource
    path: src/Transformations/Transformations/Linq/IncrementalExtensions.cs
    startLine: 318
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations.Linq
  summary: "\nCreates a new computation source from a transformation rule\n"
  example: []
  syntax:
    content: >-
      public static Func<ITransformationContext, INotifyEnumerable<TransformationComputationWrapper<TInput1, TInput2, TOutput>>> ToComputationSource<TInput1, TInput2, TOutput>(this TransformationRuleBase<TInput1, TInput2, TOutput> rule, bool allowNull, Func<TransformationComputationWrapper<TInput1, TInput2, TOutput>, bool> filter)

          where TInput1 : class where TInput2 : class where TOutput : class
    parameters:
    - id: rule
      type: NMF.Transformations.TransformationRuleBase{{TInput1},{TInput2},{TOutput}}
      description: The rule that should be taken as a source of computation objects
    - id: allowNull
      type: System.Boolean
      description: A boolean value indicating whether null values should be allowed
    - id: filter
      type: System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{{TInput1},{TInput2},{TOutput}},System.Boolean}
      description: A method or lambda expression to filter the computation objects
    typeParameters:
    - id: TInput1
      description: The type of the first input arguments for the transformation rule
    - id: TInput2
      description: The type of the second input arguments for the transformation rule
    - id: TOutput
      description: The output type of the transformation rule
    return:
      type: System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{NMF.Transformations.Linq.TransformationComputationWrapper{{TInput1},{TInput2},{TOutput}}}}
      description: A source of computations that can further be dealt with
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToComputationSource(Of TInput1 As Class, TInput2 As Class, TOutput As Class)(rule As TransformationRuleBase(Of TInput1, TInput2, TOutput), allowNull As Boolean, filter As Func(Of TransformationComputationWrapper(Of TInput1, TInput2, TOutput), Boolean)) As Func(Of ITransformationContext, INotifyEnumerable(Of TransformationComputationWrapper(Of TInput1, TInput2, TOutput)))
  overload: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource*
  nameWithType.vb: IncrementalExtensions.ToComputationSource(Of TInput1, TInput2, TOutput)(TransformationRuleBase(Of TInput1, TInput2, TOutput), Boolean, Func(Of TransformationComputationWrapper(Of TInput1, TInput2, TOutput), Boolean))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource(Of TInput1, TInput2, TOutput)(NMF.Transformations.TransformationRuleBase(Of TInput1, TInput2, TOutput), System.Boolean, System.Func(Of NMF.Transformations.Linq.TransformationComputationWrapper(Of TInput1, TInput2, TOutput), System.Boolean))
  name.vb: ToComputationSource(Of TInput1, TInput2, TOutput)(TransformationRuleBase(Of TInput1, TInput2, TOutput), Boolean, Func(Of TransformationComputationWrapper(Of TInput1, TInput2, TOutput), Boolean))
- uid: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``1(NMF.Transformations.InPlaceTransformationRuleBase{``0},NMF.Transformations.Core.ITransformationContext)
  commentId: M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``1(NMF.Transformations.InPlaceTransformationRuleBase{``0},NMF.Transformations.Core.ITransformationContext)
  id: ToComputationSource``1(NMF.Transformations.InPlaceTransformationRuleBase{``0},NMF.Transformations.Core.ITransformationContext)
  isExtensionMethod: true
  parent: NMF.Transformations.Linq.IncrementalExtensions
  langs:
  - csharp
  - vb
  name: ToComputationSource<TInput>(InPlaceTransformationRuleBase<TInput>, ITransformationContext)
  nameWithType: IncrementalExtensions.ToComputationSource<TInput>(InPlaceTransformationRuleBase<TInput>, ITransformationContext)
  fullName: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource<TInput>(NMF.Transformations.InPlaceTransformationRuleBase<TInput>, NMF.Transformations.Core.ITransformationContext)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/Linq/IncrementalExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ToComputationSource
    path: src/Transformations/Transformations/Linq/IncrementalExtensions.cs
    startLine: 335
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations.Linq
  summary: "\nCreates a new computation source from a transformation rule\n"
  example: []
  syntax:
    content: >-
      public static INotifyEnumerable<InPlaceComputationWrapper<TInput>> ToComputationSource<TInput>(this InPlaceTransformationRuleBase<TInput> rule, ITransformationContext context)

          where TInput : class
    parameters:
    - id: rule
      type: NMF.Transformations.InPlaceTransformationRuleBase{{TInput}}
      description: The rule that should be taken as a source of computation objects
    - id: context
      type: NMF.Transformations.Core.ITransformationContext
      description: The context in which the rule is used as source of computations
    typeParameters:
    - id: TInput
      description: The type of the input arguments for the transformation rule
    return:
      type: INotifyEnumerable{NMF.Transformations.Linq.InPlaceComputationWrapper{{TInput}}}
      description: A source of computations that can further be dealt with
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToComputationSource(Of TInput As Class)(rule As InPlaceTransformationRuleBase(Of TInput), context As ITransformationContext) As INotifyEnumerable(Of InPlaceComputationWrapper(Of TInput))
  overload: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource*
  nameWithType.vb: IncrementalExtensions.ToComputationSource(Of TInput)(InPlaceTransformationRuleBase(Of TInput), ITransformationContext)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource(Of TInput)(NMF.Transformations.InPlaceTransformationRuleBase(Of TInput), NMF.Transformations.Core.ITransformationContext)
  name.vb: ToComputationSource(Of TInput)(InPlaceTransformationRuleBase(Of TInput), ITransformationContext)
- uid: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``1(NMF.Transformations.InPlaceTransformationRuleBase{``0},NMF.Transformations.Core.ITransformationContext,System.Boolean)
  commentId: M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``1(NMF.Transformations.InPlaceTransformationRuleBase{``0},NMF.Transformations.Core.ITransformationContext,System.Boolean)
  id: ToComputationSource``1(NMF.Transformations.InPlaceTransformationRuleBase{``0},NMF.Transformations.Core.ITransformationContext,System.Boolean)
  isExtensionMethod: true
  parent: NMF.Transformations.Linq.IncrementalExtensions
  langs:
  - csharp
  - vb
  name: ToComputationSource<TInput>(InPlaceTransformationRuleBase<TInput>, ITransformationContext, Boolean)
  nameWithType: IncrementalExtensions.ToComputationSource<TInput>(InPlaceTransformationRuleBase<TInput>, ITransformationContext, Boolean)
  fullName: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource<TInput>(NMF.Transformations.InPlaceTransformationRuleBase<TInput>, NMF.Transformations.Core.ITransformationContext, System.Boolean)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/Linq/IncrementalExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ToComputationSource
    path: src/Transformations/Transformations/Linq/IncrementalExtensions.cs
    startLine: 351
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations.Linq
  summary: "\nCreates a new computation source from a transformation rule\n"
  example: []
  syntax:
    content: >-
      public static INotifyEnumerable<InPlaceComputationWrapper<TInput>> ToComputationSource<TInput>(this InPlaceTransformationRuleBase<TInput> rule, ITransformationContext context, bool allowNull)

          where TInput : class
    parameters:
    - id: rule
      type: NMF.Transformations.InPlaceTransformationRuleBase{{TInput}}
      description: The rule that should be taken as a source of computation objects
    - id: context
      type: NMF.Transformations.Core.ITransformationContext
      description: The context in which the rule is used as source of computations
    - id: allowNull
      type: System.Boolean
      description: A boolean value indicating whether null values should be allowed
    typeParameters:
    - id: TInput
      description: The type of the input arguments for the transformation rule
    return:
      type: INotifyEnumerable{NMF.Transformations.Linq.InPlaceComputationWrapper{{TInput}}}
      description: A source of computations that can further be dealt with
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToComputationSource(Of TInput As Class)(rule As InPlaceTransformationRuleBase(Of TInput), context As ITransformationContext, allowNull As Boolean) As INotifyEnumerable(Of InPlaceComputationWrapper(Of TInput))
  overload: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource*
  nameWithType.vb: IncrementalExtensions.ToComputationSource(Of TInput)(InPlaceTransformationRuleBase(Of TInput), ITransformationContext, Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource(Of TInput)(NMF.Transformations.InPlaceTransformationRuleBase(Of TInput), NMF.Transformations.Core.ITransformationContext, System.Boolean)
  name.vb: ToComputationSource(Of TInput)(InPlaceTransformationRuleBase(Of TInput), ITransformationContext, Boolean)
- uid: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``1(NMF.Transformations.InPlaceTransformationRuleBase{``0},NMF.Transformations.Core.ITransformationContext,System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{``0},System.Boolean})
  commentId: M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``1(NMF.Transformations.InPlaceTransformationRuleBase{``0},NMF.Transformations.Core.ITransformationContext,System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{``0},System.Boolean})
  id: ToComputationSource``1(NMF.Transformations.InPlaceTransformationRuleBase{``0},NMF.Transformations.Core.ITransformationContext,System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{``0},System.Boolean})
  isExtensionMethod: true
  parent: NMF.Transformations.Linq.IncrementalExtensions
  langs:
  - csharp
  - vb
  name: ToComputationSource<TInput>(InPlaceTransformationRuleBase<TInput>, ITransformationContext, Func<InPlaceComputationWrapper<TInput>, Boolean>)
  nameWithType: IncrementalExtensions.ToComputationSource<TInput>(InPlaceTransformationRuleBase<TInput>, ITransformationContext, Func<InPlaceComputationWrapper<TInput>, Boolean>)
  fullName: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource<TInput>(NMF.Transformations.InPlaceTransformationRuleBase<TInput>, NMF.Transformations.Core.ITransformationContext, System.Func<NMF.Transformations.Linq.InPlaceComputationWrapper<TInput>, System.Boolean>)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/Linq/IncrementalExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ToComputationSource
    path: src/Transformations/Transformations/Linq/IncrementalExtensions.cs
    startLine: 370
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations.Linq
  summary: "\nCreates a new computation source from a transformation rule\n"
  example: []
  syntax:
    content: >-
      public static INotifyEnumerable<InPlaceComputationWrapper<TInput>> ToComputationSource<TInput>(this InPlaceTransformationRuleBase<TInput> rule, ITransformationContext context, Func<InPlaceComputationWrapper<TInput>, bool> filter)

          where TInput : class
    parameters:
    - id: rule
      type: NMF.Transformations.InPlaceTransformationRuleBase{{TInput}}
      description: The rule that should be taken as a source of computation objects
    - id: context
      type: NMF.Transformations.Core.ITransformationContext
      description: The context in which the rule is used as source of computations
    - id: filter
      type: System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{{TInput}},System.Boolean}
      description: A method or lambda expression to filter the computation objects
    typeParameters:
    - id: TInput
      description: The type of the input arguments for the transformation rule
    return:
      type: INotifyEnumerable{NMF.Transformations.Linq.InPlaceComputationWrapper{{TInput}}}
      description: A source of computations that can further be dealt with
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToComputationSource(Of TInput As Class)(rule As InPlaceTransformationRuleBase(Of TInput), context As ITransformationContext, filter As Func(Of InPlaceComputationWrapper(Of TInput), Boolean)) As INotifyEnumerable(Of InPlaceComputationWrapper(Of TInput))
  overload: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource*
  nameWithType.vb: IncrementalExtensions.ToComputationSource(Of TInput)(InPlaceTransformationRuleBase(Of TInput), ITransformationContext, Func(Of InPlaceComputationWrapper(Of TInput), Boolean))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource(Of TInput)(NMF.Transformations.InPlaceTransformationRuleBase(Of TInput), NMF.Transformations.Core.ITransformationContext, System.Func(Of NMF.Transformations.Linq.InPlaceComputationWrapper(Of TInput), System.Boolean))
  name.vb: ToComputationSource(Of TInput)(InPlaceTransformationRuleBase(Of TInput), ITransformationContext, Func(Of InPlaceComputationWrapper(Of TInput), Boolean))
- uid: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``1(NMF.Transformations.InPlaceTransformationRuleBase{``0},NMF.Transformations.Core.ITransformationContext,System.Boolean,System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{``0},System.Boolean})
  commentId: M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``1(NMF.Transformations.InPlaceTransformationRuleBase{``0},NMF.Transformations.Core.ITransformationContext,System.Boolean,System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{``0},System.Boolean})
  id: ToComputationSource``1(NMF.Transformations.InPlaceTransformationRuleBase{``0},NMF.Transformations.Core.ITransformationContext,System.Boolean,System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{``0},System.Boolean})
  isExtensionMethod: true
  parent: NMF.Transformations.Linq.IncrementalExtensions
  langs:
  - csharp
  - vb
  name: ToComputationSource<TInput>(InPlaceTransformationRuleBase<TInput>, ITransformationContext, Boolean, Func<InPlaceComputationWrapper<TInput>, Boolean>)
  nameWithType: IncrementalExtensions.ToComputationSource<TInput>(InPlaceTransformationRuleBase<TInput>, ITransformationContext, Boolean, Func<InPlaceComputationWrapper<TInput>, Boolean>)
  fullName: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource<TInput>(NMF.Transformations.InPlaceTransformationRuleBase<TInput>, NMF.Transformations.Core.ITransformationContext, System.Boolean, System.Func<NMF.Transformations.Linq.InPlaceComputationWrapper<TInput>, System.Boolean>)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/Linq/IncrementalExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ToComputationSource
    path: src/Transformations/Transformations/Linq/IncrementalExtensions.cs
    startLine: 388
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations.Linq
  summary: "\nCreates a new computation source from a transformation rule\n"
  example: []
  syntax:
    content: >-
      public static INotifyEnumerable<InPlaceComputationWrapper<TInput>> ToComputationSource<TInput>(this InPlaceTransformationRuleBase<TInput> rule, ITransformationContext context, bool allowNull, Func<InPlaceComputationWrapper<TInput>, bool> filter)

          where TInput : class
    parameters:
    - id: rule
      type: NMF.Transformations.InPlaceTransformationRuleBase{{TInput}}
      description: The rule that should be taken as a source of computation objects
    - id: context
      type: NMF.Transformations.Core.ITransformationContext
      description: The context in which the rule is used as source of computations
    - id: allowNull
      type: System.Boolean
      description: A boolean value indicating whether null values should be allowed
    - id: filter
      type: System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{{TInput}},System.Boolean}
      description: A method or lambda expression to filter the computation objects
    typeParameters:
    - id: TInput
      description: The type of the input arguments for the transformation rule
    return:
      type: INotifyEnumerable{NMF.Transformations.Linq.InPlaceComputationWrapper{{TInput}}}
      description: A source of computations that can further be dealt with
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToComputationSource(Of TInput As Class)(rule As InPlaceTransformationRuleBase(Of TInput), context As ITransformationContext, allowNull As Boolean, filter As Func(Of InPlaceComputationWrapper(Of TInput), Boolean)) As INotifyEnumerable(Of InPlaceComputationWrapper(Of TInput))
  overload: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource*
  nameWithType.vb: IncrementalExtensions.ToComputationSource(Of TInput)(InPlaceTransformationRuleBase(Of TInput), ITransformationContext, Boolean, Func(Of InPlaceComputationWrapper(Of TInput), Boolean))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource(Of TInput)(NMF.Transformations.InPlaceTransformationRuleBase(Of TInput), NMF.Transformations.Core.ITransformationContext, System.Boolean, System.Func(Of NMF.Transformations.Linq.InPlaceComputationWrapper(Of TInput), System.Boolean))
  name.vb: ToComputationSource(Of TInput)(InPlaceTransformationRuleBase(Of TInput), ITransformationContext, Boolean, Func(Of InPlaceComputationWrapper(Of TInput), Boolean))
- uid: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.InPlaceTransformationRuleBase{``0,``1},NMF.Transformations.Core.ITransformationContext)
  commentId: M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.InPlaceTransformationRuleBase{``0,``1},NMF.Transformations.Core.ITransformationContext)
  id: ToComputationSource``2(NMF.Transformations.InPlaceTransformationRuleBase{``0,``1},NMF.Transformations.Core.ITransformationContext)
  isExtensionMethod: true
  parent: NMF.Transformations.Linq.IncrementalExtensions
  langs:
  - csharp
  - vb
  name: ToComputationSource<TInput1, TInput2>(InPlaceTransformationRuleBase<TInput1, TInput2>, ITransformationContext)
  nameWithType: IncrementalExtensions.ToComputationSource<TInput1, TInput2>(InPlaceTransformationRuleBase<TInput1, TInput2>, ITransformationContext)
  fullName: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource<TInput1, TInput2>(NMF.Transformations.InPlaceTransformationRuleBase<TInput1, TInput2>, NMF.Transformations.Core.ITransformationContext)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/Linq/IncrementalExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ToComputationSource
    path: src/Transformations/Transformations/Linq/IncrementalExtensions.cs
    startLine: 407
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations.Linq
  summary: "\nCreates a new computation source from a transformation rule\n"
  example: []
  syntax:
    content: >-
      public static INotifyEnumerable<InPlaceComputationWrapper<TInput1, TInput2>> ToComputationSource<TInput1, TInput2>(this InPlaceTransformationRuleBase<TInput1, TInput2> rule, ITransformationContext context)

          where TInput1 : class where TInput2 : class
    parameters:
    - id: rule
      type: NMF.Transformations.InPlaceTransformationRuleBase{{TInput1},{TInput2}}
      description: The rule that should be taken as a source of computation objects
    - id: context
      type: NMF.Transformations.Core.ITransformationContext
      description: The context in which the rule is used as source of computations
    typeParameters:
    - id: TInput1
      description: The type of the first input arguments for the transformation rule
    - id: TInput2
      description: The type of the second input arguments for the transformation rule
    return:
      type: INotifyEnumerable{NMF.Transformations.Linq.InPlaceComputationWrapper{{TInput1},{TInput2}}}
      description: A source of computations that can further be dealt with
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToComputationSource(Of TInput1 As Class, TInput2 As Class)(rule As InPlaceTransformationRuleBase(Of TInput1, TInput2), context As ITransformationContext) As INotifyEnumerable(Of InPlaceComputationWrapper(Of TInput1, TInput2))
  overload: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource*
  nameWithType.vb: IncrementalExtensions.ToComputationSource(Of TInput1, TInput2)(InPlaceTransformationRuleBase(Of TInput1, TInput2), ITransformationContext)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource(Of TInput1, TInput2)(NMF.Transformations.InPlaceTransformationRuleBase(Of TInput1, TInput2), NMF.Transformations.Core.ITransformationContext)
  name.vb: ToComputationSource(Of TInput1, TInput2)(InPlaceTransformationRuleBase(Of TInput1, TInput2), ITransformationContext)
- uid: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.InPlaceTransformationRuleBase{``0,``1},NMF.Transformations.Core.ITransformationContext,System.Boolean)
  commentId: M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.InPlaceTransformationRuleBase{``0,``1},NMF.Transformations.Core.ITransformationContext,System.Boolean)
  id: ToComputationSource``2(NMF.Transformations.InPlaceTransformationRuleBase{``0,``1},NMF.Transformations.Core.ITransformationContext,System.Boolean)
  isExtensionMethod: true
  parent: NMF.Transformations.Linq.IncrementalExtensions
  langs:
  - csharp
  - vb
  name: ToComputationSource<TInput1, TInput2>(InPlaceTransformationRuleBase<TInput1, TInput2>, ITransformationContext, Boolean)
  nameWithType: IncrementalExtensions.ToComputationSource<TInput1, TInput2>(InPlaceTransformationRuleBase<TInput1, TInput2>, ITransformationContext, Boolean)
  fullName: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource<TInput1, TInput2>(NMF.Transformations.InPlaceTransformationRuleBase<TInput1, TInput2>, NMF.Transformations.Core.ITransformationContext, System.Boolean)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/Linq/IncrementalExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ToComputationSource
    path: src/Transformations/Transformations/Linq/IncrementalExtensions.cs
    startLine: 425
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations.Linq
  summary: "\nCreates a new computation source from a transformation rule\n"
  example: []
  syntax:
    content: >-
      public static INotifyEnumerable<InPlaceComputationWrapper<TInput1, TInput2>> ToComputationSource<TInput1, TInput2>(this InPlaceTransformationRuleBase<TInput1, TInput2> rule, ITransformationContext context, bool allowNull)

          where TInput1 : class where TInput2 : class
    parameters:
    - id: rule
      type: NMF.Transformations.InPlaceTransformationRuleBase{{TInput1},{TInput2}}
      description: The rule that should be taken as a source of computation objects
    - id: context
      type: NMF.Transformations.Core.ITransformationContext
      description: The context in which the rule is used as source of computations
    - id: allowNull
      type: System.Boolean
      description: A boolean value indicating whether null values should be allowed
    typeParameters:
    - id: TInput1
      description: The type of the first input arguments for the transformation rule
    - id: TInput2
      description: The type of the second input arguments for the transformation rule
    return:
      type: INotifyEnumerable{NMF.Transformations.Linq.InPlaceComputationWrapper{{TInput1},{TInput2}}}
      description: A source of computations that can further be dealt with
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToComputationSource(Of TInput1 As Class, TInput2 As Class)(rule As InPlaceTransformationRuleBase(Of TInput1, TInput2), context As ITransformationContext, allowNull As Boolean) As INotifyEnumerable(Of InPlaceComputationWrapper(Of TInput1, TInput2))
  overload: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource*
  nameWithType.vb: IncrementalExtensions.ToComputationSource(Of TInput1, TInput2)(InPlaceTransformationRuleBase(Of TInput1, TInput2), ITransformationContext, Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource(Of TInput1, TInput2)(NMF.Transformations.InPlaceTransformationRuleBase(Of TInput1, TInput2), NMF.Transformations.Core.ITransformationContext, System.Boolean)
  name.vb: ToComputationSource(Of TInput1, TInput2)(InPlaceTransformationRuleBase(Of TInput1, TInput2), ITransformationContext, Boolean)
- uid: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.InPlaceTransformationRuleBase{``0,``1},NMF.Transformations.Core.ITransformationContext,System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{``0,``1},System.Boolean})
  commentId: M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.InPlaceTransformationRuleBase{``0,``1},NMF.Transformations.Core.ITransformationContext,System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{``0,``1},System.Boolean})
  id: ToComputationSource``2(NMF.Transformations.InPlaceTransformationRuleBase{``0,``1},NMF.Transformations.Core.ITransformationContext,System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{``0,``1},System.Boolean})
  isExtensionMethod: true
  parent: NMF.Transformations.Linq.IncrementalExtensions
  langs:
  - csharp
  - vb
  name: ToComputationSource<TInput1, TInput2>(InPlaceTransformationRuleBase<TInput1, TInput2>, ITransformationContext, Func<InPlaceComputationWrapper<TInput1, TInput2>, Boolean>)
  nameWithType: IncrementalExtensions.ToComputationSource<TInput1, TInput2>(InPlaceTransformationRuleBase<TInput1, TInput2>, ITransformationContext, Func<InPlaceComputationWrapper<TInput1, TInput2>, Boolean>)
  fullName: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource<TInput1, TInput2>(NMF.Transformations.InPlaceTransformationRuleBase<TInput1, TInput2>, NMF.Transformations.Core.ITransformationContext, System.Func<NMF.Transformations.Linq.InPlaceComputationWrapper<TInput1, TInput2>, System.Boolean>)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/Linq/IncrementalExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ToComputationSource
    path: src/Transformations/Transformations/Linq/IncrementalExtensions.cs
    startLine: 446
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations.Linq
  summary: "\nCreates a new computation source from a transformation rule\n"
  example: []
  syntax:
    content: >-
      public static INotifyEnumerable<InPlaceComputationWrapper<TInput1, TInput2>> ToComputationSource<TInput1, TInput2>(this InPlaceTransformationRuleBase<TInput1, TInput2> rule, ITransformationContext context, Func<InPlaceComputationWrapper<TInput1, TInput2>, bool> filter)

          where TInput1 : class where TInput2 : class
    parameters:
    - id: rule
      type: NMF.Transformations.InPlaceTransformationRuleBase{{TInput1},{TInput2}}
      description: The rule that should be taken as a source of computation objects
    - id: context
      type: NMF.Transformations.Core.ITransformationContext
      description: The context in which the rule is used as source of computations
    - id: filter
      type: System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{{TInput1},{TInput2}},System.Boolean}
      description: A method or lambda expression to filter the computation objects
    typeParameters:
    - id: TInput1
      description: The type of the first input arguments for the transformation rule
    - id: TInput2
      description: The type of the second input arguments for the transformation rule
    return:
      type: INotifyEnumerable{NMF.Transformations.Linq.InPlaceComputationWrapper{{TInput1},{TInput2}}}
      description: A source of computations that can further be dealt with
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToComputationSource(Of TInput1 As Class, TInput2 As Class)(rule As InPlaceTransformationRuleBase(Of TInput1, TInput2), context As ITransformationContext, filter As Func(Of InPlaceComputationWrapper(Of TInput1, TInput2), Boolean)) As INotifyEnumerable(Of InPlaceComputationWrapper(Of TInput1, TInput2))
  overload: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource*
  nameWithType.vb: IncrementalExtensions.ToComputationSource(Of TInput1, TInput2)(InPlaceTransformationRuleBase(Of TInput1, TInput2), ITransformationContext, Func(Of InPlaceComputationWrapper(Of TInput1, TInput2), Boolean))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource(Of TInput1, TInput2)(NMF.Transformations.InPlaceTransformationRuleBase(Of TInput1, TInput2), NMF.Transformations.Core.ITransformationContext, System.Func(Of NMF.Transformations.Linq.InPlaceComputationWrapper(Of TInput1, TInput2), System.Boolean))
  name.vb: ToComputationSource(Of TInput1, TInput2)(InPlaceTransformationRuleBase(Of TInput1, TInput2), ITransformationContext, Func(Of InPlaceComputationWrapper(Of TInput1, TInput2), Boolean))
- uid: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.InPlaceTransformationRuleBase{``0,``1},NMF.Transformations.Core.ITransformationContext,System.Boolean,System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{``0,``1},System.Boolean})
  commentId: M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.InPlaceTransformationRuleBase{``0,``1},NMF.Transformations.Core.ITransformationContext,System.Boolean,System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{``0,``1},System.Boolean})
  id: ToComputationSource``2(NMF.Transformations.InPlaceTransformationRuleBase{``0,``1},NMF.Transformations.Core.ITransformationContext,System.Boolean,System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{``0,``1},System.Boolean})
  isExtensionMethod: true
  parent: NMF.Transformations.Linq.IncrementalExtensions
  langs:
  - csharp
  - vb
  name: ToComputationSource<TInput1, TInput2>(InPlaceTransformationRuleBase<TInput1, TInput2>, ITransformationContext, Boolean, Func<InPlaceComputationWrapper<TInput1, TInput2>, Boolean>)
  nameWithType: IncrementalExtensions.ToComputationSource<TInput1, TInput2>(InPlaceTransformationRuleBase<TInput1, TInput2>, ITransformationContext, Boolean, Func<InPlaceComputationWrapper<TInput1, TInput2>, Boolean>)
  fullName: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource<TInput1, TInput2>(NMF.Transformations.InPlaceTransformationRuleBase<TInput1, TInput2>, NMF.Transformations.Core.ITransformationContext, System.Boolean, System.Func<NMF.Transformations.Linq.InPlaceComputationWrapper<TInput1, TInput2>, System.Boolean>)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/Linq/IncrementalExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ToComputationSource
    path: src/Transformations/Transformations/Linq/IncrementalExtensions.cs
    startLine: 466
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations.Linq
  summary: "\nCreates a new computation source from a transformation rule\n"
  example: []
  syntax:
    content: >-
      public static INotifyEnumerable<InPlaceComputationWrapper<TInput1, TInput2>> ToComputationSource<TInput1, TInput2>(this InPlaceTransformationRuleBase<TInput1, TInput2> rule, ITransformationContext context, bool allowNull, Func<InPlaceComputationWrapper<TInput1, TInput2>, bool> filter)

          where TInput1 : class where TInput2 : class
    parameters:
    - id: rule
      type: NMF.Transformations.InPlaceTransformationRuleBase{{TInput1},{TInput2}}
      description: The rule that should be taken as a source of computation objects
    - id: context
      type: NMF.Transformations.Core.ITransformationContext
      description: The context in which the rule is used as source of computations
    - id: allowNull
      type: System.Boolean
      description: A boolean value indicating whether null values should be allowed
    - id: filter
      type: System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{{TInput1},{TInput2}},System.Boolean}
      description: A method or lambda expression to filter the computation objects
    typeParameters:
    - id: TInput1
      description: The type of the first input arguments for the transformation rule
    - id: TInput2
      description: The type of the second input arguments for the transformation rule
    return:
      type: INotifyEnumerable{NMF.Transformations.Linq.InPlaceComputationWrapper{{TInput1},{TInput2}}}
      description: A source of computations that can further be dealt with
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToComputationSource(Of TInput1 As Class, TInput2 As Class)(rule As InPlaceTransformationRuleBase(Of TInput1, TInput2), context As ITransformationContext, allowNull As Boolean, filter As Func(Of InPlaceComputationWrapper(Of TInput1, TInput2), Boolean)) As INotifyEnumerable(Of InPlaceComputationWrapper(Of TInput1, TInput2))
  overload: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource*
  nameWithType.vb: IncrementalExtensions.ToComputationSource(Of TInput1, TInput2)(InPlaceTransformationRuleBase(Of TInput1, TInput2), ITransformationContext, Boolean, Func(Of InPlaceComputationWrapper(Of TInput1, TInput2), Boolean))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource(Of TInput1, TInput2)(NMF.Transformations.InPlaceTransformationRuleBase(Of TInput1, TInput2), NMF.Transformations.Core.ITransformationContext, System.Boolean, System.Func(Of NMF.Transformations.Linq.InPlaceComputationWrapper(Of TInput1, TInput2), System.Boolean))
  name.vb: ToComputationSource(Of TInput1, TInput2)(InPlaceTransformationRuleBase(Of TInput1, TInput2), ITransformationContext, Boolean, Func(Of InPlaceComputationWrapper(Of TInput1, TInput2), Boolean))
- uid: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``1(NMF.Transformations.InPlaceTransformationRuleBase{``0})
  commentId: M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``1(NMF.Transformations.InPlaceTransformationRuleBase{``0})
  id: ToComputationSource``1(NMF.Transformations.InPlaceTransformationRuleBase{``0})
  isExtensionMethod: true
  parent: NMF.Transformations.Linq.IncrementalExtensions
  langs:
  - csharp
  - vb
  name: ToComputationSource<TInput>(InPlaceTransformationRuleBase<TInput>)
  nameWithType: IncrementalExtensions.ToComputationSource<TInput>(InPlaceTransformationRuleBase<TInput>)
  fullName: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource<TInput>(NMF.Transformations.InPlaceTransformationRuleBase<TInput>)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/Linq/IncrementalExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ToComputationSource
    path: src/Transformations/Transformations/Linq/IncrementalExtensions.cs
    startLine: 484
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations.Linq
  summary: "\nCreates a new computation source from a transformation rule\n"
  example: []
  syntax:
    content: >-
      public static Func<ITransformationContext, INotifyEnumerable<InPlaceComputationWrapper<TInput>>> ToComputationSource<TInput>(this InPlaceTransformationRuleBase<TInput> rule)

          where TInput : class
    parameters:
    - id: rule
      type: NMF.Transformations.InPlaceTransformationRuleBase{{TInput}}
      description: The rule that should be taken as a source of computation objects
    typeParameters:
    - id: TInput
      description: The type of the input arguments for the transformation rule
    return:
      type: System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{NMF.Transformations.Linq.InPlaceComputationWrapper{{TInput}}}}
      description: A source of computations that can further be dealt with
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToComputationSource(Of TInput As Class)(rule As InPlaceTransformationRuleBase(Of TInput)) As Func(Of ITransformationContext, INotifyEnumerable(Of InPlaceComputationWrapper(Of TInput)))
  overload: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource*
  nameWithType.vb: IncrementalExtensions.ToComputationSource(Of TInput)(InPlaceTransformationRuleBase(Of TInput))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource(Of TInput)(NMF.Transformations.InPlaceTransformationRuleBase(Of TInput))
  name.vb: ToComputationSource(Of TInput)(InPlaceTransformationRuleBase(Of TInput))
- uid: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``1(NMF.Transformations.InPlaceTransformationRuleBase{``0},System.Boolean)
  commentId: M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``1(NMF.Transformations.InPlaceTransformationRuleBase{``0},System.Boolean)
  id: ToComputationSource``1(NMF.Transformations.InPlaceTransformationRuleBase{``0},System.Boolean)
  isExtensionMethod: true
  parent: NMF.Transformations.Linq.IncrementalExtensions
  langs:
  - csharp
  - vb
  name: ToComputationSource<TInput>(InPlaceTransformationRuleBase<TInput>, Boolean)
  nameWithType: IncrementalExtensions.ToComputationSource<TInput>(InPlaceTransformationRuleBase<TInput>, Boolean)
  fullName: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource<TInput>(NMF.Transformations.InPlaceTransformationRuleBase<TInput>, System.Boolean)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/Linq/IncrementalExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ToComputationSource
    path: src/Transformations/Transformations/Linq/IncrementalExtensions.cs
    startLine: 500
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations.Linq
  summary: "\nCreates a new computation source from a transformation rule\n"
  example: []
  syntax:
    content: >-
      public static Func<ITransformationContext, INotifyEnumerable<InPlaceComputationWrapper<TInput>>> ToComputationSource<TInput>(this InPlaceTransformationRuleBase<TInput> rule, bool allowNull)

          where TInput : class
    parameters:
    - id: rule
      type: NMF.Transformations.InPlaceTransformationRuleBase{{TInput}}
      description: The rule that should be taken as a source of computation objects
    - id: allowNull
      type: System.Boolean
      description: A boolean value indicating whether null values should be allowed
    typeParameters:
    - id: TInput
      description: The type of the input arguments for the transformation rule
    return:
      type: System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{NMF.Transformations.Linq.InPlaceComputationWrapper{{TInput}}}}
      description: A source of computations that can further be dealt with
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToComputationSource(Of TInput As Class)(rule As InPlaceTransformationRuleBase(Of TInput), allowNull As Boolean) As Func(Of ITransformationContext, INotifyEnumerable(Of InPlaceComputationWrapper(Of TInput)))
  overload: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource*
  nameWithType.vb: IncrementalExtensions.ToComputationSource(Of TInput)(InPlaceTransformationRuleBase(Of TInput), Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource(Of TInput)(NMF.Transformations.InPlaceTransformationRuleBase(Of TInput), System.Boolean)
  name.vb: ToComputationSource(Of TInput)(InPlaceTransformationRuleBase(Of TInput), Boolean)
- uid: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``1(NMF.Transformations.InPlaceTransformationRuleBase{``0},System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{``0},System.Boolean})
  commentId: M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``1(NMF.Transformations.InPlaceTransformationRuleBase{``0},System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{``0},System.Boolean})
  id: ToComputationSource``1(NMF.Transformations.InPlaceTransformationRuleBase{``0},System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{``0},System.Boolean})
  isExtensionMethod: true
  parent: NMF.Transformations.Linq.IncrementalExtensions
  langs:
  - csharp
  - vb
  name: ToComputationSource<TInput>(InPlaceTransformationRuleBase<TInput>, Func<InPlaceComputationWrapper<TInput>, Boolean>)
  nameWithType: IncrementalExtensions.ToComputationSource<TInput>(InPlaceTransformationRuleBase<TInput>, Func<InPlaceComputationWrapper<TInput>, Boolean>)
  fullName: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource<TInput>(NMF.Transformations.InPlaceTransformationRuleBase<TInput>, System.Func<NMF.Transformations.Linq.InPlaceComputationWrapper<TInput>, System.Boolean>)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/Linq/IncrementalExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ToComputationSource
    path: src/Transformations/Transformations/Linq/IncrementalExtensions.cs
    startLine: 516
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations.Linq
  summary: "\nCreates a new computation source from a transformation rule\n"
  example: []
  syntax:
    content: >-
      public static Func<ITransformationContext, INotifyEnumerable<InPlaceComputationWrapper<TInput>>> ToComputationSource<TInput>(this InPlaceTransformationRuleBase<TInput> rule, Func<InPlaceComputationWrapper<TInput>, bool> filter)

          where TInput : class
    parameters:
    - id: rule
      type: NMF.Transformations.InPlaceTransformationRuleBase{{TInput}}
      description: The rule that should be taken as a source of computation objects
    - id: filter
      type: System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{{TInput}},System.Boolean}
      description: A method or lambda expression to filter the computation objects
    typeParameters:
    - id: TInput
      description: The type of the input arguments for the transformation rule
    return:
      type: System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{NMF.Transformations.Linq.InPlaceComputationWrapper{{TInput}}}}
      description: A source of computations that can further be dealt with
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToComputationSource(Of TInput As Class)(rule As InPlaceTransformationRuleBase(Of TInput), filter As Func(Of InPlaceComputationWrapper(Of TInput), Boolean)) As Func(Of ITransformationContext, INotifyEnumerable(Of InPlaceComputationWrapper(Of TInput)))
  overload: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource*
  nameWithType.vb: IncrementalExtensions.ToComputationSource(Of TInput)(InPlaceTransformationRuleBase(Of TInput), Func(Of InPlaceComputationWrapper(Of TInput), Boolean))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource(Of TInput)(NMF.Transformations.InPlaceTransformationRuleBase(Of TInput), System.Func(Of NMF.Transformations.Linq.InPlaceComputationWrapper(Of TInput), System.Boolean))
  name.vb: ToComputationSource(Of TInput)(InPlaceTransformationRuleBase(Of TInput), Func(Of InPlaceComputationWrapper(Of TInput), Boolean))
- uid: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``1(NMF.Transformations.InPlaceTransformationRuleBase{``0},System.Boolean,System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{``0},System.Boolean})
  commentId: M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``1(NMF.Transformations.InPlaceTransformationRuleBase{``0},System.Boolean,System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{``0},System.Boolean})
  id: ToComputationSource``1(NMF.Transformations.InPlaceTransformationRuleBase{``0},System.Boolean,System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{``0},System.Boolean})
  isExtensionMethod: true
  parent: NMF.Transformations.Linq.IncrementalExtensions
  langs:
  - csharp
  - vb
  name: ToComputationSource<TInput>(InPlaceTransformationRuleBase<TInput>, Boolean, Func<InPlaceComputationWrapper<TInput>, Boolean>)
  nameWithType: IncrementalExtensions.ToComputationSource<TInput>(InPlaceTransformationRuleBase<TInput>, Boolean, Func<InPlaceComputationWrapper<TInput>, Boolean>)
  fullName: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource<TInput>(NMF.Transformations.InPlaceTransformationRuleBase<TInput>, System.Boolean, System.Func<NMF.Transformations.Linq.InPlaceComputationWrapper<TInput>, System.Boolean>)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/Linq/IncrementalExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ToComputationSource
    path: src/Transformations/Transformations/Linq/IncrementalExtensions.cs
    startLine: 533
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations.Linq
  summary: "\nCreates a new computation source from a transformation rule\n"
  example: []
  syntax:
    content: >-
      public static Func<ITransformationContext, INotifyEnumerable<InPlaceComputationWrapper<TInput>>> ToComputationSource<TInput>(this InPlaceTransformationRuleBase<TInput> rule, bool allowNull, Func<InPlaceComputationWrapper<TInput>, bool> filter)

          where TInput : class
    parameters:
    - id: rule
      type: NMF.Transformations.InPlaceTransformationRuleBase{{TInput}}
      description: The rule that should be taken as a source of computation objects
    - id: allowNull
      type: System.Boolean
      description: A boolean value indicating whether null values should be allowed
    - id: filter
      type: System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{{TInput}},System.Boolean}
      description: A method or lambda expression to filter the computation objects
    typeParameters:
    - id: TInput
      description: The type of the input arguments for the transformation rule
    return:
      type: System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{NMF.Transformations.Linq.InPlaceComputationWrapper{{TInput}}}}
      description: A source of computations that can further be dealt with
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToComputationSource(Of TInput As Class)(rule As InPlaceTransformationRuleBase(Of TInput), allowNull As Boolean, filter As Func(Of InPlaceComputationWrapper(Of TInput), Boolean)) As Func(Of ITransformationContext, INotifyEnumerable(Of InPlaceComputationWrapper(Of TInput)))
  overload: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource*
  nameWithType.vb: IncrementalExtensions.ToComputationSource(Of TInput)(InPlaceTransformationRuleBase(Of TInput), Boolean, Func(Of InPlaceComputationWrapper(Of TInput), Boolean))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource(Of TInput)(NMF.Transformations.InPlaceTransformationRuleBase(Of TInput), System.Boolean, System.Func(Of NMF.Transformations.Linq.InPlaceComputationWrapper(Of TInput), System.Boolean))
  name.vb: ToComputationSource(Of TInput)(InPlaceTransformationRuleBase(Of TInput), Boolean, Func(Of InPlaceComputationWrapper(Of TInput), Boolean))
- uid: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.InPlaceTransformationRuleBase{``0,``1})
  commentId: M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.InPlaceTransformationRuleBase{``0,``1})
  id: ToComputationSource``2(NMF.Transformations.InPlaceTransformationRuleBase{``0,``1})
  isExtensionMethod: true
  parent: NMF.Transformations.Linq.IncrementalExtensions
  langs:
  - csharp
  - vb
  name: ToComputationSource<TInput1, TInput2>(InPlaceTransformationRuleBase<TInput1, TInput2>)
  nameWithType: IncrementalExtensions.ToComputationSource<TInput1, TInput2>(InPlaceTransformationRuleBase<TInput1, TInput2>)
  fullName: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource<TInput1, TInput2>(NMF.Transformations.InPlaceTransformationRuleBase<TInput1, TInput2>)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/Linq/IncrementalExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ToComputationSource
    path: src/Transformations/Transformations/Linq/IncrementalExtensions.cs
    startLine: 549
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations.Linq
  summary: "\nCreates a new computation source from a transformation rule\n"
  example: []
  syntax:
    content: >-
      public static Func<ITransformationContext, INotifyEnumerable<InPlaceComputationWrapper<TInput1, TInput2>>> ToComputationSource<TInput1, TInput2>(this InPlaceTransformationRuleBase<TInput1, TInput2> rule)

          where TInput1 : class where TInput2 : class
    parameters:
    - id: rule
      type: NMF.Transformations.InPlaceTransformationRuleBase{{TInput1},{TInput2}}
      description: The rule that should be taken as a source of computation objects
    typeParameters:
    - id: TInput1
      description: The type of the first input arguments for the transformation rule
    - id: TInput2
      description: The type of the second input arguments for the transformation rule
    return:
      type: System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{NMF.Transformations.Linq.InPlaceComputationWrapper{{TInput1},{TInput2}}}}
      description: A source of computations that can further be dealt with
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToComputationSource(Of TInput1 As Class, TInput2 As Class)(rule As InPlaceTransformationRuleBase(Of TInput1, TInput2)) As Func(Of ITransformationContext, INotifyEnumerable(Of InPlaceComputationWrapper(Of TInput1, TInput2)))
  overload: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource*
  nameWithType.vb: IncrementalExtensions.ToComputationSource(Of TInput1, TInput2)(InPlaceTransformationRuleBase(Of TInput1, TInput2))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource(Of TInput1, TInput2)(NMF.Transformations.InPlaceTransformationRuleBase(Of TInput1, TInput2))
  name.vb: ToComputationSource(Of TInput1, TInput2)(InPlaceTransformationRuleBase(Of TInput1, TInput2))
- uid: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.InPlaceTransformationRuleBase{``0,``1},System.Boolean)
  commentId: M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.InPlaceTransformationRuleBase{``0,``1},System.Boolean)
  id: ToComputationSource``2(NMF.Transformations.InPlaceTransformationRuleBase{``0,``1},System.Boolean)
  isExtensionMethod: true
  parent: NMF.Transformations.Linq.IncrementalExtensions
  langs:
  - csharp
  - vb
  name: ToComputationSource<TInput1, TInput2>(InPlaceTransformationRuleBase<TInput1, TInput2>, Boolean)
  nameWithType: IncrementalExtensions.ToComputationSource<TInput1, TInput2>(InPlaceTransformationRuleBase<TInput1, TInput2>, Boolean)
  fullName: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource<TInput1, TInput2>(NMF.Transformations.InPlaceTransformationRuleBase<TInput1, TInput2>, System.Boolean)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/Linq/IncrementalExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ToComputationSource
    path: src/Transformations/Transformations/Linq/IncrementalExtensions.cs
    startLine: 566
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations.Linq
  summary: "\nCreates a new computation source from a transformation rule\n"
  example: []
  syntax:
    content: >-
      public static Func<ITransformationContext, INotifyEnumerable<InPlaceComputationWrapper<TInput1, TInput2>>> ToComputationSource<TInput1, TInput2>(this InPlaceTransformationRuleBase<TInput1, TInput2> rule, bool allowNull)

          where TInput1 : class where TInput2 : class
    parameters:
    - id: rule
      type: NMF.Transformations.InPlaceTransformationRuleBase{{TInput1},{TInput2}}
      description: The rule that should be taken as a source of computation objects
    - id: allowNull
      type: System.Boolean
      description: A boolean value indicating whether null values should be allowed
    typeParameters:
    - id: TInput1
      description: The type of the first input arguments for the transformation rule
    - id: TInput2
      description: The type of the second input arguments for the transformation rule
    return:
      type: System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{NMF.Transformations.Linq.InPlaceComputationWrapper{{TInput1},{TInput2}}}}
      description: A source of computations that can further be dealt with
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToComputationSource(Of TInput1 As Class, TInput2 As Class)(rule As InPlaceTransformationRuleBase(Of TInput1, TInput2), allowNull As Boolean) As Func(Of ITransformationContext, INotifyEnumerable(Of InPlaceComputationWrapper(Of TInput1, TInput2)))
  overload: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource*
  nameWithType.vb: IncrementalExtensions.ToComputationSource(Of TInput1, TInput2)(InPlaceTransformationRuleBase(Of TInput1, TInput2), Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource(Of TInput1, TInput2)(NMF.Transformations.InPlaceTransformationRuleBase(Of TInput1, TInput2), System.Boolean)
  name.vb: ToComputationSource(Of TInput1, TInput2)(InPlaceTransformationRuleBase(Of TInput1, TInput2), Boolean)
- uid: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.InPlaceTransformationRuleBase{``0,``1},System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{``0,``1},System.Boolean})
  commentId: M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.InPlaceTransformationRuleBase{``0,``1},System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{``0,``1},System.Boolean})
  id: ToComputationSource``2(NMF.Transformations.InPlaceTransformationRuleBase{``0,``1},System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{``0,``1},System.Boolean})
  isExtensionMethod: true
  parent: NMF.Transformations.Linq.IncrementalExtensions
  langs:
  - csharp
  - vb
  name: ToComputationSource<TInput1, TInput2>(InPlaceTransformationRuleBase<TInput1, TInput2>, Func<InPlaceComputationWrapper<TInput1, TInput2>, Boolean>)
  nameWithType: IncrementalExtensions.ToComputationSource<TInput1, TInput2>(InPlaceTransformationRuleBase<TInput1, TInput2>, Func<InPlaceComputationWrapper<TInput1, TInput2>, Boolean>)
  fullName: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource<TInput1, TInput2>(NMF.Transformations.InPlaceTransformationRuleBase<TInput1, TInput2>, System.Func<NMF.Transformations.Linq.InPlaceComputationWrapper<TInput1, TInput2>, System.Boolean>)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/Linq/IncrementalExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ToComputationSource
    path: src/Transformations/Transformations/Linq/IncrementalExtensions.cs
    startLine: 584
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations.Linq
  summary: "\nCreates a new computation source from a transformation rule\n"
  example: []
  syntax:
    content: >-
      public static Func<ITransformationContext, INotifyEnumerable<InPlaceComputationWrapper<TInput1, TInput2>>> ToComputationSource<TInput1, TInput2>(this InPlaceTransformationRuleBase<TInput1, TInput2> rule, Func<InPlaceComputationWrapper<TInput1, TInput2>, bool> filter)

          where TInput1 : class where TInput2 : class
    parameters:
    - id: rule
      type: NMF.Transformations.InPlaceTransformationRuleBase{{TInput1},{TInput2}}
      description: The rule that should be taken as a source of computation objects
    - id: filter
      type: System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{{TInput1},{TInput2}},System.Boolean}
      description: A method or lambda expression to filter the computation objects
    typeParameters:
    - id: TInput1
      description: The type of the first input arguments for the transformation rule
    - id: TInput2
      description: The type of the second input arguments for the transformation rule
    return:
      type: System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{NMF.Transformations.Linq.InPlaceComputationWrapper{{TInput1},{TInput2}}}}
      description: A source of computations that can further be dealt with
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToComputationSource(Of TInput1 As Class, TInput2 As Class)(rule As InPlaceTransformationRuleBase(Of TInput1, TInput2), filter As Func(Of InPlaceComputationWrapper(Of TInput1, TInput2), Boolean)) As Func(Of ITransformationContext, INotifyEnumerable(Of InPlaceComputationWrapper(Of TInput1, TInput2)))
  overload: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource*
  nameWithType.vb: IncrementalExtensions.ToComputationSource(Of TInput1, TInput2)(InPlaceTransformationRuleBase(Of TInput1, TInput2), Func(Of InPlaceComputationWrapper(Of TInput1, TInput2), Boolean))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource(Of TInput1, TInput2)(NMF.Transformations.InPlaceTransformationRuleBase(Of TInput1, TInput2), System.Func(Of NMF.Transformations.Linq.InPlaceComputationWrapper(Of TInput1, TInput2), System.Boolean))
  name.vb: ToComputationSource(Of TInput1, TInput2)(InPlaceTransformationRuleBase(Of TInput1, TInput2), Func(Of InPlaceComputationWrapper(Of TInput1, TInput2), Boolean))
- uid: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.InPlaceTransformationRuleBase{``0,``1},System.Boolean,System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{``0,``1},System.Boolean})
  commentId: M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.InPlaceTransformationRuleBase{``0,``1},System.Boolean,System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{``0,``1},System.Boolean})
  id: ToComputationSource``2(NMF.Transformations.InPlaceTransformationRuleBase{``0,``1},System.Boolean,System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{``0,``1},System.Boolean})
  isExtensionMethod: true
  parent: NMF.Transformations.Linq.IncrementalExtensions
  langs:
  - csharp
  - vb
  name: ToComputationSource<TInput1, TInput2>(InPlaceTransformationRuleBase<TInput1, TInput2>, Boolean, Func<InPlaceComputationWrapper<TInput1, TInput2>, Boolean>)
  nameWithType: IncrementalExtensions.ToComputationSource<TInput1, TInput2>(InPlaceTransformationRuleBase<TInput1, TInput2>, Boolean, Func<InPlaceComputationWrapper<TInput1, TInput2>, Boolean>)
  fullName: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource<TInput1, TInput2>(NMF.Transformations.InPlaceTransformationRuleBase<TInput1, TInput2>, System.Boolean, System.Func<NMF.Transformations.Linq.InPlaceComputationWrapper<TInput1, TInput2>, System.Boolean>)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/Linq/IncrementalExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ToComputationSource
    path: src/Transformations/Transformations/Linq/IncrementalExtensions.cs
    startLine: 603
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations.Linq
  summary: "\nCreates a new computation source from a transformation rule\n"
  example: []
  syntax:
    content: >-
      public static Func<ITransformationContext, INotifyEnumerable<InPlaceComputationWrapper<TInput1, TInput2>>> ToComputationSource<TInput1, TInput2>(this InPlaceTransformationRuleBase<TInput1, TInput2> rule, bool allowNull, Func<InPlaceComputationWrapper<TInput1, TInput2>, bool> filter)

          where TInput1 : class where TInput2 : class
    parameters:
    - id: rule
      type: NMF.Transformations.InPlaceTransformationRuleBase{{TInput1},{TInput2}}
      description: The rule that should be taken as a source of computation objects
    - id: allowNull
      type: System.Boolean
      description: A boolean value indicating whether null values should be allowed
    - id: filter
      type: System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{{TInput1},{TInput2}},System.Boolean}
      description: A method or lambda expression to filter the computation objects
    typeParameters:
    - id: TInput1
      description: The type of the first input arguments for the transformation rule
    - id: TInput2
      description: The type of the second input arguments for the transformation rule
    return:
      type: System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{NMF.Transformations.Linq.InPlaceComputationWrapper{{TInput1},{TInput2}}}}
      description: A source of computations that can further be dealt with
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToComputationSource(Of TInput1 As Class, TInput2 As Class)(rule As InPlaceTransformationRuleBase(Of TInput1, TInput2), allowNull As Boolean, filter As Func(Of InPlaceComputationWrapper(Of TInput1, TInput2), Boolean)) As Func(Of ITransformationContext, INotifyEnumerable(Of InPlaceComputationWrapper(Of TInput1, TInput2)))
  overload: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource*
  nameWithType.vb: IncrementalExtensions.ToComputationSource(Of TInput1, TInput2)(InPlaceTransformationRuleBase(Of TInput1, TInput2), Boolean, Func(Of InPlaceComputationWrapper(Of TInput1, TInput2), Boolean))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource(Of TInput1, TInput2)(NMF.Transformations.InPlaceTransformationRuleBase(Of TInput1, TInput2), System.Boolean, System.Func(Of NMF.Transformations.Linq.InPlaceComputationWrapper(Of TInput1, TInput2), System.Boolean))
  name.vb: ToComputationSource(Of TInput1, TInput2)(InPlaceTransformationRuleBase(Of TInput1, TInput2), Boolean, Func(Of InPlaceComputationWrapper(Of TInput1, TInput2), Boolean))
- uid: NMF.Transformations.Linq.IncrementalExtensions.Where``1(System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{``0}},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})
  commentId: M:NMF.Transformations.Linq.IncrementalExtensions.Where``1(System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{``0}},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})
  id: Where``1(System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{``0}},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})
  isExtensionMethod: true
  parent: NMF.Transformations.Linq.IncrementalExtensions
  langs:
  - csharp
  - vb
  name: Where<T>(Func<ITransformationContext, INotifyEnumerable<T>>, Expression<Func<T, Boolean>>)
  nameWithType: IncrementalExtensions.Where<T>(Func<ITransformationContext, INotifyEnumerable<T>>, Expression<Func<T, Boolean>>)
  fullName: NMF.Transformations.Linq.IncrementalExtensions.Where<T>(System.Func<NMF.Transformations.Core.ITransformationContext, INotifyEnumerable<T>>, System.Linq.Expressions.Expression<System.Func<T, System.Boolean>>)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/Linq/IncrementalExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: Where
    path: src/Transformations/Transformations/Linq/IncrementalExtensions.cs
    startLine: 621
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations.Linq
  summary: "\nFilters the given monad instance with the given filter operator\n"
  remarks: Please see the documentation of the Where extension method and its use with the LINQ-syntax for more details
  example: []
  syntax:
    content: public static Func<ITransformationContext, INotifyEnumerable<T>> Where<T>(this Func<ITransformationContext, INotifyEnumerable<T>> items, Expression<Func<T, bool>> filter)
    parameters:
    - id: items
      type: System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{{T}}}
      description: The monad instance that should be filtered
    - id: filter
      type: System.Linq.Expressions.Expression{System.Func{{T},System.Boolean}}
      description: The filter that should be applied to the monad
    typeParameters:
    - id: T
      description: The inner type of the monad instance
    return:
      type: System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{{T}}}
      description: A filtered monad instance
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function Where(Of T)(items As Func(Of ITransformationContext, INotifyEnumerable(Of T)), filter As Expression(Of Func(Of T, Boolean))) As Func(Of ITransformationContext, INotifyEnumerable(Of T))
  overload: NMF.Transformations.Linq.IncrementalExtensions.Where*
  nameWithType.vb: IncrementalExtensions.Where(Of T)(Func(Of ITransformationContext, INotifyEnumerable(Of T)), Expression(Of Func(Of T, Boolean)))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.Linq.IncrementalExtensions.Where(Of T)(System.Func(Of NMF.Transformations.Core.ITransformationContext, INotifyEnumerable(Of T)), System.Linq.Expressions.Expression(Of System.Func(Of T, System.Boolean)))
  name.vb: Where(Of T)(Func(Of ITransformationContext, INotifyEnumerable(Of T)), Expression(Of Func(Of T, Boolean)))
- uid: NMF.Transformations.Linq.IncrementalExtensions.Select``2(System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{``0}},System.Linq.Expressions.Expression{System.Func{``0,``1}})
  commentId: M:NMF.Transformations.Linq.IncrementalExtensions.Select``2(System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{``0}},System.Linq.Expressions.Expression{System.Func{``0,``1}})
  id: Select``2(System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{``0}},System.Linq.Expressions.Expression{System.Func{``0,``1}})
  isExtensionMethod: true
  parent: NMF.Transformations.Linq.IncrementalExtensions
  langs:
  - csharp
  - vb
  name: Select<T1, T2>(Func<ITransformationContext, INotifyEnumerable<T1>>, Expression<Func<T1, T2>>)
  nameWithType: IncrementalExtensions.Select<T1, T2>(Func<ITransformationContext, INotifyEnumerable<T1>>, Expression<Func<T1, T2>>)
  fullName: NMF.Transformations.Linq.IncrementalExtensions.Select<T1, T2>(System.Func<NMF.Transformations.Core.ITransformationContext, INotifyEnumerable<T1>>, System.Linq.Expressions.Expression<System.Func<T1, T2>>)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/Linq/IncrementalExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: Select
    path: src/Transformations/Transformations/Linq/IncrementalExtensions.cs
    startLine: 637
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations.Linq
  summary: "\nBinds the Monad IRelationalSource to child items\n"
  example: []
  syntax:
    content: public static Func<ITransformationContext, INotifyEnumerable<T2>> Select<T1, T2>(this Func<ITransformationContext, INotifyEnumerable<T1>> items, Expression<Func<T1, T2>> selector)
    parameters:
    - id: items
      type: System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{{T1}}}
      description: The monad instance whose child items should be selected
    - id: selector
      type: System.Linq.Expressions.Expression{System.Func{{T1},{T2}}}
      description: A method that selects the result items from a source item
    typeParameters:
    - id: T1
      description: The inner type of the input monad instance
    - id: T2
      description: The inner type of the result monad instance
    return:
      type: System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{{T2}}}
      description: A monad instance of the result type that is based on the source monad instance
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function Select(Of T1, T2)(items As Func(Of ITransformationContext, INotifyEnumerable(Of T1)), selector As Expression(Of Func(Of T1, T2))) As Func(Of ITransformationContext, INotifyEnumerable(Of T2))
  overload: NMF.Transformations.Linq.IncrementalExtensions.Select*
  nameWithType.vb: IncrementalExtensions.Select(Of T1, T2)(Func(Of ITransformationContext, INotifyEnumerable(Of T1)), Expression(Of Func(Of T1, T2)))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.Linq.IncrementalExtensions.Select(Of T1, T2)(System.Func(Of NMF.Transformations.Core.ITransformationContext, INotifyEnumerable(Of T1)), System.Linq.Expressions.Expression(Of System.Func(Of T1, T2)))
  name.vb: Select(Of T1, T2)(Func(Of ITransformationContext, INotifyEnumerable(Of T1)), Expression(Of Func(Of T1, T2)))
- uid: NMF.Transformations.Linq.IncrementalExtensions.SelectMany``2(System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{``0}},System.Linq.Expressions.Expression{System.Func{``0,System.Func{NMF.Transformations.Core.ITransformationContext,System.Collections.Generic.IEnumerable{``1}}}})
  commentId: M:NMF.Transformations.Linq.IncrementalExtensions.SelectMany``2(System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{``0}},System.Linq.Expressions.Expression{System.Func{``0,System.Func{NMF.Transformations.Core.ITransformationContext,System.Collections.Generic.IEnumerable{``1}}}})
  id: SelectMany``2(System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{``0}},System.Linq.Expressions.Expression{System.Func{``0,System.Func{NMF.Transformations.Core.ITransformationContext,System.Collections.Generic.IEnumerable{``1}}}})
  isExtensionMethod: true
  parent: NMF.Transformations.Linq.IncrementalExtensions
  langs:
  - csharp
  - vb
  name: SelectMany<T1, T2>(Func<ITransformationContext, INotifyEnumerable<T1>>, Expression<Func<T1, Func<ITransformationContext, IEnumerable<T2>>>>)
  nameWithType: IncrementalExtensions.SelectMany<T1, T2>(Func<ITransformationContext, INotifyEnumerable<T1>>, Expression<Func<T1, Func<ITransformationContext, IEnumerable<T2>>>>)
  fullName: NMF.Transformations.Linq.IncrementalExtensions.SelectMany<T1, T2>(System.Func<NMF.Transformations.Core.ITransformationContext, INotifyEnumerable<T1>>, System.Linq.Expressions.Expression<System.Func<T1, System.Func<NMF.Transformations.Core.ITransformationContext, System.Collections.Generic.IEnumerable<T2>>>>)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/Linq/IncrementalExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: SelectMany
    path: src/Transformations/Transformations/Linq/IncrementalExtensions.cs
    startLine: 654
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations.Linq
  summary: "\nBinds the Monad IRelationalSource to child items\n"
  remarks: Please see the documentation of the SelectMany extension method and its use with the LINQ-syntax for more details
  example: []
  syntax:
    content: public static Func<ITransformationContext, INotifyEnumerable<T2>> SelectMany<T1, T2>(this Func<ITransformationContext, INotifyEnumerable<T1>> items, Expression<Func<T1, Func<ITransformationContext, IEnumerable<T2>>>> selector)
    parameters:
    - id: items
      type: System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{{T1}}}
      description: The monad instance which children are to be selected
    - id: selector
      type: System.Linq.Expressions.Expression{System.Func{{T1},System.Func{NMF.Transformations.Core.ITransformationContext,System.Collections.Generic.IEnumerable{{T2}}}}}
      description: A method that selects the output
    typeParameters:
    - id: T1
      description: The inner type of the outer monad instance
    - id: T2
      description: The inner type of the inner monad instance
    return:
      type: System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{{T2}}}
      description: A monad instance with items selected by the given selector function
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function SelectMany(Of T1, T2)(items As Func(Of ITransformationContext, INotifyEnumerable(Of T1)), selector As Expression(Of Func(Of T1, Func(Of ITransformationContext, IEnumerable(Of T2))))) As Func(Of ITransformationContext, INotifyEnumerable(Of T2))
  overload: NMF.Transformations.Linq.IncrementalExtensions.SelectMany*
  nameWithType.vb: IncrementalExtensions.SelectMany(Of T1, T2)(Func(Of ITransformationContext, INotifyEnumerable(Of T1)), Expression(Of Func(Of T1, Func(Of ITransformationContext, IEnumerable(Of T2)))))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.Linq.IncrementalExtensions.SelectMany(Of T1, T2)(System.Func(Of NMF.Transformations.Core.ITransformationContext, INotifyEnumerable(Of T1)), System.Linq.Expressions.Expression(Of System.Func(Of T1, System.Func(Of NMF.Transformations.Core.ITransformationContext, System.Collections.Generic.IEnumerable(Of T2)))))
  name.vb: SelectMany(Of T1, T2)(Func(Of ITransformationContext, INotifyEnumerable(Of T1)), Expression(Of Func(Of T1, Func(Of ITransformationContext, IEnumerable(Of T2)))))
- uid: NMF.Transformations.Linq.IncrementalExtensions.SelectMany``3(System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{``0}},System.Linq.Expressions.Expression{System.Func{``0,System.Func{NMF.Transformations.Core.ITransformationContext,System.Collections.Generic.IEnumerable{``1}}}},System.Linq.Expressions.Expression{System.Func{``0,``1,``2}})
  commentId: M:NMF.Transformations.Linq.IncrementalExtensions.SelectMany``3(System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{``0}},System.Linq.Expressions.Expression{System.Func{``0,System.Func{NMF.Transformations.Core.ITransformationContext,System.Collections.Generic.IEnumerable{``1}}}},System.Linq.Expressions.Expression{System.Func{``0,``1,``2}})
  id: SelectMany``3(System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{``0}},System.Linq.Expressions.Expression{System.Func{``0,System.Func{NMF.Transformations.Core.ITransformationContext,System.Collections.Generic.IEnumerable{``1}}}},System.Linq.Expressions.Expression{System.Func{``0,``1,``2}})
  isExtensionMethod: true
  parent: NMF.Transformations.Linq.IncrementalExtensions
  langs:
  - csharp
  - vb
  name: SelectMany<T1, T2, T3>(Func<ITransformationContext, INotifyEnumerable<T1>>, Expression<Func<T1, Func<ITransformationContext, IEnumerable<T2>>>>, Expression<Func<T1, T2, T3>>)
  nameWithType: IncrementalExtensions.SelectMany<T1, T2, T3>(Func<ITransformationContext, INotifyEnumerable<T1>>, Expression<Func<T1, Func<ITransformationContext, IEnumerable<T2>>>>, Expression<Func<T1, T2, T3>>)
  fullName: NMF.Transformations.Linq.IncrementalExtensions.SelectMany<T1, T2, T3>(System.Func<NMF.Transformations.Core.ITransformationContext, INotifyEnumerable<T1>>, System.Linq.Expressions.Expression<System.Func<T1, System.Func<NMF.Transformations.Core.ITransformationContext, System.Collections.Generic.IEnumerable<T2>>>>, System.Linq.Expressions.Expression<System.Func<T1, T2, T3>>)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/Linq/IncrementalExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: SelectMany
    path: src/Transformations/Transformations/Linq/IncrementalExtensions.cs
    startLine: 679
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations.Linq
  summary: "\nBinds the Monad IRelationalSource to child items\n"
  remarks: Please see the documentation of the SelectMany extension method and its use with the LINQ-syntax for more details
  example: []
  syntax:
    content: public static Func<ITransformationContext, INotifyEnumerable<T3>> SelectMany<T1, T2, T3>(this Func<ITransformationContext, INotifyEnumerable<T1>> items, Expression<Func<T1, Func<ITransformationContext, IEnumerable<T2>>>> func, Expression<Func<T1, T2, T3>> selector)
    parameters:
    - id: items
      type: System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{{T1}}}
      description: The monad instance which children are to be selected
    - id: func
      type: System.Linq.Expressions.Expression{System.Func{{T1},System.Func{NMF.Transformations.Core.ITransformationContext,System.Collections.Generic.IEnumerable{{T2}}}}}
      description: The operator that should be applied in the bind function
    - id: selector
      type: System.Linq.Expressions.Expression{System.Func{{T1},{T2},{T3}}}
      description: A method that selects the output
    typeParameters:
    - id: T1
      description: The inner type of the outer monad instance
    - id: T2
      description: The inner type of the inner monad instance
    - id: T3
      description: The inner type of the return monad
    return:
      type: System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{{T3}}}
      description: A monad instance with items selected by the given selector function
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function SelectMany(Of T1, T2, T3)(items As Func(Of ITransformationContext, INotifyEnumerable(Of T1)), func As Expression(Of Func(Of T1, Func(Of ITransformationContext, IEnumerable(Of T2)))), selector As Expression(Of Func(Of T1, T2, T3))) As Func(Of ITransformationContext, INotifyEnumerable(Of T3))
  overload: NMF.Transformations.Linq.IncrementalExtensions.SelectMany*
  nameWithType.vb: IncrementalExtensions.SelectMany(Of T1, T2, T3)(Func(Of ITransformationContext, INotifyEnumerable(Of T1)), Expression(Of Func(Of T1, Func(Of ITransformationContext, IEnumerable(Of T2)))), Expression(Of Func(Of T1, T2, T3)))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.Linq.IncrementalExtensions.SelectMany(Of T1, T2, T3)(System.Func(Of NMF.Transformations.Core.ITransformationContext, INotifyEnumerable(Of T1)), System.Linq.Expressions.Expression(Of System.Func(Of T1, System.Func(Of NMF.Transformations.Core.ITransformationContext, System.Collections.Generic.IEnumerable(Of T2)))), System.Linq.Expressions.Expression(Of System.Func(Of T1, T2, T3)))
  name.vb: SelectMany(Of T1, T2, T3)(Func(Of ITransformationContext, INotifyEnumerable(Of T1)), Expression(Of Func(Of T1, Func(Of ITransformationContext, IEnumerable(Of T2)))), Expression(Of Func(Of T1, T2, T3)))
references:
- uid: NMF.Transformations.Linq
  commentId: N:NMF.Transformations.Linq
  name: NMF.Transformations.Linq
  nameWithType: NMF.Transformations.Linq
  fullName: NMF.Transformations.Linq
- uid: System.Object
  commentId: T:System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Object.ToString
  commentId: M:System.Object.ToString
  parent: System.Object
  isExternal: true
  name: ToString()
  nameWithType: Object.ToString()
  fullName: System.Object.ToString()
  spec.csharp:
  - uid: System.Object.ToString
    name: ToString
    nameWithType: Object.ToString
    fullName: System.Object.ToString
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.ToString
    name: ToString
    nameWithType: Object.ToString
    fullName: System.Object.ToString
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Object.Equals(System.Object)
  commentId: M:System.Object.Equals(System.Object)
  parent: System.Object
  isExternal: true
  name: Equals(Object)
  nameWithType: Object.Equals(Object)
  fullName: System.Object.Equals(System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    nameWithType: Object.Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    nameWithType: Object.Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Object.Equals(System.Object,System.Object)
  commentId: M:System.Object.Equals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  name: Equals(Object, Object)
  nameWithType: Object.Equals(Object, Object)
  fullName: System.Object.Equals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    nameWithType: Object.Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    nameWithType: Object.Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Object.ReferenceEquals(System.Object,System.Object)
  commentId: M:System.Object.ReferenceEquals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  name: ReferenceEquals(Object, Object)
  nameWithType: Object.ReferenceEquals(Object, Object)
  fullName: System.Object.ReferenceEquals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    nameWithType: Object.ReferenceEquals
    fullName: System.Object.ReferenceEquals
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    nameWithType: Object.ReferenceEquals
    fullName: System.Object.ReferenceEquals
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Object.GetHashCode
  commentId: M:System.Object.GetHashCode
  parent: System.Object
  isExternal: true
  name: GetHashCode()
  nameWithType: Object.GetHashCode()
  fullName: System.Object.GetHashCode()
  spec.csharp:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    nameWithType: Object.GetHashCode
    fullName: System.Object.GetHashCode
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    nameWithType: Object.GetHashCode
    fullName: System.Object.GetHashCode
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Object.GetType
  commentId: M:System.Object.GetType
  parent: System.Object
  isExternal: true
  name: GetType()
  nameWithType: Object.GetType()
  fullName: System.Object.GetType()
  spec.csharp:
  - uid: System.Object.GetType
    name: GetType
    nameWithType: Object.GetType
    fullName: System.Object.GetType
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetType
    name: GetType
    nameWithType: Object.GetType
    fullName: System.Object.GetType
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Object.MemberwiseClone
  commentId: M:System.Object.MemberwiseClone
  parent: System.Object
  isExternal: true
  name: MemberwiseClone()
  nameWithType: Object.MemberwiseClone()
  fullName: System.Object.MemberwiseClone()
  spec.csharp:
  - uid: System.Object.MemberwiseClone
    name: MemberwiseClone
    nameWithType: Object.MemberwiseClone
    fullName: System.Object.MemberwiseClone
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.MemberwiseClone
    name: MemberwiseClone
    nameWithType: Object.MemberwiseClone
    fullName: System.Object.MemberwiseClone
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
- uid: System
  commentId: N:System
  isExternal: true
  name: System
  nameWithType: System
  fullName: System
- uid: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource*
  commentId: Overload:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource
  name: ToComputationSource
  nameWithType: IncrementalExtensions.ToComputationSource
  fullName: NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource
- uid: NMF.Transformations.TransformationRuleBase{{TInput},{TOutput}}
  commentId: T:NMF.Transformations.TransformationRuleBase{``0,``1}
  parent: NMF.Transformations
  definition: NMF.Transformations.TransformationRuleBase`2
  name: TransformationRuleBase<TInput, TOutput>
  nameWithType: TransformationRuleBase<TInput, TOutput>
  fullName: NMF.Transformations.TransformationRuleBase<TInput, TOutput>
  nameWithType.vb: TransformationRuleBase(Of TInput, TOutput)
  fullName.vb: NMF.Transformations.TransformationRuleBase(Of TInput, TOutput)
  name.vb: TransformationRuleBase(Of TInput, TOutput)
  spec.csharp:
  - uid: NMF.Transformations.TransformationRuleBase`2
    name: TransformationRuleBase
    nameWithType: TransformationRuleBase
    fullName: NMF.Transformations.TransformationRuleBase
  - name: <
    nameWithType: <
    fullName: <
  - name: TInput
    nameWithType: TInput
    fullName: TInput
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TOutput
    nameWithType: TOutput
    fullName: TOutput
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: NMF.Transformations.TransformationRuleBase`2
    name: TransformationRuleBase
    nameWithType: TransformationRuleBase
    fullName: NMF.Transformations.TransformationRuleBase
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TInput
    nameWithType: TInput
    fullName: TInput
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TOutput
    nameWithType: TOutput
    fullName: TOutput
  - name: )
    nameWithType: )
    fullName: )
- uid: NMF.Transformations.Core.ITransformationContext
  commentId: T:NMF.Transformations.Core.ITransformationContext
  parent: NMF.Transformations.Core
  name: ITransformationContext
  nameWithType: ITransformationContext
  fullName: NMF.Transformations.Core.ITransformationContext
- uid: INotifyEnumerable{NMF.Transformations.Linq.TransformationComputationWrapper{{TInput},{TOutput}}}
  commentId: '!:INotifyEnumerable{NMF.Transformations.Linq.TransformationComputationWrapper{``0,``1}}'
  definition: INotifyEnumerable`1
  name: INotifyEnumerable<TransformationComputationWrapper<TInput, TOutput>>
  nameWithType: INotifyEnumerable<TransformationComputationWrapper<TInput, TOutput>>
  fullName: INotifyEnumerable<NMF.Transformations.Linq.TransformationComputationWrapper<TInput, TOutput>>
  nameWithType.vb: INotifyEnumerable(Of TransformationComputationWrapper(Of TInput, TOutput))
  fullName.vb: INotifyEnumerable(Of NMF.Transformations.Linq.TransformationComputationWrapper(Of TInput, TOutput))
  name.vb: INotifyEnumerable(Of TransformationComputationWrapper(Of TInput, TOutput))
  spec.csharp:
  - uid: INotifyEnumerable`1
    name: INotifyEnumerable
    nameWithType: INotifyEnumerable
    fullName: INotifyEnumerable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: NMF.Transformations.Linq.TransformationComputationWrapper`2
    name: TransformationComputationWrapper
    nameWithType: TransformationComputationWrapper
    fullName: NMF.Transformations.Linq.TransformationComputationWrapper
  - name: <
    nameWithType: <
    fullName: <
  - name: TInput
    nameWithType: TInput
    fullName: TInput
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TOutput
    nameWithType: TOutput
    fullName: TOutput
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: INotifyEnumerable`1
    name: INotifyEnumerable
    nameWithType: INotifyEnumerable
    fullName: INotifyEnumerable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: NMF.Transformations.Linq.TransformationComputationWrapper`2
    name: TransformationComputationWrapper
    nameWithType: TransformationComputationWrapper
    fullName: NMF.Transformations.Linq.TransformationComputationWrapper
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TInput
    nameWithType: TInput
    fullName: TInput
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TOutput
    nameWithType: TOutput
    fullName: TOutput
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
- uid: NMF.Transformations.TransformationRuleBase`2
  commentId: T:NMF.Transformations.TransformationRuleBase`2
  name: TransformationRuleBase<TIn, TOut>
  nameWithType: TransformationRuleBase<TIn, TOut>
  fullName: NMF.Transformations.TransformationRuleBase<TIn, TOut>
  nameWithType.vb: TransformationRuleBase(Of TIn, TOut)
  fullName.vb: NMF.Transformations.TransformationRuleBase(Of TIn, TOut)
  name.vb: TransformationRuleBase(Of TIn, TOut)
  spec.csharp:
  - uid: NMF.Transformations.TransformationRuleBase`2
    name: TransformationRuleBase
    nameWithType: TransformationRuleBase
    fullName: NMF.Transformations.TransformationRuleBase
  - name: <
    nameWithType: <
    fullName: <
  - name: TIn
    nameWithType: TIn
    fullName: TIn
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: NMF.Transformations.TransformationRuleBase`2
    name: TransformationRuleBase
    nameWithType: TransformationRuleBase
    fullName: NMF.Transformations.TransformationRuleBase
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TIn
    nameWithType: TIn
    fullName: TIn
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: )
    nameWithType: )
    fullName: )
- uid: NMF.Transformations
  commentId: N:NMF.Transformations
  name: NMF.Transformations
  nameWithType: NMF.Transformations
  fullName: NMF.Transformations
- uid: NMF.Transformations.Core
  commentId: N:NMF.Transformations.Core
  name: NMF.Transformations.Core
  nameWithType: NMF.Transformations.Core
  fullName: NMF.Transformations.Core
- uid: INotifyEnumerable`1
  isExternal: true
  name: INotifyEnumerable<>
  nameWithType: INotifyEnumerable<>
  fullName: INotifyEnumerable<>
  nameWithType.vb: INotifyEnumerable(Of )
  fullName.vb: INotifyEnumerable(Of )
  name.vb: INotifyEnumerable(Of )
  spec.csharp:
  - uid: INotifyEnumerable`1
    name: INotifyEnumerable
    nameWithType: INotifyEnumerable
    fullName: INotifyEnumerable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: ''
    nameWithType: ''
    fullName: ''
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: INotifyEnumerable`1
    name: INotifyEnumerable
    nameWithType: INotifyEnumerable
    fullName: INotifyEnumerable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: ''
    nameWithType: ''
    fullName: ''
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Boolean
  commentId: T:System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{{TInput},{TOutput}},System.Boolean}
  commentId: T:System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{``0,``1},System.Boolean}
  parent: System
  definition: System.Func`2
  name: Func<TransformationComputationWrapper<TInput, TOutput>, Boolean>
  nameWithType: Func<TransformationComputationWrapper<TInput, TOutput>, Boolean>
  fullName: System.Func<NMF.Transformations.Linq.TransformationComputationWrapper<TInput, TOutput>, System.Boolean>
  nameWithType.vb: Func(Of TransformationComputationWrapper(Of TInput, TOutput), Boolean)
  fullName.vb: System.Func(Of NMF.Transformations.Linq.TransformationComputationWrapper(Of TInput, TOutput), System.Boolean)
  name.vb: Func(Of TransformationComputationWrapper(Of TInput, TOutput), Boolean)
  spec.csharp:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: NMF.Transformations.Linq.TransformationComputationWrapper`2
    name: TransformationComputationWrapper
    nameWithType: TransformationComputationWrapper
    fullName: NMF.Transformations.Linq.TransformationComputationWrapper
  - name: <
    nameWithType: <
    fullName: <
  - name: TInput
    nameWithType: TInput
    fullName: TInput
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TOutput
    nameWithType: TOutput
    fullName: TOutput
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Boolean
    name: Boolean
    nameWithType: Boolean
    fullName: System.Boolean
    isExternal: true
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: NMF.Transformations.Linq.TransformationComputationWrapper`2
    name: TransformationComputationWrapper
    nameWithType: TransformationComputationWrapper
    fullName: NMF.Transformations.Linq.TransformationComputationWrapper
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TInput
    nameWithType: TInput
    fullName: TInput
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TOutput
    nameWithType: TOutput
    fullName: TOutput
  - name: )
    nameWithType: )
    fullName: )
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Boolean
    name: Boolean
    nameWithType: Boolean
    fullName: System.Boolean
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Func`2
  commentId: T:System.Func`2
  isExternal: true
  name: Func<T, TResult>
  nameWithType: Func<T, TResult>
  fullName: System.Func<T, TResult>
  nameWithType.vb: Func(Of T, TResult)
  fullName.vb: System.Func(Of T, TResult)
  name.vb: Func(Of T, TResult)
  spec.csharp:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: )
    nameWithType: )
    fullName: )
- uid: NMF.Transformations.TransformationRuleBase{{TInput1},{TInput2},{TOutput}}
  commentId: T:NMF.Transformations.TransformationRuleBase{``0,``1,``2}
  parent: NMF.Transformations
  definition: NMF.Transformations.TransformationRuleBase`3
  name: TransformationRuleBase<TInput1, TInput2, TOutput>
  nameWithType: TransformationRuleBase<TInput1, TInput2, TOutput>
  fullName: NMF.Transformations.TransformationRuleBase<TInput1, TInput2, TOutput>
  nameWithType.vb: TransformationRuleBase(Of TInput1, TInput2, TOutput)
  fullName.vb: NMF.Transformations.TransformationRuleBase(Of TInput1, TInput2, TOutput)
  name.vb: TransformationRuleBase(Of TInput1, TInput2, TOutput)
  spec.csharp:
  - uid: NMF.Transformations.TransformationRuleBase`3
    name: TransformationRuleBase
    nameWithType: TransformationRuleBase
    fullName: NMF.Transformations.TransformationRuleBase
  - name: <
    nameWithType: <
    fullName: <
  - name: TInput1
    nameWithType: TInput1
    fullName: TInput1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TInput2
    nameWithType: TInput2
    fullName: TInput2
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TOutput
    nameWithType: TOutput
    fullName: TOutput
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: NMF.Transformations.TransformationRuleBase`3
    name: TransformationRuleBase
    nameWithType: TransformationRuleBase
    fullName: NMF.Transformations.TransformationRuleBase
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TInput1
    nameWithType: TInput1
    fullName: TInput1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TInput2
    nameWithType: TInput2
    fullName: TInput2
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TOutput
    nameWithType: TOutput
    fullName: TOutput
  - name: )
    nameWithType: )
    fullName: )
- uid: INotifyEnumerable{NMF.Transformations.Linq.TransformationComputationWrapper{{TInput1},{TInput2},{TOutput}}}
  commentId: '!:INotifyEnumerable{NMF.Transformations.Linq.TransformationComputationWrapper{``0,``1,``2}}'
  definition: INotifyEnumerable`1
  name: INotifyEnumerable<TransformationComputationWrapper<TInput1, TInput2, TOutput>>
  nameWithType: INotifyEnumerable<TransformationComputationWrapper<TInput1, TInput2, TOutput>>
  fullName: INotifyEnumerable<NMF.Transformations.Linq.TransformationComputationWrapper<TInput1, TInput2, TOutput>>
  nameWithType.vb: INotifyEnumerable(Of TransformationComputationWrapper(Of TInput1, TInput2, TOutput))
  fullName.vb: INotifyEnumerable(Of NMF.Transformations.Linq.TransformationComputationWrapper(Of TInput1, TInput2, TOutput))
  name.vb: INotifyEnumerable(Of TransformationComputationWrapper(Of TInput1, TInput2, TOutput))
  spec.csharp:
  - uid: INotifyEnumerable`1
    name: INotifyEnumerable
    nameWithType: INotifyEnumerable
    fullName: INotifyEnumerable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: NMF.Transformations.Linq.TransformationComputationWrapper`3
    name: TransformationComputationWrapper
    nameWithType: TransformationComputationWrapper
    fullName: NMF.Transformations.Linq.TransformationComputationWrapper
  - name: <
    nameWithType: <
    fullName: <
  - name: TInput1
    nameWithType: TInput1
    fullName: TInput1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TInput2
    nameWithType: TInput2
    fullName: TInput2
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TOutput
    nameWithType: TOutput
    fullName: TOutput
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: INotifyEnumerable`1
    name: INotifyEnumerable
    nameWithType: INotifyEnumerable
    fullName: INotifyEnumerable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: NMF.Transformations.Linq.TransformationComputationWrapper`3
    name: TransformationComputationWrapper
    nameWithType: TransformationComputationWrapper
    fullName: NMF.Transformations.Linq.TransformationComputationWrapper
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TInput1
    nameWithType: TInput1
    fullName: TInput1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TInput2
    nameWithType: TInput2
    fullName: TInput2
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TOutput
    nameWithType: TOutput
    fullName: TOutput
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
- uid: NMF.Transformations.TransformationRuleBase`3
  commentId: T:NMF.Transformations.TransformationRuleBase`3
  name: TransformationRuleBase<TIn1, TIn2, TOut>
  nameWithType: TransformationRuleBase<TIn1, TIn2, TOut>
  fullName: NMF.Transformations.TransformationRuleBase<TIn1, TIn2, TOut>
  nameWithType.vb: TransformationRuleBase(Of TIn1, TIn2, TOut)
  fullName.vb: NMF.Transformations.TransformationRuleBase(Of TIn1, TIn2, TOut)
  name.vb: TransformationRuleBase(Of TIn1, TIn2, TOut)
  spec.csharp:
  - uid: NMF.Transformations.TransformationRuleBase`3
    name: TransformationRuleBase
    nameWithType: TransformationRuleBase
    fullName: NMF.Transformations.TransformationRuleBase
  - name: <
    nameWithType: <
    fullName: <
  - name: TIn1
    nameWithType: TIn1
    fullName: TIn1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TIn2
    nameWithType: TIn2
    fullName: TIn2
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: NMF.Transformations.TransformationRuleBase`3
    name: TransformationRuleBase
    nameWithType: TransformationRuleBase
    fullName: NMF.Transformations.TransformationRuleBase
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TIn1
    nameWithType: TIn1
    fullName: TIn1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TIn2
    nameWithType: TIn2
    fullName: TIn2
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{{TInput1},{TInput2},{TOutput}},System.Boolean}
  commentId: T:System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{``0,``1,``2},System.Boolean}
  parent: System
  definition: System.Func`2
  name: Func<TransformationComputationWrapper<TInput1, TInput2, TOutput>, Boolean>
  nameWithType: Func<TransformationComputationWrapper<TInput1, TInput2, TOutput>, Boolean>
  fullName: System.Func<NMF.Transformations.Linq.TransformationComputationWrapper<TInput1, TInput2, TOutput>, System.Boolean>
  nameWithType.vb: Func(Of TransformationComputationWrapper(Of TInput1, TInput2, TOutput), Boolean)
  fullName.vb: System.Func(Of NMF.Transformations.Linq.TransformationComputationWrapper(Of TInput1, TInput2, TOutput), System.Boolean)
  name.vb: Func(Of TransformationComputationWrapper(Of TInput1, TInput2, TOutput), Boolean)
  spec.csharp:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: NMF.Transformations.Linq.TransformationComputationWrapper`3
    name: TransformationComputationWrapper
    nameWithType: TransformationComputationWrapper
    fullName: NMF.Transformations.Linq.TransformationComputationWrapper
  - name: <
    nameWithType: <
    fullName: <
  - name: TInput1
    nameWithType: TInput1
    fullName: TInput1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TInput2
    nameWithType: TInput2
    fullName: TInput2
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TOutput
    nameWithType: TOutput
    fullName: TOutput
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Boolean
    name: Boolean
    nameWithType: Boolean
    fullName: System.Boolean
    isExternal: true
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: NMF.Transformations.Linq.TransformationComputationWrapper`3
    name: TransformationComputationWrapper
    nameWithType: TransformationComputationWrapper
    fullName: NMF.Transformations.Linq.TransformationComputationWrapper
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TInput1
    nameWithType: TInput1
    fullName: TInput1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TInput2
    nameWithType: TInput2
    fullName: TInput2
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TOutput
    nameWithType: TOutput
    fullName: TOutput
  - name: )
    nameWithType: )
    fullName: )
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Boolean
    name: Boolean
    nameWithType: Boolean
    fullName: System.Boolean
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{NMF.Transformations.Linq.TransformationComputationWrapper{{TInput},{TOutput}}}}
  commentId: T:System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{NMF.Transformations.Linq.TransformationComputationWrapper{``0,``1}}}
  parent: System
  definition: System.Func`2
  name: Func<ITransformationContext, INotifyEnumerable<TransformationComputationWrapper<TInput, TOutput>>>
  nameWithType: Func<ITransformationContext, INotifyEnumerable<TransformationComputationWrapper<TInput, TOutput>>>
  fullName: System.Func<NMF.Transformations.Core.ITransformationContext, INotifyEnumerable<NMF.Transformations.Linq.TransformationComputationWrapper<TInput, TOutput>>>
  nameWithType.vb: Func(Of ITransformationContext, INotifyEnumerable(Of TransformationComputationWrapper(Of TInput, TOutput)))
  fullName.vb: System.Func(Of NMF.Transformations.Core.ITransformationContext, INotifyEnumerable(Of NMF.Transformations.Linq.TransformationComputationWrapper(Of TInput, TOutput)))
  name.vb: Func(Of ITransformationContext, INotifyEnumerable(Of TransformationComputationWrapper(Of TInput, TOutput)))
  spec.csharp:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: NMF.Transformations.Core.ITransformationContext
    name: ITransformationContext
    nameWithType: ITransformationContext
    fullName: NMF.Transformations.Core.ITransformationContext
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: INotifyEnumerable`1
    name: INotifyEnumerable
    nameWithType: INotifyEnumerable
    fullName: INotifyEnumerable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: NMF.Transformations.Linq.TransformationComputationWrapper`2
    name: TransformationComputationWrapper
    nameWithType: TransformationComputationWrapper
    fullName: NMF.Transformations.Linq.TransformationComputationWrapper
  - name: <
    nameWithType: <
    fullName: <
  - name: TInput
    nameWithType: TInput
    fullName: TInput
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TOutput
    nameWithType: TOutput
    fullName: TOutput
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: NMF.Transformations.Core.ITransformationContext
    name: ITransformationContext
    nameWithType: ITransformationContext
    fullName: NMF.Transformations.Core.ITransformationContext
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: INotifyEnumerable`1
    name: INotifyEnumerable
    nameWithType: INotifyEnumerable
    fullName: INotifyEnumerable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: NMF.Transformations.Linq.TransformationComputationWrapper`2
    name: TransformationComputationWrapper
    nameWithType: TransformationComputationWrapper
    fullName: NMF.Transformations.Linq.TransformationComputationWrapper
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TInput
    nameWithType: TInput
    fullName: TInput
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TOutput
    nameWithType: TOutput
    fullName: TOutput
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{NMF.Transformations.Linq.TransformationComputationWrapper{{TInput1},{TInput2},{TOutput}}}}
  commentId: T:System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{NMF.Transformations.Linq.TransformationComputationWrapper{``0,``1,``2}}}
  parent: System
  definition: System.Func`2
  name: Func<ITransformationContext, INotifyEnumerable<TransformationComputationWrapper<TInput1, TInput2, TOutput>>>
  nameWithType: Func<ITransformationContext, INotifyEnumerable<TransformationComputationWrapper<TInput1, TInput2, TOutput>>>
  fullName: System.Func<NMF.Transformations.Core.ITransformationContext, INotifyEnumerable<NMF.Transformations.Linq.TransformationComputationWrapper<TInput1, TInput2, TOutput>>>
  nameWithType.vb: Func(Of ITransformationContext, INotifyEnumerable(Of TransformationComputationWrapper(Of TInput1, TInput2, TOutput)))
  fullName.vb: System.Func(Of NMF.Transformations.Core.ITransformationContext, INotifyEnumerable(Of NMF.Transformations.Linq.TransformationComputationWrapper(Of TInput1, TInput2, TOutput)))
  name.vb: Func(Of ITransformationContext, INotifyEnumerable(Of TransformationComputationWrapper(Of TInput1, TInput2, TOutput)))
  spec.csharp:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: NMF.Transformations.Core.ITransformationContext
    name: ITransformationContext
    nameWithType: ITransformationContext
    fullName: NMF.Transformations.Core.ITransformationContext
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: INotifyEnumerable`1
    name: INotifyEnumerable
    nameWithType: INotifyEnumerable
    fullName: INotifyEnumerable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: NMF.Transformations.Linq.TransformationComputationWrapper`3
    name: TransformationComputationWrapper
    nameWithType: TransformationComputationWrapper
    fullName: NMF.Transformations.Linq.TransformationComputationWrapper
  - name: <
    nameWithType: <
    fullName: <
  - name: TInput1
    nameWithType: TInput1
    fullName: TInput1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TInput2
    nameWithType: TInput2
    fullName: TInput2
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TOutput
    nameWithType: TOutput
    fullName: TOutput
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: NMF.Transformations.Core.ITransformationContext
    name: ITransformationContext
    nameWithType: ITransformationContext
    fullName: NMF.Transformations.Core.ITransformationContext
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: INotifyEnumerable`1
    name: INotifyEnumerable
    nameWithType: INotifyEnumerable
    fullName: INotifyEnumerable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: NMF.Transformations.Linq.TransformationComputationWrapper`3
    name: TransformationComputationWrapper
    nameWithType: TransformationComputationWrapper
    fullName: NMF.Transformations.Linq.TransformationComputationWrapper
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TInput1
    nameWithType: TInput1
    fullName: TInput1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TInput2
    nameWithType: TInput2
    fullName: TInput2
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TOutput
    nameWithType: TOutput
    fullName: TOutput
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
- uid: NMF.Transformations.InPlaceTransformationRuleBase{{TInput}}
  commentId: T:NMF.Transformations.InPlaceTransformationRuleBase{``0}
  parent: NMF.Transformations
  definition: NMF.Transformations.InPlaceTransformationRuleBase`1
  name: InPlaceTransformationRuleBase<TInput>
  nameWithType: InPlaceTransformationRuleBase<TInput>
  fullName: NMF.Transformations.InPlaceTransformationRuleBase<TInput>
  nameWithType.vb: InPlaceTransformationRuleBase(Of TInput)
  fullName.vb: NMF.Transformations.InPlaceTransformationRuleBase(Of TInput)
  name.vb: InPlaceTransformationRuleBase(Of TInput)
  spec.csharp:
  - uid: NMF.Transformations.InPlaceTransformationRuleBase`1
    name: InPlaceTransformationRuleBase
    nameWithType: InPlaceTransformationRuleBase
    fullName: NMF.Transformations.InPlaceTransformationRuleBase
  - name: <
    nameWithType: <
    fullName: <
  - name: TInput
    nameWithType: TInput
    fullName: TInput
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: NMF.Transformations.InPlaceTransformationRuleBase`1
    name: InPlaceTransformationRuleBase
    nameWithType: InPlaceTransformationRuleBase
    fullName: NMF.Transformations.InPlaceTransformationRuleBase
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TInput
    nameWithType: TInput
    fullName: TInput
  - name: )
    nameWithType: )
    fullName: )
- uid: INotifyEnumerable{NMF.Transformations.Linq.InPlaceComputationWrapper{{TInput}}}
  commentId: '!:INotifyEnumerable{NMF.Transformations.Linq.InPlaceComputationWrapper{``0}}'
  definition: INotifyEnumerable`1
  name: INotifyEnumerable<InPlaceComputationWrapper<TInput>>
  nameWithType: INotifyEnumerable<InPlaceComputationWrapper<TInput>>
  fullName: INotifyEnumerable<NMF.Transformations.Linq.InPlaceComputationWrapper<TInput>>
  nameWithType.vb: INotifyEnumerable(Of InPlaceComputationWrapper(Of TInput))
  fullName.vb: INotifyEnumerable(Of NMF.Transformations.Linq.InPlaceComputationWrapper(Of TInput))
  name.vb: INotifyEnumerable(Of InPlaceComputationWrapper(Of TInput))
  spec.csharp:
  - uid: INotifyEnumerable`1
    name: INotifyEnumerable
    nameWithType: INotifyEnumerable
    fullName: INotifyEnumerable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: NMF.Transformations.Linq.InPlaceComputationWrapper`1
    name: InPlaceComputationWrapper
    nameWithType: InPlaceComputationWrapper
    fullName: NMF.Transformations.Linq.InPlaceComputationWrapper
  - name: <
    nameWithType: <
    fullName: <
  - name: TInput
    nameWithType: TInput
    fullName: TInput
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: INotifyEnumerable`1
    name: INotifyEnumerable
    nameWithType: INotifyEnumerable
    fullName: INotifyEnumerable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: NMF.Transformations.Linq.InPlaceComputationWrapper`1
    name: InPlaceComputationWrapper
    nameWithType: InPlaceComputationWrapper
    fullName: NMF.Transformations.Linq.InPlaceComputationWrapper
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TInput
    nameWithType: TInput
    fullName: TInput
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
- uid: NMF.Transformations.InPlaceTransformationRuleBase`1
  commentId: T:NMF.Transformations.InPlaceTransformationRuleBase`1
  name: InPlaceTransformationRuleBase<T>
  nameWithType: InPlaceTransformationRuleBase<T>
  fullName: NMF.Transformations.InPlaceTransformationRuleBase<T>
  nameWithType.vb: InPlaceTransformationRuleBase(Of T)
  fullName.vb: NMF.Transformations.InPlaceTransformationRuleBase(Of T)
  name.vb: InPlaceTransformationRuleBase(Of T)
  spec.csharp:
  - uid: NMF.Transformations.InPlaceTransformationRuleBase`1
    name: InPlaceTransformationRuleBase
    nameWithType: InPlaceTransformationRuleBase
    fullName: NMF.Transformations.InPlaceTransformationRuleBase
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: NMF.Transformations.InPlaceTransformationRuleBase`1
    name: InPlaceTransformationRuleBase
    nameWithType: InPlaceTransformationRuleBase
    fullName: NMF.Transformations.InPlaceTransformationRuleBase
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{{TInput}},System.Boolean}
  commentId: T:System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{``0},System.Boolean}
  parent: System
  definition: System.Func`2
  name: Func<InPlaceComputationWrapper<TInput>, Boolean>
  nameWithType: Func<InPlaceComputationWrapper<TInput>, Boolean>
  fullName: System.Func<NMF.Transformations.Linq.InPlaceComputationWrapper<TInput>, System.Boolean>
  nameWithType.vb: Func(Of InPlaceComputationWrapper(Of TInput), Boolean)
  fullName.vb: System.Func(Of NMF.Transformations.Linq.InPlaceComputationWrapper(Of TInput), System.Boolean)
  name.vb: Func(Of InPlaceComputationWrapper(Of TInput), Boolean)
  spec.csharp:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: NMF.Transformations.Linq.InPlaceComputationWrapper`1
    name: InPlaceComputationWrapper
    nameWithType: InPlaceComputationWrapper
    fullName: NMF.Transformations.Linq.InPlaceComputationWrapper
  - name: <
    nameWithType: <
    fullName: <
  - name: TInput
    nameWithType: TInput
    fullName: TInput
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Boolean
    name: Boolean
    nameWithType: Boolean
    fullName: System.Boolean
    isExternal: true
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: NMF.Transformations.Linq.InPlaceComputationWrapper`1
    name: InPlaceComputationWrapper
    nameWithType: InPlaceComputationWrapper
    fullName: NMF.Transformations.Linq.InPlaceComputationWrapper
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TInput
    nameWithType: TInput
    fullName: TInput
  - name: )
    nameWithType: )
    fullName: )
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Boolean
    name: Boolean
    nameWithType: Boolean
    fullName: System.Boolean
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: NMF.Transformations.InPlaceTransformationRuleBase{{TInput1},{TInput2}}
  commentId: T:NMF.Transformations.InPlaceTransformationRuleBase{``0,``1}
  parent: NMF.Transformations
  definition: NMF.Transformations.InPlaceTransformationRuleBase`2
  name: InPlaceTransformationRuleBase<TInput1, TInput2>
  nameWithType: InPlaceTransformationRuleBase<TInput1, TInput2>
  fullName: NMF.Transformations.InPlaceTransformationRuleBase<TInput1, TInput2>
  nameWithType.vb: InPlaceTransformationRuleBase(Of TInput1, TInput2)
  fullName.vb: NMF.Transformations.InPlaceTransformationRuleBase(Of TInput1, TInput2)
  name.vb: InPlaceTransformationRuleBase(Of TInput1, TInput2)
  spec.csharp:
  - uid: NMF.Transformations.InPlaceTransformationRuleBase`2
    name: InPlaceTransformationRuleBase
    nameWithType: InPlaceTransformationRuleBase
    fullName: NMF.Transformations.InPlaceTransformationRuleBase
  - name: <
    nameWithType: <
    fullName: <
  - name: TInput1
    nameWithType: TInput1
    fullName: TInput1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TInput2
    nameWithType: TInput2
    fullName: TInput2
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: NMF.Transformations.InPlaceTransformationRuleBase`2
    name: InPlaceTransformationRuleBase
    nameWithType: InPlaceTransformationRuleBase
    fullName: NMF.Transformations.InPlaceTransformationRuleBase
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TInput1
    nameWithType: TInput1
    fullName: TInput1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TInput2
    nameWithType: TInput2
    fullName: TInput2
  - name: )
    nameWithType: )
    fullName: )
- uid: INotifyEnumerable{NMF.Transformations.Linq.InPlaceComputationWrapper{{TInput1},{TInput2}}}
  commentId: '!:INotifyEnumerable{NMF.Transformations.Linq.InPlaceComputationWrapper{``0,``1}}'
  definition: INotifyEnumerable`1
  name: INotifyEnumerable<InPlaceComputationWrapper<TInput1, TInput2>>
  nameWithType: INotifyEnumerable<InPlaceComputationWrapper<TInput1, TInput2>>
  fullName: INotifyEnumerable<NMF.Transformations.Linq.InPlaceComputationWrapper<TInput1, TInput2>>
  nameWithType.vb: INotifyEnumerable(Of InPlaceComputationWrapper(Of TInput1, TInput2))
  fullName.vb: INotifyEnumerable(Of NMF.Transformations.Linq.InPlaceComputationWrapper(Of TInput1, TInput2))
  name.vb: INotifyEnumerable(Of InPlaceComputationWrapper(Of TInput1, TInput2))
  spec.csharp:
  - uid: INotifyEnumerable`1
    name: INotifyEnumerable
    nameWithType: INotifyEnumerable
    fullName: INotifyEnumerable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: NMF.Transformations.Linq.InPlaceComputationWrapper`2
    name: InPlaceComputationWrapper
    nameWithType: InPlaceComputationWrapper
    fullName: NMF.Transformations.Linq.InPlaceComputationWrapper
  - name: <
    nameWithType: <
    fullName: <
  - name: TInput1
    nameWithType: TInput1
    fullName: TInput1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TInput2
    nameWithType: TInput2
    fullName: TInput2
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: INotifyEnumerable`1
    name: INotifyEnumerable
    nameWithType: INotifyEnumerable
    fullName: INotifyEnumerable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: NMF.Transformations.Linq.InPlaceComputationWrapper`2
    name: InPlaceComputationWrapper
    nameWithType: InPlaceComputationWrapper
    fullName: NMF.Transformations.Linq.InPlaceComputationWrapper
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TInput1
    nameWithType: TInput1
    fullName: TInput1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TInput2
    nameWithType: TInput2
    fullName: TInput2
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
- uid: NMF.Transformations.InPlaceTransformationRuleBase`2
  commentId: T:NMF.Transformations.InPlaceTransformationRuleBase`2
  name: InPlaceTransformationRuleBase<TIn1, TIn2>
  nameWithType: InPlaceTransformationRuleBase<TIn1, TIn2>
  fullName: NMF.Transformations.InPlaceTransformationRuleBase<TIn1, TIn2>
  nameWithType.vb: InPlaceTransformationRuleBase(Of TIn1, TIn2)
  fullName.vb: NMF.Transformations.InPlaceTransformationRuleBase(Of TIn1, TIn2)
  name.vb: InPlaceTransformationRuleBase(Of TIn1, TIn2)
  spec.csharp:
  - uid: NMF.Transformations.InPlaceTransformationRuleBase`2
    name: InPlaceTransformationRuleBase
    nameWithType: InPlaceTransformationRuleBase
    fullName: NMF.Transformations.InPlaceTransformationRuleBase
  - name: <
    nameWithType: <
    fullName: <
  - name: TIn1
    nameWithType: TIn1
    fullName: TIn1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TIn2
    nameWithType: TIn2
    fullName: TIn2
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: NMF.Transformations.InPlaceTransformationRuleBase`2
    name: InPlaceTransformationRuleBase
    nameWithType: InPlaceTransformationRuleBase
    fullName: NMF.Transformations.InPlaceTransformationRuleBase
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TIn1
    nameWithType: TIn1
    fullName: TIn1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TIn2
    nameWithType: TIn2
    fullName: TIn2
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{{TInput1},{TInput2}},System.Boolean}
  commentId: T:System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{``0,``1},System.Boolean}
  parent: System
  definition: System.Func`2
  name: Func<InPlaceComputationWrapper<TInput1, TInput2>, Boolean>
  nameWithType: Func<InPlaceComputationWrapper<TInput1, TInput2>, Boolean>
  fullName: System.Func<NMF.Transformations.Linq.InPlaceComputationWrapper<TInput1, TInput2>, System.Boolean>
  nameWithType.vb: Func(Of InPlaceComputationWrapper(Of TInput1, TInput2), Boolean)
  fullName.vb: System.Func(Of NMF.Transformations.Linq.InPlaceComputationWrapper(Of TInput1, TInput2), System.Boolean)
  name.vb: Func(Of InPlaceComputationWrapper(Of TInput1, TInput2), Boolean)
  spec.csharp:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: NMF.Transformations.Linq.InPlaceComputationWrapper`2
    name: InPlaceComputationWrapper
    nameWithType: InPlaceComputationWrapper
    fullName: NMF.Transformations.Linq.InPlaceComputationWrapper
  - name: <
    nameWithType: <
    fullName: <
  - name: TInput1
    nameWithType: TInput1
    fullName: TInput1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TInput2
    nameWithType: TInput2
    fullName: TInput2
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Boolean
    name: Boolean
    nameWithType: Boolean
    fullName: System.Boolean
    isExternal: true
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: NMF.Transformations.Linq.InPlaceComputationWrapper`2
    name: InPlaceComputationWrapper
    nameWithType: InPlaceComputationWrapper
    fullName: NMF.Transformations.Linq.InPlaceComputationWrapper
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TInput1
    nameWithType: TInput1
    fullName: TInput1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TInput2
    nameWithType: TInput2
    fullName: TInput2
  - name: )
    nameWithType: )
    fullName: )
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Boolean
    name: Boolean
    nameWithType: Boolean
    fullName: System.Boolean
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{NMF.Transformations.Linq.InPlaceComputationWrapper{{TInput}}}}
  commentId: T:System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{NMF.Transformations.Linq.InPlaceComputationWrapper{``0}}}
  parent: System
  definition: System.Func`2
  name: Func<ITransformationContext, INotifyEnumerable<InPlaceComputationWrapper<TInput>>>
  nameWithType: Func<ITransformationContext, INotifyEnumerable<InPlaceComputationWrapper<TInput>>>
  fullName: System.Func<NMF.Transformations.Core.ITransformationContext, INotifyEnumerable<NMF.Transformations.Linq.InPlaceComputationWrapper<TInput>>>
  nameWithType.vb: Func(Of ITransformationContext, INotifyEnumerable(Of InPlaceComputationWrapper(Of TInput)))
  fullName.vb: System.Func(Of NMF.Transformations.Core.ITransformationContext, INotifyEnumerable(Of NMF.Transformations.Linq.InPlaceComputationWrapper(Of TInput)))
  name.vb: Func(Of ITransformationContext, INotifyEnumerable(Of InPlaceComputationWrapper(Of TInput)))
  spec.csharp:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: NMF.Transformations.Core.ITransformationContext
    name: ITransformationContext
    nameWithType: ITransformationContext
    fullName: NMF.Transformations.Core.ITransformationContext
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: INotifyEnumerable`1
    name: INotifyEnumerable
    nameWithType: INotifyEnumerable
    fullName: INotifyEnumerable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: NMF.Transformations.Linq.InPlaceComputationWrapper`1
    name: InPlaceComputationWrapper
    nameWithType: InPlaceComputationWrapper
    fullName: NMF.Transformations.Linq.InPlaceComputationWrapper
  - name: <
    nameWithType: <
    fullName: <
  - name: TInput
    nameWithType: TInput
    fullName: TInput
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: NMF.Transformations.Core.ITransformationContext
    name: ITransformationContext
    nameWithType: ITransformationContext
    fullName: NMF.Transformations.Core.ITransformationContext
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: INotifyEnumerable`1
    name: INotifyEnumerable
    nameWithType: INotifyEnumerable
    fullName: INotifyEnumerable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: NMF.Transformations.Linq.InPlaceComputationWrapper`1
    name: InPlaceComputationWrapper
    nameWithType: InPlaceComputationWrapper
    fullName: NMF.Transformations.Linq.InPlaceComputationWrapper
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TInput
    nameWithType: TInput
    fullName: TInput
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{NMF.Transformations.Linq.InPlaceComputationWrapper{{TInput1},{TInput2}}}}
  commentId: T:System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{NMF.Transformations.Linq.InPlaceComputationWrapper{``0,``1}}}
  parent: System
  definition: System.Func`2
  name: Func<ITransformationContext, INotifyEnumerable<InPlaceComputationWrapper<TInput1, TInput2>>>
  nameWithType: Func<ITransformationContext, INotifyEnumerable<InPlaceComputationWrapper<TInput1, TInput2>>>
  fullName: System.Func<NMF.Transformations.Core.ITransformationContext, INotifyEnumerable<NMF.Transformations.Linq.InPlaceComputationWrapper<TInput1, TInput2>>>
  nameWithType.vb: Func(Of ITransformationContext, INotifyEnumerable(Of InPlaceComputationWrapper(Of TInput1, TInput2)))
  fullName.vb: System.Func(Of NMF.Transformations.Core.ITransformationContext, INotifyEnumerable(Of NMF.Transformations.Linq.InPlaceComputationWrapper(Of TInput1, TInput2)))
  name.vb: Func(Of ITransformationContext, INotifyEnumerable(Of InPlaceComputationWrapper(Of TInput1, TInput2)))
  spec.csharp:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: NMF.Transformations.Core.ITransformationContext
    name: ITransformationContext
    nameWithType: ITransformationContext
    fullName: NMF.Transformations.Core.ITransformationContext
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: INotifyEnumerable`1
    name: INotifyEnumerable
    nameWithType: INotifyEnumerable
    fullName: INotifyEnumerable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: NMF.Transformations.Linq.InPlaceComputationWrapper`2
    name: InPlaceComputationWrapper
    nameWithType: InPlaceComputationWrapper
    fullName: NMF.Transformations.Linq.InPlaceComputationWrapper
  - name: <
    nameWithType: <
    fullName: <
  - name: TInput1
    nameWithType: TInput1
    fullName: TInput1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TInput2
    nameWithType: TInput2
    fullName: TInput2
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: NMF.Transformations.Core.ITransformationContext
    name: ITransformationContext
    nameWithType: ITransformationContext
    fullName: NMF.Transformations.Core.ITransformationContext
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: INotifyEnumerable`1
    name: INotifyEnumerable
    nameWithType: INotifyEnumerable
    fullName: INotifyEnumerable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: NMF.Transformations.Linq.InPlaceComputationWrapper`2
    name: InPlaceComputationWrapper
    nameWithType: InPlaceComputationWrapper
    fullName: NMF.Transformations.Linq.InPlaceComputationWrapper
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TInput1
    nameWithType: TInput1
    fullName: TInput1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TInput2
    nameWithType: TInput2
    fullName: TInput2
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
- uid: NMF.Transformations.Linq.IncrementalExtensions.Where*
  commentId: Overload:NMF.Transformations.Linq.IncrementalExtensions.Where
  name: Where
  nameWithType: IncrementalExtensions.Where
  fullName: NMF.Transformations.Linq.IncrementalExtensions.Where
- uid: System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{{T}}}
  commentId: T:System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{``0}}
  parent: System
  definition: System.Func`2
  name: Func<ITransformationContext, INotifyEnumerable<T>>
  nameWithType: Func<ITransformationContext, INotifyEnumerable<T>>
  fullName: System.Func<NMF.Transformations.Core.ITransformationContext, INotifyEnumerable<T>>
  nameWithType.vb: Func(Of ITransformationContext, INotifyEnumerable(Of T))
  fullName.vb: System.Func(Of NMF.Transformations.Core.ITransformationContext, INotifyEnumerable(Of T))
  name.vb: Func(Of ITransformationContext, INotifyEnumerable(Of T))
  spec.csharp:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: NMF.Transformations.Core.ITransformationContext
    name: ITransformationContext
    nameWithType: ITransformationContext
    fullName: NMF.Transformations.Core.ITransformationContext
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: INotifyEnumerable`1
    name: INotifyEnumerable
    nameWithType: INotifyEnumerable
    fullName: INotifyEnumerable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: NMF.Transformations.Core.ITransformationContext
    name: ITransformationContext
    nameWithType: ITransformationContext
    fullName: NMF.Transformations.Core.ITransformationContext
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: INotifyEnumerable`1
    name: INotifyEnumerable
    nameWithType: INotifyEnumerable
    fullName: INotifyEnumerable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Linq.Expressions.Expression{System.Func{{T},System.Boolean}}
  commentId: T:System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}}
  parent: System.Linq.Expressions
  definition: System.Linq.Expressions.Expression`1
  name: Expression<Func<T, Boolean>>
  nameWithType: Expression<Func<T, Boolean>>
  fullName: System.Linq.Expressions.Expression<System.Func<T, System.Boolean>>
  nameWithType.vb: Expression(Of Func(Of T, Boolean))
  fullName.vb: System.Linq.Expressions.Expression(Of System.Func(Of T, System.Boolean))
  name.vb: Expression(Of Func(Of T, Boolean))
  spec.csharp:
  - uid: System.Linq.Expressions.Expression`1
    name: Expression
    nameWithType: Expression
    fullName: System.Linq.Expressions.Expression
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Boolean
    name: Boolean
    nameWithType: Boolean
    fullName: System.Boolean
    isExternal: true
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Linq.Expressions.Expression`1
    name: Expression
    nameWithType: Expression
    fullName: System.Linq.Expressions.Expression
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Boolean
    name: Boolean
    nameWithType: Boolean
    fullName: System.Boolean
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Linq.Expressions.Expression`1
  commentId: T:System.Linq.Expressions.Expression`1
  isExternal: true
  name: Expression<TDelegate>
  nameWithType: Expression<TDelegate>
  fullName: System.Linq.Expressions.Expression<TDelegate>
  nameWithType.vb: Expression(Of TDelegate)
  fullName.vb: System.Linq.Expressions.Expression(Of TDelegate)
  name.vb: Expression(Of TDelegate)
  spec.csharp:
  - uid: System.Linq.Expressions.Expression`1
    name: Expression
    nameWithType: Expression
    fullName: System.Linq.Expressions.Expression
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TDelegate
    nameWithType: TDelegate
    fullName: TDelegate
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Linq.Expressions.Expression`1
    name: Expression
    nameWithType: Expression
    fullName: System.Linq.Expressions.Expression
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TDelegate
    nameWithType: TDelegate
    fullName: TDelegate
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Linq.Expressions
  commentId: N:System.Linq.Expressions
  isExternal: true
  name: System.Linq.Expressions
  nameWithType: System.Linq.Expressions
  fullName: System.Linq.Expressions
- uid: NMF.Transformations.Linq.IncrementalExtensions.Select*
  commentId: Overload:NMF.Transformations.Linq.IncrementalExtensions.Select
  name: Select
  nameWithType: IncrementalExtensions.Select
  fullName: NMF.Transformations.Linq.IncrementalExtensions.Select
- uid: System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{{T1}}}
  commentId: T:System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{``0}}
  parent: System
  definition: System.Func`2
  name: Func<ITransformationContext, INotifyEnumerable<T1>>
  nameWithType: Func<ITransformationContext, INotifyEnumerable<T1>>
  fullName: System.Func<NMF.Transformations.Core.ITransformationContext, INotifyEnumerable<T1>>
  nameWithType.vb: Func(Of ITransformationContext, INotifyEnumerable(Of T1))
  fullName.vb: System.Func(Of NMF.Transformations.Core.ITransformationContext, INotifyEnumerable(Of T1))
  name.vb: Func(Of ITransformationContext, INotifyEnumerable(Of T1))
  spec.csharp:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: NMF.Transformations.Core.ITransformationContext
    name: ITransformationContext
    nameWithType: ITransformationContext
    fullName: NMF.Transformations.Core.ITransformationContext
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: INotifyEnumerable`1
    name: INotifyEnumerable
    nameWithType: INotifyEnumerable
    fullName: INotifyEnumerable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T1
    nameWithType: T1
    fullName: T1
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: NMF.Transformations.Core.ITransformationContext
    name: ITransformationContext
    nameWithType: ITransformationContext
    fullName: NMF.Transformations.Core.ITransformationContext
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: INotifyEnumerable`1
    name: INotifyEnumerable
    nameWithType: INotifyEnumerable
    fullName: INotifyEnumerable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T1
    nameWithType: T1
    fullName: T1
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Linq.Expressions.Expression{System.Func{{T1},{T2}}}
  commentId: T:System.Linq.Expressions.Expression{System.Func{``0,``1}}
  parent: System.Linq.Expressions
  definition: System.Linq.Expressions.Expression`1
  name: Expression<Func<T1, T2>>
  nameWithType: Expression<Func<T1, T2>>
  fullName: System.Linq.Expressions.Expression<System.Func<T1, T2>>
  nameWithType.vb: Expression(Of Func(Of T1, T2))
  fullName.vb: System.Linq.Expressions.Expression(Of System.Func(Of T1, T2))
  name.vb: Expression(Of Func(Of T1, T2))
  spec.csharp:
  - uid: System.Linq.Expressions.Expression`1
    name: Expression
    nameWithType: Expression
    fullName: System.Linq.Expressions.Expression
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T1
    nameWithType: T1
    fullName: T1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: T2
    nameWithType: T2
    fullName: T2
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Linq.Expressions.Expression`1
    name: Expression
    nameWithType: Expression
    fullName: System.Linq.Expressions.Expression
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T1
    nameWithType: T1
    fullName: T1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: T2
    nameWithType: T2
    fullName: T2
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{{T2}}}
  commentId: T:System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{``1}}
  parent: System
  definition: System.Func`2
  name: Func<ITransformationContext, INotifyEnumerable<T2>>
  nameWithType: Func<ITransformationContext, INotifyEnumerable<T2>>
  fullName: System.Func<NMF.Transformations.Core.ITransformationContext, INotifyEnumerable<T2>>
  nameWithType.vb: Func(Of ITransformationContext, INotifyEnumerable(Of T2))
  fullName.vb: System.Func(Of NMF.Transformations.Core.ITransformationContext, INotifyEnumerable(Of T2))
  name.vb: Func(Of ITransformationContext, INotifyEnumerable(Of T2))
  spec.csharp:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: NMF.Transformations.Core.ITransformationContext
    name: ITransformationContext
    nameWithType: ITransformationContext
    fullName: NMF.Transformations.Core.ITransformationContext
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: INotifyEnumerable`1
    name: INotifyEnumerable
    nameWithType: INotifyEnumerable
    fullName: INotifyEnumerable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T2
    nameWithType: T2
    fullName: T2
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: NMF.Transformations.Core.ITransformationContext
    name: ITransformationContext
    nameWithType: ITransformationContext
    fullName: NMF.Transformations.Core.ITransformationContext
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: INotifyEnumerable`1
    name: INotifyEnumerable
    nameWithType: INotifyEnumerable
    fullName: INotifyEnumerable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T2
    nameWithType: T2
    fullName: T2
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
- uid: NMF.Transformations.Linq.IncrementalExtensions.SelectMany*
  commentId: Overload:NMF.Transformations.Linq.IncrementalExtensions.SelectMany
  name: SelectMany
  nameWithType: IncrementalExtensions.SelectMany
  fullName: NMF.Transformations.Linq.IncrementalExtensions.SelectMany
- uid: System.Linq.Expressions.Expression{System.Func{{T1},System.Func{NMF.Transformations.Core.ITransformationContext,System.Collections.Generic.IEnumerable{{T2}}}}}
  commentId: T:System.Linq.Expressions.Expression{System.Func{``0,System.Func{NMF.Transformations.Core.ITransformationContext,System.Collections.Generic.IEnumerable{``1}}}}
  parent: System.Linq.Expressions
  definition: System.Linq.Expressions.Expression`1
  name: Expression<Func<T1, Func<ITransformationContext, IEnumerable<T2>>>>
  nameWithType: Expression<Func<T1, Func<ITransformationContext, IEnumerable<T2>>>>
  fullName: System.Linq.Expressions.Expression<System.Func<T1, System.Func<NMF.Transformations.Core.ITransformationContext, System.Collections.Generic.IEnumerable<T2>>>>
  nameWithType.vb: Expression(Of Func(Of T1, Func(Of ITransformationContext, IEnumerable(Of T2))))
  fullName.vb: System.Linq.Expressions.Expression(Of System.Func(Of T1, System.Func(Of NMF.Transformations.Core.ITransformationContext, System.Collections.Generic.IEnumerable(Of T2))))
  name.vb: Expression(Of Func(Of T1, Func(Of ITransformationContext, IEnumerable(Of T2))))
  spec.csharp:
  - uid: System.Linq.Expressions.Expression`1
    name: Expression
    nameWithType: Expression
    fullName: System.Linq.Expressions.Expression
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T1
    nameWithType: T1
    fullName: T1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: NMF.Transformations.Core.ITransformationContext
    name: ITransformationContext
    nameWithType: ITransformationContext
    fullName: NMF.Transformations.Core.ITransformationContext
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T2
    nameWithType: T2
    fullName: T2
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Linq.Expressions.Expression`1
    name: Expression
    nameWithType: Expression
    fullName: System.Linq.Expressions.Expression
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T1
    nameWithType: T1
    fullName: T1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: NMF.Transformations.Core.ITransformationContext
    name: ITransformationContext
    nameWithType: ITransformationContext
    fullName: NMF.Transformations.Core.ITransformationContext
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T2
    nameWithType: T2
    fullName: T2
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Linq.Expressions.Expression{System.Func{{T1},{T2},{T3}}}
  commentId: T:System.Linq.Expressions.Expression{System.Func{``0,``1,``2}}
  parent: System.Linq.Expressions
  definition: System.Linq.Expressions.Expression`1
  name: Expression<Func<T1, T2, T3>>
  nameWithType: Expression<Func<T1, T2, T3>>
  fullName: System.Linq.Expressions.Expression<System.Func<T1, T2, T3>>
  nameWithType.vb: Expression(Of Func(Of T1, T2, T3))
  fullName.vb: System.Linq.Expressions.Expression(Of System.Func(Of T1, T2, T3))
  name.vb: Expression(Of Func(Of T1, T2, T3))
  spec.csharp:
  - uid: System.Linq.Expressions.Expression`1
    name: Expression
    nameWithType: Expression
    fullName: System.Linq.Expressions.Expression
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Func`3
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T1
    nameWithType: T1
    fullName: T1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: T2
    nameWithType: T2
    fullName: T2
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: T3
    nameWithType: T3
    fullName: T3
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Linq.Expressions.Expression`1
    name: Expression
    nameWithType: Expression
    fullName: System.Linq.Expressions.Expression
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.Func`3
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T1
    nameWithType: T1
    fullName: T1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: T2
    nameWithType: T2
    fullName: T2
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: T3
    nameWithType: T3
    fullName: T3
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{{T3}}}
  commentId: T:System.Func{NMF.Transformations.Core.ITransformationContext,INotifyEnumerable{``2}}
  parent: System
  definition: System.Func`2
  name: Func<ITransformationContext, INotifyEnumerable<T3>>
  nameWithType: Func<ITransformationContext, INotifyEnumerable<T3>>
  fullName: System.Func<NMF.Transformations.Core.ITransformationContext, INotifyEnumerable<T3>>
  nameWithType.vb: Func(Of ITransformationContext, INotifyEnumerable(Of T3))
  fullName.vb: System.Func(Of NMF.Transformations.Core.ITransformationContext, INotifyEnumerable(Of T3))
  name.vb: Func(Of ITransformationContext, INotifyEnumerable(Of T3))
  spec.csharp:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: NMF.Transformations.Core.ITransformationContext
    name: ITransformationContext
    nameWithType: ITransformationContext
    fullName: NMF.Transformations.Core.ITransformationContext
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: INotifyEnumerable`1
    name: INotifyEnumerable
    nameWithType: INotifyEnumerable
    fullName: INotifyEnumerable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T3
    nameWithType: T3
    fullName: T3
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: NMF.Transformations.Core.ITransformationContext
    name: ITransformationContext
    nameWithType: ITransformationContext
    fullName: NMF.Transformations.Core.ITransformationContext
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: INotifyEnumerable`1
    name: INotifyEnumerable
    nameWithType: INotifyEnumerable
    fullName: INotifyEnumerable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T3
    nameWithType: T3
    fullName: T3
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
