### YamlMime:ManagedReference
items:
- uid: NMF.Transformations.TraceExtensions
  commentId: T:NMF.Transformations.TraceExtensions
  id: TraceExtensions
  parent: NMF.Transformations
  children:
  - NMF.Transformations.TraceExtensions.FindAll``1(NMF.Transformations.Core.ITransformationTrace,System.Type[])
  - NMF.Transformations.TraceExtensions.FindAll``2(NMF.Transformations.Core.ITransformationTrace)
  - NMF.Transformations.TraceExtensions.FindAll``3(NMF.Transformations.Core.ITransformationTrace)
  - NMF.Transformations.TraceExtensions.FindAllIn``1(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0})
  - NMF.Transformations.TraceExtensions.FindAllIn``2(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1})
  - NMF.Transformations.TraceExtensions.FindAllIn``3(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1,``2})
  - NMF.Transformations.TraceExtensions.FindInWhere``1(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0},System.Predicate{``0})
  - NMF.Transformations.TraceExtensions.FindInWhere``2(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1},System.Predicate{``1})
  - NMF.Transformations.TraceExtensions.FindInWhere``3(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Predicate{``2})
  - NMF.Transformations.TraceExtensions.FindWhere``1(NMF.Transformations.Core.ITransformationTrace,System.Type[],System.Predicate{``0})
  - NMF.Transformations.TraceExtensions.FindWhere``2(NMF.Transformations.Core.ITransformationTrace,System.Predicate{``1})
  - NMF.Transformations.TraceExtensions.FindWhere``3(NMF.Transformations.Core.ITransformationTrace,System.Predicate{``2})
  - NMF.Transformations.TraceExtensions.GetOrCreateUserItem``1(NMF.Transformations.Core.ITransformationContext,System.Object,System.Func{``0})
  - NMF.Transformations.TraceExtensions.Resolve``1(NMF.Transformations.Core.ITransformationTrace,System.Object[])
  - NMF.Transformations.TraceExtensions.Resolve``2(NMF.Transformations.Core.ITransformationTrace,``0)
  - NMF.Transformations.TraceExtensions.Resolve``3(NMF.Transformations.Core.ITransformationTrace,``0,``1)
  - NMF.Transformations.TraceExtensions.ResolveIn(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.Core.GeneralTransformationRule,System.Object[])
  - NMF.Transformations.TraceExtensions.ResolveIn``1(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0},System.Object[])
  - NMF.Transformations.TraceExtensions.ResolveIn``2(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1},``0)
  - NMF.Transformations.TraceExtensions.ResolveIn``3(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1,``2},``0,``1)
  - NMF.Transformations.TraceExtensions.ResolveInWhere(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.Core.GeneralTransformationRule,System.Predicate{NMF.Transformations.Core.ITraceEntry})
  - NMF.Transformations.TraceExtensions.ResolveInWhere``1(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0},System.Predicate{System.Object[]})
  - NMF.Transformations.TraceExtensions.ResolveInWhere``2(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1},System.Predicate{``0})
  - NMF.Transformations.TraceExtensions.ResolveInWhere``3(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Func{``0,``1,System.Boolean})
  - NMF.Transformations.TraceExtensions.ResolveMany``2(NMF.Transformations.Core.ITransformationTrace,``0)
  - NMF.Transformations.TraceExtensions.ResolveMany``2(NMF.Transformations.Core.ITransformationTrace,``0[])
  - NMF.Transformations.TraceExtensions.ResolveMany``2(NMF.Transformations.Core.ITransformationTrace,System.Collections.Generic.IEnumerable{``0})
  - NMF.Transformations.TraceExtensions.ResolveManyIn``2(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1},``0)
  - NMF.Transformations.TraceExtensions.ResolveManyIn``2(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1},``0[])
  - NMF.Transformations.TraceExtensions.ResolveManyIn``2(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1},System.Collections.Generic.IEnumerable{``0})
  - NMF.Transformations.TraceExtensions.ResolveWhere``1(NMF.Transformations.Core.ITransformationTrace,System.Type[],System.Predicate{System.Object[]})
  - NMF.Transformations.TraceExtensions.ResolveWhere``2(NMF.Transformations.Core.ITransformationTrace,System.Predicate{``0})
  - NMF.Transformations.TraceExtensions.ResolveWhere``3(NMF.Transformations.Core.ITransformationTrace,System.Func{``0,``1,System.Boolean})
  - NMF.Transformations.TraceExtensions.TraceInWhere(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.Core.GeneralTransformationRule,System.Predicate{System.Object[]})
  - NMF.Transformations.TraceExtensions.TraceInWhere``1(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.GeneralTransformationRule{``0},System.Predicate{``0})
  - NMF.Transformations.TraceExtensions.TraceInWhere``2(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.GeneralTransformationRule{``0,``1},System.Func{``0,``1,System.Boolean})
  langs:
  - csharp
  - vb
  name: TraceExtensions
  nameWithType: TraceExtensions
  fullName: NMF.Transformations.TraceExtensions
  type: Class
  source:
    remote:
      path: Transformations/Transformations/NTL/TraceExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: TraceExtensions
    path: src/Transformations/Transformations/NTL/TraceExtensions.cs
    startLine: 12
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations
  summary: "\nThis helper class provides additional methods for tracing purposes\n"
  example: []
  syntax:
    content: public static class TraceExtensions
    content.vb: Public Module TraceExtensions
  inheritance:
  - System.Object
  inheritedMembers:
  - System.Object.ToString
  - System.Object.Equals(System.Object)
  - System.Object.Equals(System.Object,System.Object)
  - System.Object.ReferenceEquals(System.Object,System.Object)
  - System.Object.GetHashCode
  - System.Object.GetType
  - System.Object.MemberwiseClone
  modifiers.csharp:
  - public
  - static
  - class
  modifiers.vb:
  - Public
  - Module
- uid: NMF.Transformations.TraceExtensions.ResolveIn(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.Core.GeneralTransformationRule,System.Object[])
  commentId: M:NMF.Transformations.TraceExtensions.ResolveIn(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.Core.GeneralTransformationRule,System.Object[])
  id: ResolveIn(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.Core.GeneralTransformationRule,System.Object[])
  isExtensionMethod: true
  parent: NMF.Transformations.TraceExtensions
  langs:
  - csharp
  - vb
  name: ResolveIn(ITransformationTrace, GeneralTransformationRule, Object[])
  nameWithType: TraceExtensions.ResolveIn(ITransformationTrace, GeneralTransformationRule, Object[])
  fullName: NMF.Transformations.TraceExtensions.ResolveIn(NMF.Transformations.Core.ITransformationTrace, NMF.Transformations.Core.GeneralTransformationRule, System.Object[])
  type: Method
  source:
    remote:
      path: Transformations/Transformations/NTL/TraceExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ResolveIn
    path: src/Transformations/Transformations/NTL/TraceExtensions.cs
    startLine: 21
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations
  summary: "\nTrace the output of the computation that transformed the given input with the given transformation type\n"
  example: []
  syntax:
    content: public static object ResolveIn(this ITransformationTrace trace, GeneralTransformationRule rule, object[] input)
    parameters:
    - id: trace
      type: NMF.Transformations.Core.ITransformationTrace
      description: The trace component that is used as basis
    - id: rule
      type: NMF.Transformations.Core.GeneralTransformationRule
      description: The rule that transformed the argument
    - id: input
      type: System.Object[]
      description: The input arguments
    return:
      type: System.Object
      description: The output of the computation with the specified input argument or null, if there is none such
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ResolveIn(trace As ITransformationTrace, rule As GeneralTransformationRule, input As Object()) As Object
  overload: NMF.Transformations.TraceExtensions.ResolveIn*
  nameWithType.vb: TraceExtensions.ResolveIn(ITransformationTrace, GeneralTransformationRule, Object())
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.TraceExtensions.ResolveIn(NMF.Transformations.Core.ITransformationTrace, NMF.Transformations.Core.GeneralTransformationRule, System.Object())
  name.vb: ResolveIn(ITransformationTrace, GeneralTransformationRule, Object())
- uid: NMF.Transformations.TraceExtensions.ResolveIn``2(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1},``0)
  commentId: M:NMF.Transformations.TraceExtensions.ResolveIn``2(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1},``0)
  id: ResolveIn``2(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1},``0)
  isExtensionMethod: true
  parent: NMF.Transformations.TraceExtensions
  langs:
  - csharp
  - vb
  name: ResolveIn<TIn, TOut>(ITransformationTrace, TransformationRuleBase<TIn, TOut>, TIn)
  nameWithType: TraceExtensions.ResolveIn<TIn, TOut>(ITransformationTrace, TransformationRuleBase<TIn, TOut>, TIn)
  fullName: NMF.Transformations.TraceExtensions.ResolveIn<TIn, TOut>(NMF.Transformations.Core.ITransformationTrace, NMF.Transformations.TransformationRuleBase<TIn, TOut>, TIn)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/NTL/TraceExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ResolveIn
    path: src/Transformations/Transformations/NTL/TraceExtensions.cs
    startLine: 38
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations
  summary: "\nTrace the output of the computation that transformed the given input with the given transformation type\n"
  example: []
  syntax:
    content: >-
      public static TOut ResolveIn<TIn, TOut>(this ITransformationTrace trace, TransformationRuleBase<TIn, TOut> rule, TIn input)

          where TIn : class where TOut : class
    parameters:
    - id: trace
      type: NMF.Transformations.Core.ITransformationTrace
      description: The trace component that is used as basis
    - id: rule
      type: NMF.Transformations.TransformationRuleBase{{TIn},{TOut}}
      description: The transformation rule the object was transformed with
    - id: input
      type: '{TIn}'
      description: The input argument
    typeParameters:
    - id: TIn
      description: The input type that is looked for
    - id: TOut
      description: The output that is returned by the transformation rule
    return:
      type: '{TOut}'
      description: The output of the computation with the specified input argument or null, if there is none such
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ResolveIn(Of TIn As Class, TOut As Class)(trace As ITransformationTrace, rule As TransformationRuleBase(Of TIn, TOut), input As TIn) As TOut
  overload: NMF.Transformations.TraceExtensions.ResolveIn*
  nameWithType.vb: TraceExtensions.ResolveIn(Of TIn, TOut)(ITransformationTrace, TransformationRuleBase(Of TIn, TOut), TIn)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.TraceExtensions.ResolveIn(Of TIn, TOut)(NMF.Transformations.Core.ITransformationTrace, NMF.Transformations.TransformationRuleBase(Of TIn, TOut), TIn)
  name.vb: ResolveIn(Of TIn, TOut)(ITransformationTrace, TransformationRuleBase(Of TIn, TOut), TIn)
- uid: NMF.Transformations.TraceExtensions.Resolve``2(NMF.Transformations.Core.ITransformationTrace,``0)
  commentId: M:NMF.Transformations.TraceExtensions.Resolve``2(NMF.Transformations.Core.ITransformationTrace,``0)
  id: Resolve``2(NMF.Transformations.Core.ITransformationTrace,``0)
  isExtensionMethod: true
  parent: NMF.Transformations.TraceExtensions
  langs:
  - csharp
  - vb
  name: Resolve<TIn, TOut>(ITransformationTrace, TIn)
  nameWithType: TraceExtensions.Resolve<TIn, TOut>(ITransformationTrace, TIn)
  fullName: NMF.Transformations.TraceExtensions.Resolve<TIn, TOut>(NMF.Transformations.Core.ITransformationTrace, TIn)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/NTL/TraceExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: Resolve
    path: src/Transformations/Transformations/NTL/TraceExtensions.cs
    startLine: 57
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations
  summary: "\nTrace the output of the computation that transformed the given input into a desired output\n"
  example: []
  syntax:
    content: >-
      public static TOut Resolve<TIn, TOut>(this ITransformationTrace trace, TIn input)

          where TIn : class where TOut : class
    parameters:
    - id: trace
      type: NMF.Transformations.Core.ITransformationTrace
      description: The trace component that is used as basis
    - id: input
      type: '{TIn}'
      description: The input argument
    typeParameters:
    - id: TIn
      description: The input type that is looked for
    - id: TOut
      description: The desired output type
    return:
      type: '{TOut}'
      description: The output of the computation with the specified input argument or null, if there is none such
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function Resolve(Of TIn As Class, TOut As Class)(trace As ITransformationTrace, input As TIn) As TOut
  overload: NMF.Transformations.TraceExtensions.Resolve*
  nameWithType.vb: TraceExtensions.Resolve(Of TIn, TOut)(ITransformationTrace, TIn)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.TraceExtensions.Resolve(Of TIn, TOut)(NMF.Transformations.Core.ITransformationTrace, TIn)
  name.vb: Resolve(Of TIn, TOut)(ITransformationTrace, TIn)
- uid: NMF.Transformations.TraceExtensions.ResolveIn``3(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1,``2},``0,``1)
  commentId: M:NMF.Transformations.TraceExtensions.ResolveIn``3(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1,``2},``0,``1)
  id: ResolveIn``3(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1,``2},``0,``1)
  isExtensionMethod: true
  parent: NMF.Transformations.TraceExtensions
  langs:
  - csharp
  - vb
  name: ResolveIn<TIn1, TIn2, TOut>(ITransformationTrace, TransformationRuleBase<TIn1, TIn2, TOut>, TIn1, TIn2)
  nameWithType: TraceExtensions.ResolveIn<TIn1, TIn2, TOut>(ITransformationTrace, TransformationRuleBase<TIn1, TIn2, TOut>, TIn1, TIn2)
  fullName: NMF.Transformations.TraceExtensions.ResolveIn<TIn1, TIn2, TOut>(NMF.Transformations.Core.ITransformationTrace, NMF.Transformations.TransformationRuleBase<TIn1, TIn2, TOut>, TIn1, TIn2)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/NTL/TraceExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ResolveIn
    path: src/Transformations/Transformations/NTL/TraceExtensions.cs
    startLine: 80
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations
  summary: "\nTrace the output of the computation that transformed the given input with the given transformation type\n"
  example: []
  syntax:
    content: >-
      public static TOut ResolveIn<TIn1, TIn2, TOut>(this ITransformationTrace trace, TransformationRuleBase<TIn1, TIn2, TOut> rule, TIn1 input1, TIn2 input2)

          where TIn1 : class where TIn2 : class where TOut : class
    parameters:
    - id: trace
      type: NMF.Transformations.Core.ITransformationTrace
      description: The trace component that is used as basis
    - id: rule
      type: NMF.Transformations.TransformationRuleBase{{TIn1},{TIn2},{TOut}}
      description: The transformation rule the object was transformed with
    - id: input1
      type: '{TIn1}'
      description: The first input argument
    - id: input2
      type: '{TIn2}'
      description: The second input argument
    typeParameters:
    - id: TIn1
      description: The first input type that is looked for
    - id: TIn2
      description: The second input type that is looked for
    - id: TOut
      description: The output that is returned by the transformation rule
    return:
      type: '{TOut}'
      description: The output of the computation with the specified input argument or null, if there is none such
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ResolveIn(Of TIn1 As Class, TIn2 As Class, TOut As Class)(trace As ITransformationTrace, rule As TransformationRuleBase(Of TIn1, TIn2, TOut), input1 As TIn1, input2 As TIn2) As TOut
  overload: NMF.Transformations.TraceExtensions.ResolveIn*
  nameWithType.vb: TraceExtensions.ResolveIn(Of TIn1, TIn2, TOut)(ITransformationTrace, TransformationRuleBase(Of TIn1, TIn2, TOut), TIn1, TIn2)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.TraceExtensions.ResolveIn(Of TIn1, TIn2, TOut)(NMF.Transformations.Core.ITransformationTrace, NMF.Transformations.TransformationRuleBase(Of TIn1, TIn2, TOut), TIn1, TIn2)
  name.vb: ResolveIn(Of TIn1, TIn2, TOut)(ITransformationTrace, TransformationRuleBase(Of TIn1, TIn2, TOut), TIn1, TIn2)
- uid: NMF.Transformations.TraceExtensions.Resolve``3(NMF.Transformations.Core.ITransformationTrace,``0,``1)
  commentId: M:NMF.Transformations.TraceExtensions.Resolve``3(NMF.Transformations.Core.ITransformationTrace,``0,``1)
  id: Resolve``3(NMF.Transformations.Core.ITransformationTrace,``0,``1)
  isExtensionMethod: true
  parent: NMF.Transformations.TraceExtensions
  langs:
  - csharp
  - vb
  name: Resolve<TIn1, TIn2, TOut>(ITransformationTrace, TIn1, TIn2)
  nameWithType: TraceExtensions.Resolve<TIn1, TIn2, TOut>(ITransformationTrace, TIn1, TIn2)
  fullName: NMF.Transformations.TraceExtensions.Resolve<TIn1, TIn2, TOut>(NMF.Transformations.Core.ITransformationTrace, TIn1, TIn2)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/NTL/TraceExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: Resolve
    path: src/Transformations/Transformations/NTL/TraceExtensions.cs
    startLine: 102
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations
  summary: "\nTrace the output of the computation that transformed the given input with the given transformation type\n"
  example: []
  syntax:
    content: >-
      public static TOut Resolve<TIn1, TIn2, TOut>(this ITransformationTrace trace, TIn1 input1, TIn2 input2)

          where TIn1 : class where TIn2 : class where TOut : class
    parameters:
    - id: trace
      type: NMF.Transformations.Core.ITransformationTrace
      description: The trace component that is used as basis
    - id: input1
      type: '{TIn1}'
      description: The first input argument
    - id: input2
      type: '{TIn2}'
      description: The second input argument
    typeParameters:
    - id: TIn1
      description: The first input type that is looked for
    - id: TIn2
      description: The second input type that is looked for
    - id: TOut
      description: The output that is returned by the transformation rule
    return:
      type: '{TOut}'
      description: The output of the computation with the specified input argument or null, if there is none such
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function Resolve(Of TIn1 As Class, TIn2 As Class, TOut As Class)(trace As ITransformationTrace, input1 As TIn1, input2 As TIn2) As TOut
  overload: NMF.Transformations.TraceExtensions.Resolve*
  nameWithType.vb: TraceExtensions.Resolve(Of TIn1, TIn2, TOut)(ITransformationTrace, TIn1, TIn2)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.TraceExtensions.Resolve(Of TIn1, TIn2, TOut)(NMF.Transformations.Core.ITransformationTrace, TIn1, TIn2)
  name.vb: Resolve(Of TIn1, TIn2, TOut)(ITransformationTrace, TIn1, TIn2)
- uid: NMF.Transformations.TraceExtensions.ResolveIn``1(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0},System.Object[])
  commentId: M:NMF.Transformations.TraceExtensions.ResolveIn``1(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0},System.Object[])
  id: ResolveIn``1(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0},System.Object[])
  isExtensionMethod: true
  parent: NMF.Transformations.TraceExtensions
  langs:
  - csharp
  - vb
  name: ResolveIn<TOut>(ITransformationTrace, TransformationRuleBase<TOut>, Object[])
  nameWithType: TraceExtensions.ResolveIn<TOut>(ITransformationTrace, TransformationRuleBase<TOut>, Object[])
  fullName: NMF.Transformations.TraceExtensions.ResolveIn<TOut>(NMF.Transformations.Core.ITransformationTrace, NMF.Transformations.TransformationRuleBase<TOut>, System.Object[])
  type: Method
  source:
    remote:
      path: Transformations/Transformations/NTL/TraceExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ResolveIn
    path: src/Transformations/Transformations/NTL/TraceExtensions.cs
    startLine: 123
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations
  summary: "\nTrace the output of the computation that transformed the given input with the given transformation type\n"
  example: []
  syntax:
    content: >-
      public static TOut ResolveIn<TOut>(this ITransformationTrace trace, TransformationRuleBase<TOut> rule, object[] input)

          where TOut : class
    parameters:
    - id: trace
      type: NMF.Transformations.Core.ITransformationTrace
      description: The trace component that is used as basis
    - id: rule
      type: NMF.Transformations.TransformationRuleBase{{TOut}}
      description: The transformation rule the object was transformed with
    - id: input
      type: System.Object[]
      description: The input arguments
    typeParameters:
    - id: TOut
      description: The output that is returned by the transformation rule
    return:
      type: '{TOut}'
      description: The output of the computation with the specified input argument or null, if there is none such
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ResolveIn(Of TOut As Class)(trace As ITransformationTrace, rule As TransformationRuleBase(Of TOut), input As Object()) As TOut
  overload: NMF.Transformations.TraceExtensions.ResolveIn*
  nameWithType.vb: TraceExtensions.ResolveIn(Of TOut)(ITransformationTrace, TransformationRuleBase(Of TOut), Object())
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.TraceExtensions.ResolveIn(Of TOut)(NMF.Transformations.Core.ITransformationTrace, NMF.Transformations.TransformationRuleBase(Of TOut), System.Object())
  name.vb: ResolveIn(Of TOut)(ITransformationTrace, TransformationRuleBase(Of TOut), Object())
- uid: NMF.Transformations.TraceExtensions.Resolve``1(NMF.Transformations.Core.ITransformationTrace,System.Object[])
  commentId: M:NMF.Transformations.TraceExtensions.Resolve``1(NMF.Transformations.Core.ITransformationTrace,System.Object[])
  id: Resolve``1(NMF.Transformations.Core.ITransformationTrace,System.Object[])
  isExtensionMethod: true
  parent: NMF.Transformations.TraceExtensions
  langs:
  - csharp
  - vb
  name: Resolve<TOut>(ITransformationTrace, Object[])
  nameWithType: TraceExtensions.Resolve<TOut>(ITransformationTrace, Object[])
  fullName: NMF.Transformations.TraceExtensions.Resolve<TOut>(NMF.Transformations.Core.ITransformationTrace, System.Object[])
  type: Method
  source:
    remote:
      path: Transformations/Transformations/NTL/TraceExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: Resolve
    path: src/Transformations/Transformations/NTL/TraceExtensions.cs
    startLine: 141
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations
  summary: "\nTrace the output of the computation that transformed the given input with the given transformation type\n"
  example: []
  syntax:
    content: >-
      public static TOut Resolve<TOut>(this ITransformationTrace trace, object[] input)

          where TOut : class
    parameters:
    - id: trace
      type: NMF.Transformations.Core.ITransformationTrace
      description: The trace component that is used as basis
    - id: input
      type: System.Object[]
      description: The input arguments
    typeParameters:
    - id: TOut
      description: The output that is returned by the transformation rule
    return:
      type: '{TOut}'
      description: The output of the computation with the specified input argument or null, if there is none such
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function Resolve(Of TOut As Class)(trace As ITransformationTrace, input As Object()) As TOut
  overload: NMF.Transformations.TraceExtensions.Resolve*
  nameWithType.vb: TraceExtensions.Resolve(Of TOut)(ITransformationTrace, Object())
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.TraceExtensions.Resolve(Of TOut)(NMF.Transformations.Core.ITransformationTrace, System.Object())
  name.vb: Resolve(Of TOut)(ITransformationTrace, Object())
- uid: NMF.Transformations.TraceExtensions.ResolveInWhere``2(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1},System.Predicate{``0})
  commentId: M:NMF.Transformations.TraceExtensions.ResolveInWhere``2(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1},System.Predicate{``0})
  id: ResolveInWhere``2(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1},System.Predicate{``0})
  isExtensionMethod: true
  parent: NMF.Transformations.TraceExtensions
  langs:
  - csharp
  - vb
  name: ResolveInWhere<TIn, TOut>(ITransformationTrace, TransformationRuleBase<TIn, TOut>, Predicate<TIn>)
  nameWithType: TraceExtensions.ResolveInWhere<TIn, TOut>(ITransformationTrace, TransformationRuleBase<TIn, TOut>, Predicate<TIn>)
  fullName: NMF.Transformations.TraceExtensions.ResolveInWhere<TIn, TOut>(NMF.Transformations.Core.ITransformationTrace, NMF.Transformations.TransformationRuleBase<TIn, TOut>, System.Predicate<TIn>)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/NTL/TraceExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ResolveInWhere
    path: src/Transformations/Transformations/NTL/TraceExtensions.cs
    startLine: 161
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations
  summary: "\nTrace the output of the computation that transformed any input that matches the filter with the given transformation type\n"
  example: []
  syntax:
    content: >-
      public static IEnumerable<TOut> ResolveInWhere<TIn, TOut>(this ITransformationTrace trace, TransformationRuleBase<TIn, TOut> rule, Predicate<TIn> filter)

          where TIn : class where TOut : class
    parameters:
    - id: trace
      type: NMF.Transformations.Core.ITransformationTrace
      description: The trace component that is used as basis
    - id: rule
      type: NMF.Transformations.TransformationRuleBase{{TIn},{TOut}}
      description: The transformation rule the object was transformed with
    - id: filter
      type: System.Predicate{{TIn}}
      description: The filter that should filter the inputs
    typeParameters:
    - id: TIn
      description: The input type that is looked for
    - id: TOut
      description: The output that is returned by the transformation rule
    return:
      type: System.Collections.Generic.IEnumerable{{TOut}}
      description: All outputs of computations with suitable input arguments or null, if there are none
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ResolveInWhere(Of TIn As Class, TOut As Class)(trace As ITransformationTrace, rule As TransformationRuleBase(Of TIn, TOut), filter As Predicate(Of TIn)) As IEnumerable(Of TOut)
  overload: NMF.Transformations.TraceExtensions.ResolveInWhere*
  nameWithType.vb: TraceExtensions.ResolveInWhere(Of TIn, TOut)(ITransformationTrace, TransformationRuleBase(Of TIn, TOut), Predicate(Of TIn))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.TraceExtensions.ResolveInWhere(Of TIn, TOut)(NMF.Transformations.Core.ITransformationTrace, NMF.Transformations.TransformationRuleBase(Of TIn, TOut), System.Predicate(Of TIn))
  name.vb: ResolveInWhere(Of TIn, TOut)(ITransformationTrace, TransformationRuleBase(Of TIn, TOut), Predicate(Of TIn))
- uid: NMF.Transformations.TraceExtensions.ResolveWhere``2(NMF.Transformations.Core.ITransformationTrace,System.Predicate{``0})
  commentId: M:NMF.Transformations.TraceExtensions.ResolveWhere``2(NMF.Transformations.Core.ITransformationTrace,System.Predicate{``0})
  id: ResolveWhere``2(NMF.Transformations.Core.ITransformationTrace,System.Predicate{``0})
  isExtensionMethod: true
  parent: NMF.Transformations.TraceExtensions
  langs:
  - csharp
  - vb
  name: ResolveWhere<TIn, TOut>(ITransformationTrace, Predicate<TIn>)
  nameWithType: TraceExtensions.ResolveWhere<TIn, TOut>(ITransformationTrace, Predicate<TIn>)
  fullName: NMF.Transformations.TraceExtensions.ResolveWhere<TIn, TOut>(NMF.Transformations.Core.ITransformationTrace, System.Predicate<TIn>)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/NTL/TraceExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ResolveWhere
    path: src/Transformations/Transformations/NTL/TraceExtensions.cs
    startLine: 182
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations
  summary: "\nTrace the output of the computation that transformed any input that matches the filter into the desired type\n"
  example: []
  syntax:
    content: >-
      public static IEnumerable<TOut> ResolveWhere<TIn, TOut>(this ITransformationTrace trace, Predicate<TIn> filter)

          where TIn : class where TOut : class
    parameters:
    - id: trace
      type: NMF.Transformations.Core.ITransformationTrace
      description: The trace component that is used as basis
    - id: filter
      type: System.Predicate{{TIn}}
      description: The filter that should filter the inputs
    typeParameters:
    - id: TIn
      description: The input type that is looked for
    - id: TOut
      description: The desired output type
    return:
      type: System.Collections.Generic.IEnumerable{{TOut}}
      description: All outputs of computations with suitable input arguments or null, if there are none
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ResolveWhere(Of TIn As Class, TOut As Class)(trace As ITransformationTrace, filter As Predicate(Of TIn)) As IEnumerable(Of TOut)
  overload: NMF.Transformations.TraceExtensions.ResolveWhere*
  nameWithType.vb: TraceExtensions.ResolveWhere(Of TIn, TOut)(ITransformationTrace, Predicate(Of TIn))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.TraceExtensions.ResolveWhere(Of TIn, TOut)(NMF.Transformations.Core.ITransformationTrace, System.Predicate(Of TIn))
  name.vb: ResolveWhere(Of TIn, TOut)(ITransformationTrace, Predicate(Of TIn))
- uid: NMF.Transformations.TraceExtensions.ResolveManyIn``2(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1},``0)
  commentId: M:NMF.Transformations.TraceExtensions.ResolveManyIn``2(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1},``0)
  id: ResolveManyIn``2(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1},``0)
  isExtensionMethod: true
  parent: NMF.Transformations.TraceExtensions
  langs:
  - csharp
  - vb
  name: ResolveManyIn<TIn, TOut>(ITransformationTrace, TransformationRuleBase<TIn, TOut>, TIn)
  nameWithType: TraceExtensions.ResolveManyIn<TIn, TOut>(ITransformationTrace, TransformationRuleBase<TIn, TOut>, TIn)
  fullName: NMF.Transformations.TraceExtensions.ResolveManyIn<TIn, TOut>(NMF.Transformations.Core.ITransformationTrace, NMF.Transformations.TransformationRuleBase<TIn, TOut>, TIn)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/NTL/TraceExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ResolveManyIn
    path: src/Transformations/Transformations/NTL/TraceExtensions.cs
    startLine: 203
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations
  summary: "\nTrace the output of the computation that transformed any input that matches the filter with the given transformation type\n"
  example: []
  syntax:
    content: >-
      public static IEnumerable<TOut> ResolveManyIn<TIn, TOut>(this ITransformationTrace trace, TransformationRuleBase<TIn, TOut> rule, TIn input)

          where TIn : class where TOut : class
    parameters:
    - id: trace
      type: NMF.Transformations.Core.ITransformationTrace
      description: The trace component that is used as basis
    - id: rule
      type: NMF.Transformations.TransformationRuleBase{{TIn},{TOut}}
      description: The transformation rule the object was transformed with
    - id: input
      type: '{TIn}'
      description: The input to resolve multiple outputs
    typeParameters:
    - id: TIn
      description: The input type that is looked for
    - id: TOut
      description: The output that is returned by the transformation rule
    return:
      type: System.Collections.Generic.IEnumerable{{TOut}}
      description: All outputs of computations with suitable input arguments or null, if there are none
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ResolveManyIn(Of TIn As Class, TOut As Class)(trace As ITransformationTrace, rule As TransformationRuleBase(Of TIn, TOut), input As TIn) As IEnumerable(Of TOut)
  overload: NMF.Transformations.TraceExtensions.ResolveManyIn*
  nameWithType.vb: TraceExtensions.ResolveManyIn(Of TIn, TOut)(ITransformationTrace, TransformationRuleBase(Of TIn, TOut), TIn)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.TraceExtensions.ResolveManyIn(Of TIn, TOut)(NMF.Transformations.Core.ITransformationTrace, NMF.Transformations.TransformationRuleBase(Of TIn, TOut), TIn)
  name.vb: ResolveManyIn(Of TIn, TOut)(ITransformationTrace, TransformationRuleBase(Of TIn, TOut), TIn)
- uid: NMF.Transformations.TraceExtensions.ResolveManyIn``2(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1},System.Collections.Generic.IEnumerable{``0})
  commentId: M:NMF.Transformations.TraceExtensions.ResolveManyIn``2(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1},System.Collections.Generic.IEnumerable{``0})
  id: ResolveManyIn``2(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1},System.Collections.Generic.IEnumerable{``0})
  isExtensionMethod: true
  parent: NMF.Transformations.TraceExtensions
  langs:
  - csharp
  - vb
  name: ResolveManyIn<TIn, TOut>(ITransformationTrace, TransformationRuleBase<TIn, TOut>, IEnumerable<TIn>)
  nameWithType: TraceExtensions.ResolveManyIn<TIn, TOut>(ITransformationTrace, TransformationRuleBase<TIn, TOut>, IEnumerable<TIn>)
  fullName: NMF.Transformations.TraceExtensions.ResolveManyIn<TIn, TOut>(NMF.Transformations.Core.ITransformationTrace, NMF.Transformations.TransformationRuleBase<TIn, TOut>, System.Collections.Generic.IEnumerable<TIn>)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/NTL/TraceExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ResolveManyIn
    path: src/Transformations/Transformations/NTL/TraceExtensions.cs
    startLine: 223
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations
  summary: "\nTrace the output of the computation that transformed any input that matches the filter with the given transformation type\n"
  example: []
  syntax:
    content: >-
      public static IEnumerable<TOut> ResolveManyIn<TIn, TOut>(this ITransformationTrace trace, TransformationRuleBase<TIn, TOut> rule, IEnumerable<TIn> list)

          where TIn : class where TOut : class
    parameters:
    - id: trace
      type: NMF.Transformations.Core.ITransformationTrace
      description: The trace component that is used as basis
    - id: rule
      type: NMF.Transformations.TransformationRuleBase{{TIn},{TOut}}
      description: The transformation rule the object was transformed with
    - id: list
      type: System.Collections.Generic.IEnumerable{{TIn}}
      description: A list of allowed input arguments
    typeParameters:
    - id: TIn
      description: The input type that is looked for
    - id: TOut
      description: The output that is returned by the transformation rule
    return:
      type: System.Collections.Generic.IEnumerable{{TOut}}
      description: All outputs of computations with suitable input arguments or null, if there are none
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ResolveManyIn(Of TIn As Class, TOut As Class)(trace As ITransformationTrace, rule As TransformationRuleBase(Of TIn, TOut), list As IEnumerable(Of TIn)) As IEnumerable(Of TOut)
  overload: NMF.Transformations.TraceExtensions.ResolveManyIn*
  nameWithType.vb: TraceExtensions.ResolveManyIn(Of TIn, TOut)(ITransformationTrace, TransformationRuleBase(Of TIn, TOut), IEnumerable(Of TIn))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.TraceExtensions.ResolveManyIn(Of TIn, TOut)(NMF.Transformations.Core.ITransformationTrace, NMF.Transformations.TransformationRuleBase(Of TIn, TOut), System.Collections.Generic.IEnumerable(Of TIn))
  name.vb: ResolveManyIn(Of TIn, TOut)(ITransformationTrace, TransformationRuleBase(Of TIn, TOut), IEnumerable(Of TIn))
- uid: NMF.Transformations.TraceExtensions.ResolveMany``2(NMF.Transformations.Core.ITransformationTrace,System.Collections.Generic.IEnumerable{``0})
  commentId: M:NMF.Transformations.TraceExtensions.ResolveMany``2(NMF.Transformations.Core.ITransformationTrace,System.Collections.Generic.IEnumerable{``0})
  id: ResolveMany``2(NMF.Transformations.Core.ITransformationTrace,System.Collections.Generic.IEnumerable{``0})
  isExtensionMethod: true
  parent: NMF.Transformations.TraceExtensions
  langs:
  - csharp
  - vb
  name: ResolveMany<TIn, TOut>(ITransformationTrace, IEnumerable<TIn>)
  nameWithType: TraceExtensions.ResolveMany<TIn, TOut>(ITransformationTrace, IEnumerable<TIn>)
  fullName: NMF.Transformations.TraceExtensions.ResolveMany<TIn, TOut>(NMF.Transformations.Core.ITransformationTrace, System.Collections.Generic.IEnumerable<TIn>)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/NTL/TraceExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ResolveMany
    path: src/Transformations/Transformations/NTL/TraceExtensions.cs
    startLine: 244
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations
  summary: "\nTrace the output of the computation that transformed any input that matches the filter into the desired type\n"
  example: []
  syntax:
    content: >-
      public static IEnumerable<TOut> ResolveMany<TIn, TOut>(this ITransformationTrace trace, IEnumerable<TIn> list)

          where TIn : class where TOut : class
    parameters:
    - id: trace
      type: NMF.Transformations.Core.ITransformationTrace
      description: The trace component that is used as basis
    - id: list
      type: System.Collections.Generic.IEnumerable{{TIn}}
      description: A list of allowed input arguments
    typeParameters:
    - id: TIn
      description: The input type that is looked for
    - id: TOut
      description: The desired output type
    return:
      type: System.Collections.Generic.IEnumerable{{TOut}}
      description: All outputs of computations with suitable input arguments or null, if there are none
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ResolveMany(Of TIn As Class, TOut As Class)(trace As ITransformationTrace, list As IEnumerable(Of TIn)) As IEnumerable(Of TOut)
  overload: NMF.Transformations.TraceExtensions.ResolveMany*
  nameWithType.vb: TraceExtensions.ResolveMany(Of TIn, TOut)(ITransformationTrace, IEnumerable(Of TIn))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.TraceExtensions.ResolveMany(Of TIn, TOut)(NMF.Transformations.Core.ITransformationTrace, System.Collections.Generic.IEnumerable(Of TIn))
  name.vb: ResolveMany(Of TIn, TOut)(ITransformationTrace, IEnumerable(Of TIn))
- uid: NMF.Transformations.TraceExtensions.ResolveMany``2(NMF.Transformations.Core.ITransformationTrace,``0)
  commentId: M:NMF.Transformations.TraceExtensions.ResolveMany``2(NMF.Transformations.Core.ITransformationTrace,``0)
  id: ResolveMany``2(NMF.Transformations.Core.ITransformationTrace,``0)
  isExtensionMethod: true
  parent: NMF.Transformations.TraceExtensions
  langs:
  - csharp
  - vb
  name: ResolveMany<TIn, TOut>(ITransformationTrace, TIn)
  nameWithType: TraceExtensions.ResolveMany<TIn, TOut>(ITransformationTrace, TIn)
  fullName: NMF.Transformations.TraceExtensions.ResolveMany<TIn, TOut>(NMF.Transformations.Core.ITransformationTrace, TIn)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/NTL/TraceExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ResolveMany
    path: src/Transformations/Transformations/NTL/TraceExtensions.cs
    startLine: 264
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations
  summary: "\nTrace the output of the computation that transformed any input that matches the filter into the desired type\n"
  example: []
  syntax:
    content: >-
      public static IEnumerable<TOut> ResolveMany<TIn, TOut>(this ITransformationTrace trace, TIn input)

          where TIn : class where TOut : class
    parameters:
    - id: trace
      type: NMF.Transformations.Core.ITransformationTrace
      description: The trace component that is used as basis
    - id: input
      type: '{TIn}'
      description: An input argument to look up multiple results
    typeParameters:
    - id: TIn
      description: The input type that is looked for
    - id: TOut
      description: The desired output type
    return:
      type: System.Collections.Generic.IEnumerable{{TOut}}
      description: All outputs of computations with suitable input arguments or null, if there are none
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ResolveMany(Of TIn As Class, TOut As Class)(trace As ITransformationTrace, input As TIn) As IEnumerable(Of TOut)
  overload: NMF.Transformations.TraceExtensions.ResolveMany*
  nameWithType.vb: TraceExtensions.ResolveMany(Of TIn, TOut)(ITransformationTrace, TIn)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.TraceExtensions.ResolveMany(Of TIn, TOut)(NMF.Transformations.Core.ITransformationTrace, TIn)
  name.vb: ResolveMany(Of TIn, TOut)(ITransformationTrace, TIn)
- uid: NMF.Transformations.TraceExtensions.ResolveInWhere``1(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0},System.Predicate{System.Object[]})
  commentId: M:NMF.Transformations.TraceExtensions.ResolveInWhere``1(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0},System.Predicate{System.Object[]})
  id: ResolveInWhere``1(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0},System.Predicate{System.Object[]})
  isExtensionMethod: true
  parent: NMF.Transformations.TraceExtensions
  langs:
  - csharp
  - vb
  name: ResolveInWhere<TOut>(ITransformationTrace, TransformationRuleBase<TOut>, Predicate<Object[]>)
  nameWithType: TraceExtensions.ResolveInWhere<TOut>(ITransformationTrace, TransformationRuleBase<TOut>, Predicate<Object[]>)
  fullName: NMF.Transformations.TraceExtensions.ResolveInWhere<TOut>(NMF.Transformations.Core.ITransformationTrace, NMF.Transformations.TransformationRuleBase<TOut>, System.Predicate<System.Object[]>)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/NTL/TraceExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ResolveInWhere
    path: src/Transformations/Transformations/NTL/TraceExtensions.cs
    startLine: 283
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations
  summary: "\nTrace the output of the computation that transformed any input that matches the filter with the given transformation type\n"
  example: []
  syntax:
    content: >-
      public static IEnumerable<TOut> ResolveInWhere<TOut>(this ITransformationTrace trace, TransformationRuleBase<TOut> rule, Predicate<object[]> filter)

          where TOut : class
    parameters:
    - id: trace
      type: NMF.Transformations.Core.ITransformationTrace
      description: The trace component that is used as basis
    - id: rule
      type: NMF.Transformations.TransformationRuleBase{{TOut}}
      description: The transformation rule the object was transformed with
    - id: filter
      type: System.Predicate{System.Object[]}
      description: The filter that should filter the inputs
    typeParameters:
    - id: TOut
      description: The output that is returned by the transformation rule
    return:
      type: System.Collections.Generic.IEnumerable{{TOut}}
      description: All outputs of computations with suitable input arguments or null, if there are none
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ResolveInWhere(Of TOut As Class)(trace As ITransformationTrace, rule As TransformationRuleBase(Of TOut), filter As Predicate(Of Object())) As IEnumerable(Of TOut)
  overload: NMF.Transformations.TraceExtensions.ResolveInWhere*
  nameWithType.vb: TraceExtensions.ResolveInWhere(Of TOut)(ITransformationTrace, TransformationRuleBase(Of TOut), Predicate(Of Object()))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.TraceExtensions.ResolveInWhere(Of TOut)(NMF.Transformations.Core.ITransformationTrace, NMF.Transformations.TransformationRuleBase(Of TOut), System.Predicate(Of System.Object()))
  name.vb: ResolveInWhere(Of TOut)(ITransformationTrace, TransformationRuleBase(Of TOut), Predicate(Of Object()))
- uid: NMF.Transformations.TraceExtensions.ResolveWhere``1(NMF.Transformations.Core.ITransformationTrace,System.Type[],System.Predicate{System.Object[]})
  commentId: M:NMF.Transformations.TraceExtensions.ResolveWhere``1(NMF.Transformations.Core.ITransformationTrace,System.Type[],System.Predicate{System.Object[]})
  id: ResolveWhere``1(NMF.Transformations.Core.ITransformationTrace,System.Type[],System.Predicate{System.Object[]})
  isExtensionMethod: true
  parent: NMF.Transformations.TraceExtensions
  langs:
  - csharp
  - vb
  name: ResolveWhere<TOut>(ITransformationTrace, Type[], Predicate<Object[]>)
  nameWithType: TraceExtensions.ResolveWhere<TOut>(ITransformationTrace, Type[], Predicate<Object[]>)
  fullName: NMF.Transformations.TraceExtensions.ResolveWhere<TOut>(NMF.Transformations.Core.ITransformationTrace, System.Type[], System.Predicate<System.Object[]>)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/NTL/TraceExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ResolveWhere
    path: src/Transformations/Transformations/NTL/TraceExtensions.cs
    startLine: 303
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations
  summary: "\nTrace the output of the computation that transformed any input that matches the filter with the given transformation type\n"
  example: []
  syntax:
    content: >-
      public static IEnumerable<TOut> ResolveWhere<TOut>(this ITransformationTrace trace, Type[] inputTypes, Predicate<object[]> filter)

          where TOut : class
    parameters:
    - id: trace
      type: NMF.Transformations.Core.ITransformationTrace
      description: The trace component that is used as basis
    - id: inputTypes
      type: System.Type[]
      description: The types of the input arguments that are expected to be matched
    - id: filter
      type: System.Predicate{System.Object[]}
      description: The filter that should filter the inputs
    typeParameters:
    - id: TOut
      description: The output that is returned by the transformation rule
    return:
      type: System.Collections.Generic.IEnumerable{{TOut}}
      description: All outputs of computations with suitable input arguments or null, if there are none
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ResolveWhere(Of TOut As Class)(trace As ITransformationTrace, inputTypes As Type(), filter As Predicate(Of Object())) As IEnumerable(Of TOut)
  overload: NMF.Transformations.TraceExtensions.ResolveWhere*
  nameWithType.vb: TraceExtensions.ResolveWhere(Of TOut)(ITransformationTrace, Type(), Predicate(Of Object()))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.TraceExtensions.ResolveWhere(Of TOut)(NMF.Transformations.Core.ITransformationTrace, System.Type(), System.Predicate(Of System.Object()))
  name.vb: ResolveWhere(Of TOut)(ITransformationTrace, Type(), Predicate(Of Object()))
- uid: NMF.Transformations.TraceExtensions.FindInWhere``2(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1},System.Predicate{``1})
  commentId: M:NMF.Transformations.TraceExtensions.FindInWhere``2(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1},System.Predicate{``1})
  id: FindInWhere``2(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1},System.Predicate{``1})
  isExtensionMethod: true
  parent: NMF.Transformations.TraceExtensions
  langs:
  - csharp
  - vb
  name: FindInWhere<TIn, TOut>(ITransformationTrace, TransformationRuleBase<TIn, TOut>, Predicate<TOut>)
  nameWithType: TraceExtensions.FindInWhere<TIn, TOut>(ITransformationTrace, TransformationRuleBase<TIn, TOut>, Predicate<TOut>)
  fullName: NMF.Transformations.TraceExtensions.FindInWhere<TIn, TOut>(NMF.Transformations.Core.ITransformationTrace, NMF.Transformations.TransformationRuleBase<TIn, TOut>, System.Predicate<TOut>)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/NTL/TraceExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: FindInWhere
    path: src/Transformations/Transformations/NTL/TraceExtensions.cs
    startLine: 323
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations
  summary: "\nTrace the output of the computation that transformed any input that matches the filter with the given transformation type\n"
  example: []
  syntax:
    content: >-
      public static IEnumerable<TOut> FindInWhere<TIn, TOut>(this ITransformationTrace trace, TransformationRuleBase<TIn, TOut> rule, Predicate<TOut> filter)

          where TIn : class where TOut : class
    parameters:
    - id: trace
      type: NMF.Transformations.Core.ITransformationTrace
      description: The trace component that is used as basis
    - id: rule
      type: NMF.Transformations.TransformationRuleBase{{TIn},{TOut}}
      description: The transformation rule the object was transformed with
    - id: filter
      type: System.Predicate{{TOut}}
      description: The filter that should filter the inputs
    typeParameters:
    - id: TIn
      description: The input type parameter of the transformation rule
    - id: TOut
      description: The output that is returned by the transformation rule
    return:
      type: System.Collections.Generic.IEnumerable{{TOut}}
      description: All outputs of computations with suitable input arguments or null, if there are none
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function FindInWhere(Of TIn As Class, TOut As Class)(trace As ITransformationTrace, rule As TransformationRuleBase(Of TIn, TOut), filter As Predicate(Of TOut)) As IEnumerable(Of TOut)
  overload: NMF.Transformations.TraceExtensions.FindInWhere*
  nameWithType.vb: TraceExtensions.FindInWhere(Of TIn, TOut)(ITransformationTrace, TransformationRuleBase(Of TIn, TOut), Predicate(Of TOut))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.TraceExtensions.FindInWhere(Of TIn, TOut)(NMF.Transformations.Core.ITransformationTrace, NMF.Transformations.TransformationRuleBase(Of TIn, TOut), System.Predicate(Of TOut))
  name.vb: FindInWhere(Of TIn, TOut)(ITransformationTrace, TransformationRuleBase(Of TIn, TOut), Predicate(Of TOut))
- uid: NMF.Transformations.TraceExtensions.FindWhere``2(NMF.Transformations.Core.ITransformationTrace,System.Predicate{``1})
  commentId: M:NMF.Transformations.TraceExtensions.FindWhere``2(NMF.Transformations.Core.ITransformationTrace,System.Predicate{``1})
  id: FindWhere``2(NMF.Transformations.Core.ITransformationTrace,System.Predicate{``1})
  isExtensionMethod: true
  parent: NMF.Transformations.TraceExtensions
  langs:
  - csharp
  - vb
  name: FindWhere<TIn, TOut>(ITransformationTrace, Predicate<TOut>)
  nameWithType: TraceExtensions.FindWhere<TIn, TOut>(ITransformationTrace, Predicate<TOut>)
  fullName: NMF.Transformations.TraceExtensions.FindWhere<TIn, TOut>(NMF.Transformations.Core.ITransformationTrace, System.Predicate<TOut>)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/NTL/TraceExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: FindWhere
    path: src/Transformations/Transformations/NTL/TraceExtensions.cs
    startLine: 341
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations
  summary: "\nFinds all outputs of computations of from the specified source typpe to the specified target type that match the given filter\n"
  example: []
  syntax:
    content: >-
      public static IEnumerable<TOut> FindWhere<TIn, TOut>(this ITransformationTrace trace, Predicate<TOut> filter)

          where TIn : class where TOut : class
    parameters:
    - id: trace
      type: NMF.Transformations.Core.ITransformationTrace
      description: The trace component that is used as basis
    - id: filter
      type: System.Predicate{{TOut}}
      description: The filter that should be applied to the transformation outputs
    typeParameters:
    - id: TIn
      description: The input type of the transformation rule
    - id: TOut
      description: The output type of the transformation rule
    return:
      type: System.Collections.Generic.IEnumerable{{TOut}}
      description: A collection with all suitable outputs
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function FindWhere(Of TIn As Class, TOut As Class)(trace As ITransformationTrace, filter As Predicate(Of TOut)) As IEnumerable(Of TOut)
  overload: NMF.Transformations.TraceExtensions.FindWhere*
  nameWithType.vb: TraceExtensions.FindWhere(Of TIn, TOut)(ITransformationTrace, Predicate(Of TOut))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.TraceExtensions.FindWhere(Of TIn, TOut)(NMF.Transformations.Core.ITransformationTrace, System.Predicate(Of TOut))
  name.vb: FindWhere(Of TIn, TOut)(ITransformationTrace, Predicate(Of TOut))
- uid: NMF.Transformations.TraceExtensions.FindInWhere``3(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Predicate{``2})
  commentId: M:NMF.Transformations.TraceExtensions.FindInWhere``3(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Predicate{``2})
  id: FindInWhere``3(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Predicate{``2})
  isExtensionMethod: true
  parent: NMF.Transformations.TraceExtensions
  langs:
  - csharp
  - vb
  name: FindInWhere<TIn1, TIn2, TOut>(ITransformationTrace, TransformationRuleBase<TIn1, TIn2, TOut>, Predicate<TOut>)
  nameWithType: TraceExtensions.FindInWhere<TIn1, TIn2, TOut>(ITransformationTrace, TransformationRuleBase<TIn1, TIn2, TOut>, Predicate<TOut>)
  fullName: NMF.Transformations.TraceExtensions.FindInWhere<TIn1, TIn2, TOut>(NMF.Transformations.Core.ITransformationTrace, NMF.Transformations.TransformationRuleBase<TIn1, TIn2, TOut>, System.Predicate<TOut>)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/NTL/TraceExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: FindInWhere
    path: src/Transformations/Transformations/NTL/TraceExtensions.cs
    startLine: 359
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations
  summary: "\nFinds all outputs of computations of the given transformation that match the given filter\n"
  example: []
  syntax:
    content: >-
      public static IEnumerable<TOut> FindInWhere<TIn1, TIn2, TOut>(this ITransformationTrace trace, TransformationRuleBase<TIn1, TIn2, TOut> rule, Predicate<TOut> filter)

          where TIn1 : class where TIn2 : class where TOut : class
    parameters:
    - id: trace
      type: NMF.Transformations.Core.ITransformationTrace
      description: The trace component that is used as basis
    - id: rule
      type: NMF.Transformations.TransformationRuleBase{{TIn1},{TIn2},{TOut}}
      description: The transformation rule the object was transformed with
    - id: filter
      type: System.Predicate{{TOut}}
      description: The filter that should be applied to the transformation outputs
    typeParameters:
    - id: TIn1
      description: The type of the first transformation argument
    - id: TIn2
      description: The type of the second transformation argument
    - id: TOut
      description: The output type of the transformation rule
    return:
      type: System.Collections.Generic.IEnumerable{{TOut}}
      description: A collection with all suitable outputs
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function FindInWhere(Of TIn1 As Class, TIn2 As Class, TOut As Class)(trace As ITransformationTrace, rule As TransformationRuleBase(Of TIn1, TIn2, TOut), filter As Predicate(Of TOut)) As IEnumerable(Of TOut)
  overload: NMF.Transformations.TraceExtensions.FindInWhere*
  nameWithType.vb: TraceExtensions.FindInWhere(Of TIn1, TIn2, TOut)(ITransformationTrace, TransformationRuleBase(Of TIn1, TIn2, TOut), Predicate(Of TOut))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.TraceExtensions.FindInWhere(Of TIn1, TIn2, TOut)(NMF.Transformations.Core.ITransformationTrace, NMF.Transformations.TransformationRuleBase(Of TIn1, TIn2, TOut), System.Predicate(Of TOut))
  name.vb: FindInWhere(Of TIn1, TIn2, TOut)(ITransformationTrace, TransformationRuleBase(Of TIn1, TIn2, TOut), Predicate(Of TOut))
- uid: NMF.Transformations.TraceExtensions.FindWhere``3(NMF.Transformations.Core.ITransformationTrace,System.Predicate{``2})
  commentId: M:NMF.Transformations.TraceExtensions.FindWhere``3(NMF.Transformations.Core.ITransformationTrace,System.Predicate{``2})
  id: FindWhere``3(NMF.Transformations.Core.ITransformationTrace,System.Predicate{``2})
  isExtensionMethod: true
  parent: NMF.Transformations.TraceExtensions
  langs:
  - csharp
  - vb
  name: FindWhere<TIn1, TIn2, TOut>(ITransformationTrace, Predicate<TOut>)
  nameWithType: TraceExtensions.FindWhere<TIn1, TIn2, TOut>(ITransformationTrace, Predicate<TOut>)
  fullName: NMF.Transformations.TraceExtensions.FindWhere<TIn1, TIn2, TOut>(NMF.Transformations.Core.ITransformationTrace, System.Predicate<TOut>)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/NTL/TraceExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: FindWhere
    path: src/Transformations/Transformations/NTL/TraceExtensions.cs
    startLine: 379
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations
  summary: "\nFinds all outputs of computations of from the specified source type to the specified target type that match the given filter\n"
  example: []
  syntax:
    content: >-
      public static IEnumerable<TOut> FindWhere<TIn1, TIn2, TOut>(this ITransformationTrace trace, Predicate<TOut> filter)

          where TIn1 : class where TIn2 : class where TOut : class
    parameters:
    - id: trace
      type: NMF.Transformations.Core.ITransformationTrace
      description: The trace component that is used as basis
    - id: filter
      type: System.Predicate{{TOut}}
      description: The filter that should be applied to the transformation outputs
    typeParameters:
    - id: TIn1
      description: The type of the first transformation argument
    - id: TIn2
      description: The type of the second transformation argument
    - id: TOut
      description: The output type of the transformation rule
    return:
      type: System.Collections.Generic.IEnumerable{{TOut}}
      description: A collection with all suitable outputs
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function FindWhere(Of TIn1 As Class, TIn2 As Class, TOut As Class)(trace As ITransformationTrace, filter As Predicate(Of TOut)) As IEnumerable(Of TOut)
  overload: NMF.Transformations.TraceExtensions.FindWhere*
  nameWithType.vb: TraceExtensions.FindWhere(Of TIn1, TIn2, TOut)(ITransformationTrace, Predicate(Of TOut))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.TraceExtensions.FindWhere(Of TIn1, TIn2, TOut)(NMF.Transformations.Core.ITransformationTrace, System.Predicate(Of TOut))
  name.vb: FindWhere(Of TIn1, TIn2, TOut)(ITransformationTrace, Predicate(Of TOut))
- uid: NMF.Transformations.TraceExtensions.FindInWhere``1(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0},System.Predicate{``0})
  commentId: M:NMF.Transformations.TraceExtensions.FindInWhere``1(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0},System.Predicate{``0})
  id: FindInWhere``1(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0},System.Predicate{``0})
  isExtensionMethod: true
  parent: NMF.Transformations.TraceExtensions
  langs:
  - csharp
  - vb
  name: FindInWhere<TOut>(ITransformationTrace, TransformationRuleBase<TOut>, Predicate<TOut>)
  nameWithType: TraceExtensions.FindInWhere<TOut>(ITransformationTrace, TransformationRuleBase<TOut>, Predicate<TOut>)
  fullName: NMF.Transformations.TraceExtensions.FindInWhere<TOut>(NMF.Transformations.Core.ITransformationTrace, NMF.Transformations.TransformationRuleBase<TOut>, System.Predicate<TOut>)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/NTL/TraceExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: FindInWhere
    path: src/Transformations/Transformations/NTL/TraceExtensions.cs
    startLine: 396
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations
  summary: "\nFinds all outputs of computations of from the specified source type to the specified target type that match the given filter\n"
  example: []
  syntax:
    content: >-
      public static IEnumerable<TOut> FindInWhere<TOut>(this ITransformationTrace trace, TransformationRuleBase<TOut> rule, Predicate<TOut> filter)

          where TOut : class
    parameters:
    - id: trace
      type: NMF.Transformations.Core.ITransformationTrace
      description: The trace component that is used as basis
    - id: rule
      type: NMF.Transformations.TransformationRuleBase{{TOut}}
      description: The transformation rule the object was transformed with
    - id: filter
      type: System.Predicate{{TOut}}
      description: The filter that should be applied to the transformation outputs
    typeParameters:
    - id: TOut
      description: The output type of the transformation rule
    return:
      type: System.Collections.Generic.IEnumerable{{TOut}}
      description: A collection with all suitable outputs
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function FindInWhere(Of TOut As Class)(trace As ITransformationTrace, rule As TransformationRuleBase(Of TOut), filter As Predicate(Of TOut)) As IEnumerable(Of TOut)
  overload: NMF.Transformations.TraceExtensions.FindInWhere*
  nameWithType.vb: TraceExtensions.FindInWhere(Of TOut)(ITransformationTrace, TransformationRuleBase(Of TOut), Predicate(Of TOut))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.TraceExtensions.FindInWhere(Of TOut)(NMF.Transformations.Core.ITransformationTrace, NMF.Transformations.TransformationRuleBase(Of TOut), System.Predicate(Of TOut))
  name.vb: FindInWhere(Of TOut)(ITransformationTrace, TransformationRuleBase(Of TOut), Predicate(Of TOut))
- uid: NMF.Transformations.TraceExtensions.FindWhere``1(NMF.Transformations.Core.ITransformationTrace,System.Type[],System.Predicate{``0})
  commentId: M:NMF.Transformations.TraceExtensions.FindWhere``1(NMF.Transformations.Core.ITransformationTrace,System.Type[],System.Predicate{``0})
  id: FindWhere``1(NMF.Transformations.Core.ITransformationTrace,System.Type[],System.Predicate{``0})
  isExtensionMethod: true
  parent: NMF.Transformations.TraceExtensions
  langs:
  - csharp
  - vb
  name: FindWhere<TOut>(ITransformationTrace, Type[], Predicate<TOut>)
  nameWithType: TraceExtensions.FindWhere<TOut>(ITransformationTrace, Type[], Predicate<TOut>)
  fullName: NMF.Transformations.TraceExtensions.FindWhere<TOut>(NMF.Transformations.Core.ITransformationTrace, System.Type[], System.Predicate<TOut>)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/NTL/TraceExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: FindWhere
    path: src/Transformations/Transformations/NTL/TraceExtensions.cs
    startLine: 413
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations
  summary: "\nFinds all outputs of computations of from the specified source type to the specified target type that match the given filter\n"
  example: []
  syntax:
    content: >-
      public static IEnumerable<TOut> FindWhere<TOut>(this ITransformationTrace trace, Type[] inputTypes, Predicate<TOut> filter)

          where TOut : class
    parameters:
    - id: trace
      type: NMF.Transformations.Core.ITransformationTrace
      description: The trace component that is used as basis
    - id: inputTypes
      type: System.Type[]
      description: The input types for the transformation rule
    - id: filter
      type: System.Predicate{{TOut}}
      description: The filter that should be applied to the transformation outputs
    typeParameters:
    - id: TOut
      description: The output type of the transformation rule
    return:
      type: System.Collections.Generic.IEnumerable{{TOut}}
      description: A collection with all suitable outputs
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function FindWhere(Of TOut As Class)(trace As ITransformationTrace, inputTypes As Type(), filter As Predicate(Of TOut)) As IEnumerable(Of TOut)
  overload: NMF.Transformations.TraceExtensions.FindWhere*
  nameWithType.vb: TraceExtensions.FindWhere(Of TOut)(ITransformationTrace, Type(), Predicate(Of TOut))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.TraceExtensions.FindWhere(Of TOut)(NMF.Transformations.Core.ITransformationTrace, System.Type(), System.Predicate(Of TOut))
  name.vb: FindWhere(Of TOut)(ITransformationTrace, Type(), Predicate(Of TOut))
- uid: NMF.Transformations.TraceExtensions.TraceInWhere``1(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.GeneralTransformationRule{``0},System.Predicate{``0})
  commentId: M:NMF.Transformations.TraceExtensions.TraceInWhere``1(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.GeneralTransformationRule{``0},System.Predicate{``0})
  id: TraceInWhere``1(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.GeneralTransformationRule{``0},System.Predicate{``0})
  isExtensionMethod: true
  parent: NMF.Transformations.TraceExtensions
  langs:
  - csharp
  - vb
  name: TraceInWhere<TIn>(ITransformationTrace, GeneralTransformationRule<TIn>, Predicate<TIn>)
  nameWithType: TraceExtensions.TraceInWhere<TIn>(ITransformationTrace, GeneralTransformationRule<TIn>, Predicate<TIn>)
  fullName: NMF.Transformations.TraceExtensions.TraceInWhere<TIn>(NMF.Transformations.Core.ITransformationTrace, NMF.Transformations.GeneralTransformationRule<TIn>, System.Predicate<TIn>)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/NTL/TraceExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: TraceInWhere
    path: src/Transformations/Transformations/NTL/TraceExtensions.cs
    startLine: 429
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations
  summary: "\nTraces all computations with any inputs that math the given filters with the specified transformation rule\n"
  example: []
  syntax:
    content: >-
      public static IEnumerable<ITraceEntry> TraceInWhere<TIn>(this ITransformationTrace trace, GeneralTransformationRule<TIn> rule, Predicate<TIn> filter)

          where TIn : class
    parameters:
    - id: trace
      type: NMF.Transformations.Core.ITransformationTrace
      description: The trace component that is used as basis
    - id: rule
      type: NMF.Transformations.GeneralTransformationRule{{TIn}}
      description: The transformation rule
    - id: filter
      type: System.Predicate{{TIn}}
      description: The predicate of the inputs that are looked for
    typeParameters:
    - id: TIn
      description: The input argument type of the transformation
    return:
      type: System.Collections.Generic.IEnumerable{NMF.Transformations.Core.ITraceEntry}
      description: A collection with all computations made under these circumstances
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function TraceInWhere(Of TIn As Class)(trace As ITransformationTrace, rule As GeneralTransformationRule(Of TIn), filter As Predicate(Of TIn)) As IEnumerable(Of ITraceEntry)
  overload: NMF.Transformations.TraceExtensions.TraceInWhere*
  nameWithType.vb: TraceExtensions.TraceInWhere(Of TIn)(ITransformationTrace, GeneralTransformationRule(Of TIn), Predicate(Of TIn))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.TraceExtensions.TraceInWhere(Of TIn)(NMF.Transformations.Core.ITransformationTrace, NMF.Transformations.GeneralTransformationRule(Of TIn), System.Predicate(Of TIn))
  name.vb: TraceInWhere(Of TIn)(ITransformationTrace, GeneralTransformationRule(Of TIn), Predicate(Of TIn))
- uid: NMF.Transformations.TraceExtensions.TraceInWhere``2(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.GeneralTransformationRule{``0,``1},System.Func{``0,``1,System.Boolean})
  commentId: M:NMF.Transformations.TraceExtensions.TraceInWhere``2(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.GeneralTransformationRule{``0,``1},System.Func{``0,``1,System.Boolean})
  id: TraceInWhere``2(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.GeneralTransformationRule{``0,``1},System.Func{``0,``1,System.Boolean})
  isExtensionMethod: true
  parent: NMF.Transformations.TraceExtensions
  langs:
  - csharp
  - vb
  name: TraceInWhere<TIn1, TIn2>(ITransformationTrace, GeneralTransformationRule<TIn1, TIn2>, Func<TIn1, TIn2, Boolean>)
  nameWithType: TraceExtensions.TraceInWhere<TIn1, TIn2>(ITransformationTrace, GeneralTransformationRule<TIn1, TIn2>, Func<TIn1, TIn2, Boolean>)
  fullName: NMF.Transformations.TraceExtensions.TraceInWhere<TIn1, TIn2>(NMF.Transformations.Core.ITransformationTrace, NMF.Transformations.GeneralTransformationRule<TIn1, TIn2>, System.Func<TIn1, TIn2, System.Boolean>)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/NTL/TraceExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: TraceInWhere
    path: src/Transformations/Transformations/NTL/TraceExtensions.cs
    startLine: 448
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations
  summary: "\nTraces all computations with any inputs that math the given filters with the specified transformation rule\n"
  example: []
  syntax:
    content: >-
      public static IEnumerable<ITraceEntry> TraceInWhere<TIn1, TIn2>(this ITransformationTrace trace, GeneralTransformationRule<TIn1, TIn2> rule, Func<TIn1, TIn2, bool> filter)

          where TIn1 : class where TIn2 : class
    parameters:
    - id: trace
      type: NMF.Transformations.Core.ITransformationTrace
      description: The trace component that is used as basis
    - id: rule
      type: NMF.Transformations.GeneralTransformationRule{{TIn1},{TIn2}}
      description: The transformation rule
    - id: filter
      type: System.Func{{TIn1},{TIn2},System.Boolean}
      description: The predicate of the inputs that are looked for
    typeParameters:
    - id: TIn1
      description: The first input argument type of the transformation
    - id: TIn2
      description: The first input argument type of the transformation
    return:
      type: System.Collections.Generic.IEnumerable{NMF.Transformations.Core.ITraceEntry}
      description: A collection with all computations made under these circumstances
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function TraceInWhere(Of TIn1 As Class, TIn2 As Class)(trace As ITransformationTrace, rule As GeneralTransformationRule(Of TIn1, TIn2), filter As Func(Of TIn1, TIn2, Boolean)) As IEnumerable(Of ITraceEntry)
  overload: NMF.Transformations.TraceExtensions.TraceInWhere*
  nameWithType.vb: TraceExtensions.TraceInWhere(Of TIn1, TIn2)(ITransformationTrace, GeneralTransformationRule(Of TIn1, TIn2), Func(Of TIn1, TIn2, Boolean))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.TraceExtensions.TraceInWhere(Of TIn1, TIn2)(NMF.Transformations.Core.ITransformationTrace, NMF.Transformations.GeneralTransformationRule(Of TIn1, TIn2), System.Func(Of TIn1, TIn2, System.Boolean))
  name.vb: TraceInWhere(Of TIn1, TIn2)(ITransformationTrace, GeneralTransformationRule(Of TIn1, TIn2), Func(Of TIn1, TIn2, Boolean))
- uid: NMF.Transformations.TraceExtensions.TraceInWhere(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.Core.GeneralTransformationRule,System.Predicate{System.Object[]})
  commentId: M:NMF.Transformations.TraceExtensions.TraceInWhere(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.Core.GeneralTransformationRule,System.Predicate{System.Object[]})
  id: TraceInWhere(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.Core.GeneralTransformationRule,System.Predicate{System.Object[]})
  isExtensionMethod: true
  parent: NMF.Transformations.TraceExtensions
  langs:
  - csharp
  - vb
  name: TraceInWhere(ITransformationTrace, GeneralTransformationRule, Predicate<Object[]>)
  nameWithType: TraceExtensions.TraceInWhere(ITransformationTrace, GeneralTransformationRule, Predicate<Object[]>)
  fullName: NMF.Transformations.TraceExtensions.TraceInWhere(NMF.Transformations.Core.ITransformationTrace, NMF.Transformations.Core.GeneralTransformationRule, System.Predicate<System.Object[]>)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/NTL/TraceExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: TraceInWhere
    path: src/Transformations/Transformations/NTL/TraceExtensions.cs
    startLine: 467
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations
  summary: "\nTraces all computations with any inputs that math the given filters with the specified transformation rule\n"
  example: []
  syntax:
    content: public static IEnumerable<ITraceEntry> TraceInWhere(this ITransformationTrace trace, GeneralTransformationRule rule, Predicate<object[]> filter)
    parameters:
    - id: trace
      type: NMF.Transformations.Core.ITransformationTrace
      description: The trace component that is used as basis
    - id: rule
      type: NMF.Transformations.Core.GeneralTransformationRule
      description: The transformation rule
    - id: filter
      type: System.Predicate{System.Object[]}
      description: The predicate of the inputs that are looked for
    return:
      type: System.Collections.Generic.IEnumerable{NMF.Transformations.Core.ITraceEntry}
      description: A collection with all computations made under these circumstances
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function TraceInWhere(trace As ITransformationTrace, rule As GeneralTransformationRule, filter As Predicate(Of Object())) As IEnumerable(Of ITraceEntry)
  overload: NMF.Transformations.TraceExtensions.TraceInWhere*
  nameWithType.vb: TraceExtensions.TraceInWhere(ITransformationTrace, GeneralTransformationRule, Predicate(Of Object()))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.TraceExtensions.TraceInWhere(NMF.Transformations.Core.ITransformationTrace, NMF.Transformations.Core.GeneralTransformationRule, System.Predicate(Of System.Object()))
  name.vb: TraceInWhere(ITransformationTrace, GeneralTransformationRule, Predicate(Of Object()))
- uid: NMF.Transformations.TraceExtensions.ResolveInWhere(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.Core.GeneralTransformationRule,System.Predicate{NMF.Transformations.Core.ITraceEntry})
  commentId: M:NMF.Transformations.TraceExtensions.ResolveInWhere(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.Core.GeneralTransformationRule,System.Predicate{NMF.Transformations.Core.ITraceEntry})
  id: ResolveInWhere(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.Core.GeneralTransformationRule,System.Predicate{NMF.Transformations.Core.ITraceEntry})
  isExtensionMethod: true
  parent: NMF.Transformations.TraceExtensions
  langs:
  - csharp
  - vb
  name: ResolveInWhere(ITransformationTrace, GeneralTransformationRule, Predicate<ITraceEntry>)
  nameWithType: TraceExtensions.ResolveInWhere(ITransformationTrace, GeneralTransformationRule, Predicate<ITraceEntry>)
  fullName: NMF.Transformations.TraceExtensions.ResolveInWhere(NMF.Transformations.Core.ITransformationTrace, NMF.Transformations.Core.GeneralTransformationRule, System.Predicate<NMF.Transformations.Core.ITraceEntry>)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/NTL/TraceExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ResolveInWhere
    path: src/Transformations/Transformations/NTL/TraceExtensions.cs
    startLine: 483
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations
  summary: "\nTrace the output of the computation that transformed any input that matches the filter with the given transformation type\n"
  example: []
  syntax:
    content: public static IEnumerable<object> ResolveInWhere(this ITransformationTrace trace, GeneralTransformationRule rule, Predicate<ITraceEntry> filter)
    parameters:
    - id: trace
      type: NMF.Transformations.Core.ITransformationTrace
      description: The trace component that is used as basis
    - id: rule
      type: NMF.Transformations.Core.GeneralTransformationRule
      description: The transformation rule that was used to transform the outputs
    - id: filter
      type: System.Predicate{NMF.Transformations.Core.ITraceEntry}
      description: The filter that should filter the inputs
    return:
      type: System.Collections.Generic.IEnumerable{System.Object}
      description: All outputs of computations with suitable input arguments or null, if there are none
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ResolveInWhere(trace As ITransformationTrace, rule As GeneralTransformationRule, filter As Predicate(Of ITraceEntry)) As IEnumerable(Of Object)
  overload: NMF.Transformations.TraceExtensions.ResolveInWhere*
  nameWithType.vb: TraceExtensions.ResolveInWhere(ITransformationTrace, GeneralTransformationRule, Predicate(Of ITraceEntry))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.TraceExtensions.ResolveInWhere(NMF.Transformations.Core.ITransformationTrace, NMF.Transformations.Core.GeneralTransformationRule, System.Predicate(Of NMF.Transformations.Core.ITraceEntry))
  name.vb: ResolveInWhere(ITransformationTrace, GeneralTransformationRule, Predicate(Of ITraceEntry))
- uid: NMF.Transformations.TraceExtensions.FindAllIn``1(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0})
  commentId: M:NMF.Transformations.TraceExtensions.FindAllIn``1(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0})
  id: FindAllIn``1(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0})
  isExtensionMethod: true
  parent: NMF.Transformations.TraceExtensions
  langs:
  - csharp
  - vb
  name: FindAllIn<TOut>(ITransformationTrace, TransformationRuleBase<TOut>)
  nameWithType: TraceExtensions.FindAllIn<TOut>(ITransformationTrace, TransformationRuleBase<TOut>)
  fullName: NMF.Transformations.TraceExtensions.FindAllIn<TOut>(NMF.Transformations.Core.ITransformationTrace, NMF.Transformations.TransformationRuleBase<TOut>)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/NTL/TraceExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: FindAllIn
    path: src/Transformations/Transformations/NTL/TraceExtensions.cs
    startLine: 499
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations
  summary: "\nTraces all computations with any inputs that math the given filters with the specified transformation rule\n"
  example: []
  syntax:
    content: >-
      public static IEnumerable<TOut> FindAllIn<TOut>(this ITransformationTrace trace, TransformationRuleBase<TOut> rule)

          where TOut : class
    parameters:
    - id: trace
      type: NMF.Transformations.Core.ITransformationTrace
      description: The trace component that is used as basis
    - id: rule
      type: NMF.Transformations.TransformationRuleBase{{TOut}}
      description: The transformation rule
    typeParameters:
    - id: TOut
    return:
      type: System.Collections.Generic.IEnumerable{{TOut}}
      description: A collection with all computations made under these circumstances
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function FindAllIn(Of TOut As Class)(trace As ITransformationTrace, rule As TransformationRuleBase(Of TOut)) As IEnumerable(Of TOut)
  overload: NMF.Transformations.TraceExtensions.FindAllIn*
  nameWithType.vb: TraceExtensions.FindAllIn(Of TOut)(ITransformationTrace, TransformationRuleBase(Of TOut))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.TraceExtensions.FindAllIn(Of TOut)(NMF.Transformations.Core.ITransformationTrace, NMF.Transformations.TransformationRuleBase(Of TOut))
  name.vb: FindAllIn(Of TOut)(ITransformationTrace, TransformationRuleBase(Of TOut))
- uid: NMF.Transformations.TraceExtensions.FindAllIn``2(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1})
  commentId: M:NMF.Transformations.TraceExtensions.FindAllIn``2(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1})
  id: FindAllIn``2(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1})
  isExtensionMethod: true
  parent: NMF.Transformations.TraceExtensions
  langs:
  - csharp
  - vb
  name: FindAllIn<TIn, TOut>(ITransformationTrace, TransformationRuleBase<TIn, TOut>)
  nameWithType: TraceExtensions.FindAllIn<TIn, TOut>(ITransformationTrace, TransformationRuleBase<TIn, TOut>)
  fullName: NMF.Transformations.TraceExtensions.FindAllIn<TIn, TOut>(NMF.Transformations.Core.ITransformationTrace, NMF.Transformations.TransformationRuleBase<TIn, TOut>)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/NTL/TraceExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: FindAllIn
    path: src/Transformations/Transformations/NTL/TraceExtensions.cs
    startLine: 514
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations
  summary: "\nTraces all computations with any inputs that math the given filters with the specified transformation rule\n"
  example: []
  syntax:
    content: >-
      public static IEnumerable<TOut> FindAllIn<TIn, TOut>(this ITransformationTrace trace, TransformationRuleBase<TIn, TOut> rule)

          where TIn : class where TOut : class
    parameters:
    - id: trace
      type: NMF.Transformations.Core.ITransformationTrace
      description: The trace component that is used as basis
    - id: rule
      type: NMF.Transformations.TransformationRuleBase{{TIn},{TOut}}
      description: The transformation rule
    typeParameters:
    - id: TIn
    - id: TOut
    return:
      type: System.Collections.Generic.IEnumerable{{TOut}}
      description: A collection with all computations made under these circumstances
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function FindAllIn(Of TIn As Class, TOut As Class)(trace As ITransformationTrace, rule As TransformationRuleBase(Of TIn, TOut)) As IEnumerable(Of TOut)
  overload: NMF.Transformations.TraceExtensions.FindAllIn*
  nameWithType.vb: TraceExtensions.FindAllIn(Of TIn, TOut)(ITransformationTrace, TransformationRuleBase(Of TIn, TOut))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.TraceExtensions.FindAllIn(Of TIn, TOut)(NMF.Transformations.Core.ITransformationTrace, NMF.Transformations.TransformationRuleBase(Of TIn, TOut))
  name.vb: FindAllIn(Of TIn, TOut)(ITransformationTrace, TransformationRuleBase(Of TIn, TOut))
- uid: NMF.Transformations.TraceExtensions.FindAllIn``3(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1,``2})
  commentId: M:NMF.Transformations.TraceExtensions.FindAllIn``3(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1,``2})
  id: FindAllIn``3(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1,``2})
  isExtensionMethod: true
  parent: NMF.Transformations.TraceExtensions
  langs:
  - csharp
  - vb
  name: FindAllIn<TIn1, TIn2, TOut>(ITransformationTrace, TransformationRuleBase<TIn1, TIn2, TOut>)
  nameWithType: TraceExtensions.FindAllIn<TIn1, TIn2, TOut>(ITransformationTrace, TransformationRuleBase<TIn1, TIn2, TOut>)
  fullName: NMF.Transformations.TraceExtensions.FindAllIn<TIn1, TIn2, TOut>(NMF.Transformations.Core.ITransformationTrace, NMF.Transformations.TransformationRuleBase<TIn1, TIn2, TOut>)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/NTL/TraceExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: FindAllIn
    path: src/Transformations/Transformations/NTL/TraceExtensions.cs
    startLine: 531
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations
  summary: "\nTraces all computations with any inputs that math the given filters with the specified transformation rule\n"
  example: []
  syntax:
    content: >-
      public static IEnumerable<TOut> FindAllIn<TIn1, TIn2, TOut>(this ITransformationTrace trace, TransformationRuleBase<TIn1, TIn2, TOut> rule)

          where TIn1 : class where TIn2 : class where TOut : class
    parameters:
    - id: trace
      type: NMF.Transformations.Core.ITransformationTrace
      description: The trace component that is used as basis
    - id: rule
      type: NMF.Transformations.TransformationRuleBase{{TIn1},{TIn2},{TOut}}
      description: The transformation rule
    typeParameters:
    - id: TIn1
    - id: TIn2
    - id: TOut
    return:
      type: System.Collections.Generic.IEnumerable{{TOut}}
      description: A collection with all computations made under these circumstances
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function FindAllIn(Of TIn1 As Class, TIn2 As Class, TOut As Class)(trace As ITransformationTrace, rule As TransformationRuleBase(Of TIn1, TIn2, TOut)) As IEnumerable(Of TOut)
  overload: NMF.Transformations.TraceExtensions.FindAllIn*
  nameWithType.vb: TraceExtensions.FindAllIn(Of TIn1, TIn2, TOut)(ITransformationTrace, TransformationRuleBase(Of TIn1, TIn2, TOut))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.TraceExtensions.FindAllIn(Of TIn1, TIn2, TOut)(NMF.Transformations.Core.ITransformationTrace, NMF.Transformations.TransformationRuleBase(Of TIn1, TIn2, TOut))
  name.vb: FindAllIn(Of TIn1, TIn2, TOut)(ITransformationTrace, TransformationRuleBase(Of TIn1, TIn2, TOut))
- uid: NMF.Transformations.TraceExtensions.ResolveInWhere``3(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Func{``0,``1,System.Boolean})
  commentId: M:NMF.Transformations.TraceExtensions.ResolveInWhere``3(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Func{``0,``1,System.Boolean})
  id: ResolveInWhere``3(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Func{``0,``1,System.Boolean})
  isExtensionMethod: true
  parent: NMF.Transformations.TraceExtensions
  langs:
  - csharp
  - vb
  name: ResolveInWhere<TIn1, TIn2, TOut>(ITransformationTrace, TransformationRuleBase<TIn1, TIn2, TOut>, Func<TIn1, TIn2, Boolean>)
  nameWithType: TraceExtensions.ResolveInWhere<TIn1, TIn2, TOut>(ITransformationTrace, TransformationRuleBase<TIn1, TIn2, TOut>, Func<TIn1, TIn2, Boolean>)
  fullName: NMF.Transformations.TraceExtensions.ResolveInWhere<TIn1, TIn2, TOut>(NMF.Transformations.Core.ITransformationTrace, NMF.Transformations.TransformationRuleBase<TIn1, TIn2, TOut>, System.Func<TIn1, TIn2, System.Boolean>)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/NTL/TraceExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ResolveInWhere
    path: src/Transformations/Transformations/NTL/TraceExtensions.cs
    startLine: 549
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations
  summary: "\nTraces all computations with any inputs that math the given filters with the specified transformation rule\n"
  example: []
  syntax:
    content: >-
      public static IEnumerable<TOut> ResolveInWhere<TIn1, TIn2, TOut>(this ITransformationTrace trace, TransformationRuleBase<TIn1, TIn2, TOut> rule, Func<TIn1, TIn2, bool> filter)

          where TIn1 : class where TIn2 : class where TOut : class
    parameters:
    - id: trace
      type: NMF.Transformations.Core.ITransformationTrace
      description: The trace component that is used as basis
    - id: rule
      type: NMF.Transformations.TransformationRuleBase{{TIn1},{TIn2},{TOut}}
      description: The transformation rule
    - id: filter
      type: System.Func{{TIn1},{TIn2},System.Boolean}
      description: A filter that is to be applied on the inputs
    typeParameters:
    - id: TIn1
    - id: TIn2
    - id: TOut
    return:
      type: System.Collections.Generic.IEnumerable{{TOut}}
      description: A collection with all computations made under these circumstances
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ResolveInWhere(Of TIn1 As Class, TIn2 As Class, TOut As Class)(trace As ITransformationTrace, rule As TransformationRuleBase(Of TIn1, TIn2, TOut), filter As Func(Of TIn1, TIn2, Boolean)) As IEnumerable(Of TOut)
  overload: NMF.Transformations.TraceExtensions.ResolveInWhere*
  nameWithType.vb: TraceExtensions.ResolveInWhere(Of TIn1, TIn2, TOut)(ITransformationTrace, TransformationRuleBase(Of TIn1, TIn2, TOut), Func(Of TIn1, TIn2, Boolean))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.TraceExtensions.ResolveInWhere(Of TIn1, TIn2, TOut)(NMF.Transformations.Core.ITransformationTrace, NMF.Transformations.TransformationRuleBase(Of TIn1, TIn2, TOut), System.Func(Of TIn1, TIn2, System.Boolean))
  name.vb: ResolveInWhere(Of TIn1, TIn2, TOut)(ITransformationTrace, TransformationRuleBase(Of TIn1, TIn2, TOut), Func(Of TIn1, TIn2, Boolean))
- uid: NMF.Transformations.TraceExtensions.ResolveWhere``3(NMF.Transformations.Core.ITransformationTrace,System.Func{``0,``1,System.Boolean})
  commentId: M:NMF.Transformations.TraceExtensions.ResolveWhere``3(NMF.Transformations.Core.ITransformationTrace,System.Func{``0,``1,System.Boolean})
  id: ResolveWhere``3(NMF.Transformations.Core.ITransformationTrace,System.Func{``0,``1,System.Boolean})
  isExtensionMethod: true
  parent: NMF.Transformations.TraceExtensions
  langs:
  - csharp
  - vb
  name: ResolveWhere<TIn1, TIn2, TOut>(ITransformationTrace, Func<TIn1, TIn2, Boolean>)
  nameWithType: TraceExtensions.ResolveWhere<TIn1, TIn2, TOut>(ITransformationTrace, Func<TIn1, TIn2, Boolean>)
  fullName: NMF.Transformations.TraceExtensions.ResolveWhere<TIn1, TIn2, TOut>(NMF.Transformations.Core.ITransformationTrace, System.Func<TIn1, TIn2, System.Boolean>)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/NTL/TraceExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ResolveWhere
    path: src/Transformations/Transformations/NTL/TraceExtensions.cs
    startLine: 568
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations
  summary: "\nTrace the output of the computation that transformed any input that matches the filter with the given transformation type\n"
  example: []
  syntax:
    content: >-
      public static IEnumerable<TOut> ResolveWhere<TIn1, TIn2, TOut>(this ITransformationTrace trace, Func<TIn1, TIn2, bool> filter)

          where TIn1 : class where TIn2 : class where TOut : class
    parameters:
    - id: trace
      type: NMF.Transformations.Core.ITransformationTrace
      description: The trace component that is used as basis
    - id: filter
      type: System.Func{{TIn1},{TIn2},System.Boolean}
      description: The filter that should filter the inputs
    typeParameters:
    - id: TIn1
    - id: TIn2
    - id: TOut
    return:
      type: System.Collections.Generic.IEnumerable{{TOut}}
      description: All outputs of computations with suitable input arguments or null, if there are none
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ResolveWhere(Of TIn1 As Class, TIn2 As Class, TOut As Class)(trace As ITransformationTrace, filter As Func(Of TIn1, TIn2, Boolean)) As IEnumerable(Of TOut)
  overload: NMF.Transformations.TraceExtensions.ResolveWhere*
  nameWithType.vb: TraceExtensions.ResolveWhere(Of TIn1, TIn2, TOut)(ITransformationTrace, Func(Of TIn1, TIn2, Boolean))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.TraceExtensions.ResolveWhere(Of TIn1, TIn2, TOut)(NMF.Transformations.Core.ITransformationTrace, System.Func(Of TIn1, TIn2, System.Boolean))
  name.vb: ResolveWhere(Of TIn1, TIn2, TOut)(ITransformationTrace, Func(Of TIn1, TIn2, Boolean))
- uid: NMF.Transformations.TraceExtensions.FindAll``1(NMF.Transformations.Core.ITransformationTrace,System.Type[])
  commentId: M:NMF.Transformations.TraceExtensions.FindAll``1(NMF.Transformations.Core.ITransformationTrace,System.Type[])
  id: FindAll``1(NMF.Transformations.Core.ITransformationTrace,System.Type[])
  isExtensionMethod: true
  parent: NMF.Transformations.TraceExtensions
  langs:
  - csharp
  - vb
  name: FindAll<TOut>(ITransformationTrace, Type[])
  nameWithType: TraceExtensions.FindAll<TOut>(ITransformationTrace, Type[])
  fullName: NMF.Transformations.TraceExtensions.FindAll<TOut>(NMF.Transformations.Core.ITransformationTrace, System.Type[])
  type: Method
  source:
    remote:
      path: Transformations/Transformations/NTL/TraceExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: FindAll
    path: src/Transformations/Transformations/NTL/TraceExtensions.cs
    startLine: 589
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations
  summary: "\nTrace the output of the computation that transformed any input that matches the filter with the given transformation type\n"
  example: []
  syntax:
    content: >-
      public static IEnumerable<TOut> FindAll<TOut>(this ITransformationTrace trace, Type[] inputTypes)

          where TOut : class
    parameters:
    - id: trace
      type: NMF.Transformations.Core.ITransformationTrace
      description: The trace component that is used as basis
    - id: inputTypes
      type: System.Type[]
      description: The input types of the trace request
    typeParameters:
    - id: TOut
      description: The output that is returned by the transformation rule
    return:
      type: System.Collections.Generic.IEnumerable{{TOut}}
      description: All outputs of computations
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function FindAll(Of TOut As Class)(trace As ITransformationTrace, inputTypes As Type()) As IEnumerable(Of TOut)
  overload: NMF.Transformations.TraceExtensions.FindAll*
  nameWithType.vb: TraceExtensions.FindAll(Of TOut)(ITransformationTrace, Type())
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.TraceExtensions.FindAll(Of TOut)(NMF.Transformations.Core.ITransformationTrace, System.Type())
  name.vb: FindAll(Of TOut)(ITransformationTrace, Type())
- uid: NMF.Transformations.TraceExtensions.FindAll``2(NMF.Transformations.Core.ITransformationTrace)
  commentId: M:NMF.Transformations.TraceExtensions.FindAll``2(NMF.Transformations.Core.ITransformationTrace)
  id: FindAll``2(NMF.Transformations.Core.ITransformationTrace)
  isExtensionMethod: true
  parent: NMF.Transformations.TraceExtensions
  langs:
  - csharp
  - vb
  name: FindAll<TIn, TOut>(ITransformationTrace)
  nameWithType: TraceExtensions.FindAll<TIn, TOut>(ITransformationTrace)
  fullName: NMF.Transformations.TraceExtensions.FindAll<TIn, TOut>(NMF.Transformations.Core.ITransformationTrace)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/NTL/TraceExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: FindAll
    path: src/Transformations/Transformations/NTL/TraceExtensions.cs
    startLine: 606
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations
  summary: "\nTrace the output of the computation that transformed any input that matches the filter with the given transformation type\n"
  example: []
  syntax:
    content: >-
      public static IEnumerable<TOut> FindAll<TIn, TOut>(this ITransformationTrace trace)

          where TIn : class where TOut : class
    parameters:
    - id: trace
      type: NMF.Transformations.Core.ITransformationTrace
      description: The trace component that is used as basis
    typeParameters:
    - id: TIn
      description: The input parameter type of the transformation rule
    - id: TOut
      description: The output that is returned by the transformation rule
    return:
      type: System.Collections.Generic.IEnumerable{{TOut}}
      description: All outputs of computations
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function FindAll(Of TIn As Class, TOut As Class)(trace As ITransformationTrace) As IEnumerable(Of TOut)
  overload: NMF.Transformations.TraceExtensions.FindAll*
  nameWithType.vb: TraceExtensions.FindAll(Of TIn, TOut)(ITransformationTrace)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.TraceExtensions.FindAll(Of TIn, TOut)(NMF.Transformations.Core.ITransformationTrace)
  name.vb: FindAll(Of TIn, TOut)(ITransformationTrace)
- uid: NMF.Transformations.TraceExtensions.FindAll``3(NMF.Transformations.Core.ITransformationTrace)
  commentId: M:NMF.Transformations.TraceExtensions.FindAll``3(NMF.Transformations.Core.ITransformationTrace)
  id: FindAll``3(NMF.Transformations.Core.ITransformationTrace)
  isExtensionMethod: true
  parent: NMF.Transformations.TraceExtensions
  langs:
  - csharp
  - vb
  name: FindAll<TIn1, TIn2, TOut>(ITransformationTrace)
  nameWithType: TraceExtensions.FindAll<TIn1, TIn2, TOut>(ITransformationTrace)
  fullName: NMF.Transformations.TraceExtensions.FindAll<TIn1, TIn2, TOut>(NMF.Transformations.Core.ITransformationTrace)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/NTL/TraceExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: FindAll
    path: src/Transformations/Transformations/NTL/TraceExtensions.cs
    startLine: 625
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations
  summary: "\nTrace the output of the computation that transformed any input that matches the filter with the given transformation type\n"
  example: []
  syntax:
    content: >-
      public static IEnumerable<TOut> FindAll<TIn1, TIn2, TOut>(this ITransformationTrace trace)

          where TIn1 : class where TIn2 : class where TOut : class
    parameters:
    - id: trace
      type: NMF.Transformations.Core.ITransformationTrace
      description: The trace component that is used as basis
    typeParameters:
    - id: TIn1
      description: The first input parameter type of the transformation rule
    - id: TIn2
      description: The second input parameter type of the transformation rule
    - id: TOut
      description: The output that is returned by the transformation rule
    return:
      type: System.Collections.Generic.IEnumerable{{TOut}}
      description: All outputs of computations
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function FindAll(Of TIn1 As Class, TIn2 As Class, TOut As Class)(trace As ITransformationTrace) As IEnumerable(Of TOut)
  overload: NMF.Transformations.TraceExtensions.FindAll*
  nameWithType.vb: TraceExtensions.FindAll(Of TIn1, TIn2, TOut)(ITransformationTrace)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.TraceExtensions.FindAll(Of TIn1, TIn2, TOut)(NMF.Transformations.Core.ITransformationTrace)
  name.vb: FindAll(Of TIn1, TIn2, TOut)(ITransformationTrace)
- uid: NMF.Transformations.TraceExtensions.ResolveManyIn``2(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1},``0[])
  commentId: M:NMF.Transformations.TraceExtensions.ResolveManyIn``2(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1},``0[])
  id: ResolveManyIn``2(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1},``0[])
  isExtensionMethod: true
  parent: NMF.Transformations.TraceExtensions
  langs:
  - csharp
  - vb
  name: ResolveManyIn<TIn, TOut>(ITransformationTrace, TransformationRuleBase<TIn, TOut>, TIn[])
  nameWithType: TraceExtensions.ResolveManyIn<TIn, TOut>(ITransformationTrace, TransformationRuleBase<TIn, TOut>, TIn[])
  fullName: NMF.Transformations.TraceExtensions.ResolveManyIn<TIn, TOut>(NMF.Transformations.Core.ITransformationTrace, NMF.Transformations.TransformationRuleBase<TIn, TOut>, TIn[])
  type: Method
  source:
    remote:
      path: Transformations/Transformations/NTL/TraceExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ResolveManyIn
    path: src/Transformations/Transformations/NTL/TraceExtensions.cs
    startLine: 646
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations
  summary: "\nTrace the output of the computation that transformed any input that matches the filter with the given transformation type\n"
  example: []
  syntax:
    content: >-
      public static IEnumerable<TOut> ResolveManyIn<TIn, TOut>(this ITransformationTrace trace, TransformationRuleBase<TIn, TOut> rule, params TIn[] list)

          where TIn : class where TOut : class
    parameters:
    - id: trace
      type: NMF.Transformations.Core.ITransformationTrace
      description: The trace component that is used as basis
    - id: rule
      type: NMF.Transformations.TransformationRuleBase{{TIn},{TOut}}
      description: The transformation rule the object was transformed with
    - id: list
      type: '{TIn}[]'
      description: A list of allowed input arguments
    typeParameters:
    - id: TIn
      description: The input type that is looked for
    - id: TOut
      description: The output that is returned by the transformation rule
    return:
      type: System.Collections.Generic.IEnumerable{{TOut}}
      description: All outputs of computations with suitable input arguments or null, if there are none
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ResolveManyIn(Of TIn As Class, TOut As Class)(trace As ITransformationTrace, rule As TransformationRuleBase(Of TIn, TOut), ParamArray list As TIn()) As IEnumerable(Of TOut)
  overload: NMF.Transformations.TraceExtensions.ResolveManyIn*
  nameWithType.vb: TraceExtensions.ResolveManyIn(Of TIn, TOut)(ITransformationTrace, TransformationRuleBase(Of TIn, TOut), TIn())
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.TraceExtensions.ResolveManyIn(Of TIn, TOut)(NMF.Transformations.Core.ITransformationTrace, NMF.Transformations.TransformationRuleBase(Of TIn, TOut), TIn())
  name.vb: ResolveManyIn(Of TIn, TOut)(ITransformationTrace, TransformationRuleBase(Of TIn, TOut), TIn())
- uid: NMF.Transformations.TraceExtensions.ResolveMany``2(NMF.Transformations.Core.ITransformationTrace,``0[])
  commentId: M:NMF.Transformations.TraceExtensions.ResolveMany``2(NMF.Transformations.Core.ITransformationTrace,``0[])
  id: ResolveMany``2(NMF.Transformations.Core.ITransformationTrace,``0[])
  isExtensionMethod: true
  parent: NMF.Transformations.TraceExtensions
  langs:
  - csharp
  - vb
  name: ResolveMany<TIn, TOut>(ITransformationTrace, TIn[])
  nameWithType: TraceExtensions.ResolveMany<TIn, TOut>(ITransformationTrace, TIn[])
  fullName: NMF.Transformations.TraceExtensions.ResolveMany<TIn, TOut>(NMF.Transformations.Core.ITransformationTrace, TIn[])
  type: Method
  source:
    remote:
      path: Transformations/Transformations/NTL/TraceExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: ResolveMany
    path: src/Transformations/Transformations/NTL/TraceExtensions.cs
    startLine: 661
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations
  summary: "\nTrace the output of the computation that transformed any input that matches the filter into the desired type\n"
  example: []
  syntax:
    content: >-
      public static IEnumerable<TOut> ResolveMany<TIn, TOut>(this ITransformationTrace trace, params TIn[] list)

          where TIn : class where TOut : class
    parameters:
    - id: trace
      type: NMF.Transformations.Core.ITransformationTrace
      description: The trace component that is used as basis
    - id: list
      type: '{TIn}[]'
      description: A list of allowed input arguments
    typeParameters:
    - id: TIn
      description: The input type that is looked for
    - id: TOut
      description: The desired output type
    return:
      type: System.Collections.Generic.IEnumerable{{TOut}}
      description: All outputs of computations with suitable input arguments or null, if there are none
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ResolveMany(Of TIn As Class, TOut As Class)(trace As ITransformationTrace, ParamArray list As TIn()) As IEnumerable(Of TOut)
  overload: NMF.Transformations.TraceExtensions.ResolveMany*
  nameWithType.vb: TraceExtensions.ResolveMany(Of TIn, TOut)(ITransformationTrace, TIn())
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.TraceExtensions.ResolveMany(Of TIn, TOut)(NMF.Transformations.Core.ITransformationTrace, TIn())
  name.vb: ResolveMany(Of TIn, TOut)(ITransformationTrace, TIn())
- uid: NMF.Transformations.TraceExtensions.GetOrCreateUserItem``1(NMF.Transformations.Core.ITransformationContext,System.Object,System.Func{``0})
  commentId: M:NMF.Transformations.TraceExtensions.GetOrCreateUserItem``1(NMF.Transformations.Core.ITransformationContext,System.Object,System.Func{``0})
  id: GetOrCreateUserItem``1(NMF.Transformations.Core.ITransformationContext,System.Object,System.Func{``0})
  isExtensionMethod: true
  parent: NMF.Transformations.TraceExtensions
  langs:
  - csharp
  - vb
  name: GetOrCreateUserItem<TValue>(ITransformationContext, Object, Func<TValue>)
  nameWithType: TraceExtensions.GetOrCreateUserItem<TValue>(ITransformationContext, Object, Func<TValue>)
  fullName: NMF.Transformations.TraceExtensions.GetOrCreateUserItem<TValue>(NMF.Transformations.Core.ITransformationContext, System.Object, System.Func<TValue>)
  type: Method
  source:
    remote:
      path: Transformations/Transformations/NTL/TraceExtensions.cs
      branch: master
      repo: https://github.com/NMFCode/NMF.git
    id: GetOrCreateUserItem
    path: src/Transformations/Transformations/NTL/TraceExtensions.cs
    startLine: 678
  assemblies:
  - NMF.Transformations
  namespace: NMF.Transformations
  summary: "\nGets or creates the user item with the specified key\n"
  example: []
  syntax:
    content: >-
      public static TValue GetOrCreateUserItem<TValue>(this ITransformationContext context, object key, Func<TValue> valueCreator = null)

          where TValue : class
    parameters:
    - id: context
      type: NMF.Transformations.Core.ITransformationContext
      description: The transformation context
    - id: key
      type: System.Object
      description: The key for the user item
    - id: valueCreator
      type: System.Func{{TValue}}
      description: A method that creates the default value if the user item does not yet exist or null, if no user item should be created
    typeParameters:
    - id: TValue
      description: The type of the user item
    return:
      type: '{TValue}'
      description: The user item with the specified key
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function GetOrCreateUserItem(Of TValue As Class)(context As ITransformationContext, key As Object, valueCreator As Func(Of TValue) = Nothing) As TValue
  overload: NMF.Transformations.TraceExtensions.GetOrCreateUserItem*
  nameWithType.vb: TraceExtensions.GetOrCreateUserItem(Of TValue)(ITransformationContext, Object, Func(Of TValue))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: NMF.Transformations.TraceExtensions.GetOrCreateUserItem(Of TValue)(NMF.Transformations.Core.ITransformationContext, System.Object, System.Func(Of TValue))
  name.vb: GetOrCreateUserItem(Of TValue)(ITransformationContext, Object, Func(Of TValue))
references:
- uid: NMF.Transformations
  commentId: N:NMF.Transformations
  name: NMF.Transformations
  nameWithType: NMF.Transformations
  fullName: NMF.Transformations
- uid: System.Object
  commentId: T:System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Object.ToString
  commentId: M:System.Object.ToString
  parent: System.Object
  isExternal: true
  name: ToString()
  nameWithType: Object.ToString()
  fullName: System.Object.ToString()
  spec.csharp:
  - uid: System.Object.ToString
    name: ToString
    nameWithType: Object.ToString
    fullName: System.Object.ToString
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.ToString
    name: ToString
    nameWithType: Object.ToString
    fullName: System.Object.ToString
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Object.Equals(System.Object)
  commentId: M:System.Object.Equals(System.Object)
  parent: System.Object
  isExternal: true
  name: Equals(Object)
  nameWithType: Object.Equals(Object)
  fullName: System.Object.Equals(System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    nameWithType: Object.Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    nameWithType: Object.Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Object.Equals(System.Object,System.Object)
  commentId: M:System.Object.Equals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  name: Equals(Object, Object)
  nameWithType: Object.Equals(Object, Object)
  fullName: System.Object.Equals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    nameWithType: Object.Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    nameWithType: Object.Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Object.ReferenceEquals(System.Object,System.Object)
  commentId: M:System.Object.ReferenceEquals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  name: ReferenceEquals(Object, Object)
  nameWithType: Object.ReferenceEquals(Object, Object)
  fullName: System.Object.ReferenceEquals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    nameWithType: Object.ReferenceEquals
    fullName: System.Object.ReferenceEquals
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    nameWithType: Object.ReferenceEquals
    fullName: System.Object.ReferenceEquals
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Object.GetHashCode
  commentId: M:System.Object.GetHashCode
  parent: System.Object
  isExternal: true
  name: GetHashCode()
  nameWithType: Object.GetHashCode()
  fullName: System.Object.GetHashCode()
  spec.csharp:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    nameWithType: Object.GetHashCode
    fullName: System.Object.GetHashCode
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    nameWithType: Object.GetHashCode
    fullName: System.Object.GetHashCode
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Object.GetType
  commentId: M:System.Object.GetType
  parent: System.Object
  isExternal: true
  name: GetType()
  nameWithType: Object.GetType()
  fullName: System.Object.GetType()
  spec.csharp:
  - uid: System.Object.GetType
    name: GetType
    nameWithType: Object.GetType
    fullName: System.Object.GetType
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetType
    name: GetType
    nameWithType: Object.GetType
    fullName: System.Object.GetType
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Object.MemberwiseClone
  commentId: M:System.Object.MemberwiseClone
  parent: System.Object
  isExternal: true
  name: MemberwiseClone()
  nameWithType: Object.MemberwiseClone()
  fullName: System.Object.MemberwiseClone()
  spec.csharp:
  - uid: System.Object.MemberwiseClone
    name: MemberwiseClone
    nameWithType: Object.MemberwiseClone
    fullName: System.Object.MemberwiseClone
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.MemberwiseClone
    name: MemberwiseClone
    nameWithType: Object.MemberwiseClone
    fullName: System.Object.MemberwiseClone
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
- uid: System
  commentId: N:System
  isExternal: true
  name: System
  nameWithType: System
  fullName: System
- uid: NMF.Transformations.TraceExtensions.ResolveIn*
  commentId: Overload:NMF.Transformations.TraceExtensions.ResolveIn
  name: ResolveIn
  nameWithType: TraceExtensions.ResolveIn
  fullName: NMF.Transformations.TraceExtensions.ResolveIn
- uid: NMF.Transformations.Core.ITransformationTrace
  commentId: T:NMF.Transformations.Core.ITransformationTrace
  parent: NMF.Transformations.Core
  name: ITransformationTrace
  nameWithType: ITransformationTrace
  fullName: NMF.Transformations.Core.ITransformationTrace
- uid: NMF.Transformations.Core.GeneralTransformationRule
  commentId: T:NMF.Transformations.Core.GeneralTransformationRule
  parent: NMF.Transformations.Core
  name: GeneralTransformationRule
  nameWithType: GeneralTransformationRule
  fullName: NMF.Transformations.Core.GeneralTransformationRule
- uid: System.Object[]
  isExternal: true
  name: Object[]
  nameWithType: Object[]
  fullName: System.Object[]
  nameWithType.vb: Object()
  fullName.vb: System.Object()
  name.vb: Object()
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  spec.vb:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: ()
    nameWithType: ()
    fullName: ()
- uid: NMF.Transformations.Core
  commentId: N:NMF.Transformations.Core
  name: NMF.Transformations.Core
  nameWithType: NMF.Transformations.Core
  fullName: NMF.Transformations.Core
- uid: NMF.Transformations.TransformationRuleBase{{TIn},{TOut}}
  commentId: T:NMF.Transformations.TransformationRuleBase{`0,`1}
  parent: NMF.Transformations
  definition: NMF.Transformations.TransformationRuleBase`2
  name: TransformationRuleBase<TIn, TOut>
  nameWithType: TransformationRuleBase<TIn, TOut>
  fullName: NMF.Transformations.TransformationRuleBase<TIn, TOut>
  nameWithType.vb: TransformationRuleBase(Of TIn, TOut)
  fullName.vb: NMF.Transformations.TransformationRuleBase(Of TIn, TOut)
  name.vb: TransformationRuleBase(Of TIn, TOut)
  spec.csharp:
  - uid: NMF.Transformations.TransformationRuleBase`2
    name: TransformationRuleBase
    nameWithType: TransformationRuleBase
    fullName: NMF.Transformations.TransformationRuleBase
  - name: <
    nameWithType: <
    fullName: <
  - name: TIn
    nameWithType: TIn
    fullName: TIn
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: NMF.Transformations.TransformationRuleBase`2
    name: TransformationRuleBase
    nameWithType: TransformationRuleBase
    fullName: NMF.Transformations.TransformationRuleBase
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TIn
    nameWithType: TIn
    fullName: TIn
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: )
    nameWithType: )
    fullName: )
- uid: '{TIn}'
  commentId: '!:TIn'
  definition: TIn
  name: TIn
  nameWithType: TIn
  fullName: TIn
- uid: '{TOut}'
  commentId: '!:TOut'
  definition: TOut
  name: TOut
  nameWithType: TOut
  fullName: TOut
- uid: NMF.Transformations.TransformationRuleBase`2
  commentId: T:NMF.Transformations.TransformationRuleBase`2
  name: TransformationRuleBase<TIn, TOut>
  nameWithType: TransformationRuleBase<TIn, TOut>
  fullName: NMF.Transformations.TransformationRuleBase<TIn, TOut>
  nameWithType.vb: TransformationRuleBase(Of TIn, TOut)
  fullName.vb: NMF.Transformations.TransformationRuleBase(Of TIn, TOut)
  name.vb: TransformationRuleBase(Of TIn, TOut)
  spec.csharp:
  - uid: NMF.Transformations.TransformationRuleBase`2
    name: TransformationRuleBase
    nameWithType: TransformationRuleBase
    fullName: NMF.Transformations.TransformationRuleBase
  - name: <
    nameWithType: <
    fullName: <
  - name: TIn
    nameWithType: TIn
    fullName: TIn
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: NMF.Transformations.TransformationRuleBase`2
    name: TransformationRuleBase
    nameWithType: TransformationRuleBase
    fullName: NMF.Transformations.TransformationRuleBase
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TIn
    nameWithType: TIn
    fullName: TIn
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: )
    nameWithType: )
    fullName: )
- uid: TIn
  name: TIn
  nameWithType: TIn
  fullName: TIn
- uid: TOut
  name: TOut
  nameWithType: TOut
  fullName: TOut
- uid: NMF.Transformations.TraceExtensions.Resolve*
  commentId: Overload:NMF.Transformations.TraceExtensions.Resolve
  name: Resolve
  nameWithType: TraceExtensions.Resolve
  fullName: NMF.Transformations.TraceExtensions.Resolve
- uid: NMF.Transformations.TransformationRuleBase{{TIn1},{TIn2},{TOut}}
  commentId: T:NMF.Transformations.TransformationRuleBase{`0,`1,`2}
  parent: NMF.Transformations
  definition: NMF.Transformations.TransformationRuleBase`3
  name: TransformationRuleBase<TIn1, TIn2, TOut>
  nameWithType: TransformationRuleBase<TIn1, TIn2, TOut>
  fullName: NMF.Transformations.TransformationRuleBase<TIn1, TIn2, TOut>
  nameWithType.vb: TransformationRuleBase(Of TIn1, TIn2, TOut)
  fullName.vb: NMF.Transformations.TransformationRuleBase(Of TIn1, TIn2, TOut)
  name.vb: TransformationRuleBase(Of TIn1, TIn2, TOut)
  spec.csharp:
  - uid: NMF.Transformations.TransformationRuleBase`3
    name: TransformationRuleBase
    nameWithType: TransformationRuleBase
    fullName: NMF.Transformations.TransformationRuleBase
  - name: <
    nameWithType: <
    fullName: <
  - name: TIn1
    nameWithType: TIn1
    fullName: TIn1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TIn2
    nameWithType: TIn2
    fullName: TIn2
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: NMF.Transformations.TransformationRuleBase`3
    name: TransformationRuleBase
    nameWithType: TransformationRuleBase
    fullName: NMF.Transformations.TransformationRuleBase
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TIn1
    nameWithType: TIn1
    fullName: TIn1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TIn2
    nameWithType: TIn2
    fullName: TIn2
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: )
    nameWithType: )
    fullName: )
- uid: '{TIn1}'
  commentId: '!:TIn1'
  definition: TIn1
  name: TIn1
  nameWithType: TIn1
  fullName: TIn1
- uid: '{TIn2}'
  commentId: '!:TIn2'
  definition: TIn2
  name: TIn2
  nameWithType: TIn2
  fullName: TIn2
- uid: NMF.Transformations.TransformationRuleBase`3
  commentId: T:NMF.Transformations.TransformationRuleBase`3
  name: TransformationRuleBase<TIn1, TIn2, TOut>
  nameWithType: TransformationRuleBase<TIn1, TIn2, TOut>
  fullName: NMF.Transformations.TransformationRuleBase<TIn1, TIn2, TOut>
  nameWithType.vb: TransformationRuleBase(Of TIn1, TIn2, TOut)
  fullName.vb: NMF.Transformations.TransformationRuleBase(Of TIn1, TIn2, TOut)
  name.vb: TransformationRuleBase(Of TIn1, TIn2, TOut)
  spec.csharp:
  - uid: NMF.Transformations.TransformationRuleBase`3
    name: TransformationRuleBase
    nameWithType: TransformationRuleBase
    fullName: NMF.Transformations.TransformationRuleBase
  - name: <
    nameWithType: <
    fullName: <
  - name: TIn1
    nameWithType: TIn1
    fullName: TIn1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TIn2
    nameWithType: TIn2
    fullName: TIn2
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: NMF.Transformations.TransformationRuleBase`3
    name: TransformationRuleBase
    nameWithType: TransformationRuleBase
    fullName: NMF.Transformations.TransformationRuleBase
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TIn1
    nameWithType: TIn1
    fullName: TIn1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TIn2
    nameWithType: TIn2
    fullName: TIn2
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: )
    nameWithType: )
    fullName: )
- uid: TIn1
  name: TIn1
  nameWithType: TIn1
  fullName: TIn1
- uid: TIn2
  name: TIn2
  nameWithType: TIn2
  fullName: TIn2
- uid: NMF.Transformations.TransformationRuleBase{{TOut}}
  commentId: T:NMF.Transformations.TransformationRuleBase{``0}
  parent: NMF.Transformations
  definition: NMF.Transformations.TransformationRuleBase`1
  name: TransformationRuleBase<TOut>
  nameWithType: TransformationRuleBase<TOut>
  fullName: NMF.Transformations.TransformationRuleBase<TOut>
  nameWithType.vb: TransformationRuleBase(Of TOut)
  fullName.vb: NMF.Transformations.TransformationRuleBase(Of TOut)
  name.vb: TransformationRuleBase(Of TOut)
  spec.csharp:
  - uid: NMF.Transformations.TransformationRuleBase`1
    name: TransformationRuleBase
    nameWithType: TransformationRuleBase
    fullName: NMF.Transformations.TransformationRuleBase
  - name: <
    nameWithType: <
    fullName: <
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: NMF.Transformations.TransformationRuleBase`1
    name: TransformationRuleBase
    nameWithType: TransformationRuleBase
    fullName: NMF.Transformations.TransformationRuleBase
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: )
    nameWithType: )
    fullName: )
- uid: NMF.Transformations.TransformationRuleBase`1
  commentId: T:NMF.Transformations.TransformationRuleBase`1
  name: TransformationRuleBase<T>
  nameWithType: TransformationRuleBase<T>
  fullName: NMF.Transformations.TransformationRuleBase<T>
  nameWithType.vb: TransformationRuleBase(Of T)
  fullName.vb: NMF.Transformations.TransformationRuleBase(Of T)
  name.vb: TransformationRuleBase(Of T)
  spec.csharp:
  - uid: NMF.Transformations.TransformationRuleBase`1
    name: TransformationRuleBase
    nameWithType: TransformationRuleBase
    fullName: NMF.Transformations.TransformationRuleBase
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: NMF.Transformations.TransformationRuleBase`1
    name: TransformationRuleBase
    nameWithType: TransformationRuleBase
    fullName: NMF.Transformations.TransformationRuleBase
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
- uid: NMF.Transformations.TraceExtensions.ResolveInWhere*
  commentId: Overload:NMF.Transformations.TraceExtensions.ResolveInWhere
  name: ResolveInWhere
  nameWithType: TraceExtensions.ResolveInWhere
  fullName: NMF.Transformations.TraceExtensions.ResolveInWhere
- uid: System.Predicate{{TIn}}
  commentId: T:System.Predicate{`0}
  parent: System
  definition: System.Predicate`1
  name: Predicate<TIn>
  nameWithType: Predicate<TIn>
  fullName: System.Predicate<TIn>
  nameWithType.vb: Predicate(Of TIn)
  fullName.vb: System.Predicate(Of TIn)
  name.vb: Predicate(Of TIn)
  spec.csharp:
  - uid: System.Predicate`1
    name: Predicate
    nameWithType: Predicate
    fullName: System.Predicate
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TIn
    nameWithType: TIn
    fullName: TIn
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Predicate`1
    name: Predicate
    nameWithType: Predicate
    fullName: System.Predicate
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TIn
    nameWithType: TIn
    fullName: TIn
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Collections.Generic.IEnumerable{{TOut}}
  commentId: T:System.Collections.Generic.IEnumerable{``1}
  parent: System.Collections.Generic
  definition: System.Collections.Generic.IEnumerable`1
  name: IEnumerable<TOut>
  nameWithType: IEnumerable<TOut>
  fullName: System.Collections.Generic.IEnumerable<TOut>
  nameWithType.vb: IEnumerable(Of TOut)
  fullName.vb: System.Collections.Generic.IEnumerable(Of TOut)
  name.vb: IEnumerable(Of TOut)
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Predicate`1
  commentId: T:System.Predicate`1
  isExternal: true
  name: Predicate<T>
  nameWithType: Predicate<T>
  fullName: System.Predicate<T>
  nameWithType.vb: Predicate(Of T)
  fullName.vb: System.Predicate(Of T)
  name.vb: Predicate(Of T)
  spec.csharp:
  - uid: System.Predicate`1
    name: Predicate
    nameWithType: Predicate
    fullName: System.Predicate
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Predicate`1
    name: Predicate
    nameWithType: Predicate
    fullName: System.Predicate
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Collections.Generic.IEnumerable`1
  commentId: T:System.Collections.Generic.IEnumerable`1
  isExternal: true
  name: IEnumerable<T>
  nameWithType: IEnumerable<T>
  fullName: System.Collections.Generic.IEnumerable<T>
  nameWithType.vb: IEnumerable(Of T)
  fullName.vb: System.Collections.Generic.IEnumerable(Of T)
  name.vb: IEnumerable(Of T)
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Collections.Generic
  commentId: N:System.Collections.Generic
  isExternal: true
  name: System.Collections.Generic
  nameWithType: System.Collections.Generic
  fullName: System.Collections.Generic
- uid: NMF.Transformations.TraceExtensions.ResolveWhere*
  commentId: Overload:NMF.Transformations.TraceExtensions.ResolveWhere
  name: ResolveWhere
  nameWithType: TraceExtensions.ResolveWhere
  fullName: NMF.Transformations.TraceExtensions.ResolveWhere
- uid: NMF.Transformations.TraceExtensions.ResolveManyIn*
  commentId: Overload:NMF.Transformations.TraceExtensions.ResolveManyIn
  name: ResolveManyIn
  nameWithType: TraceExtensions.ResolveManyIn
  fullName: NMF.Transformations.TraceExtensions.ResolveManyIn
- uid: System.Collections.Generic.IEnumerable{{TIn}}
  commentId: T:System.Collections.Generic.IEnumerable{``0}
  parent: System.Collections.Generic
  definition: System.Collections.Generic.IEnumerable`1
  name: IEnumerable<TIn>
  nameWithType: IEnumerable<TIn>
  fullName: System.Collections.Generic.IEnumerable<TIn>
  nameWithType.vb: IEnumerable(Of TIn)
  fullName.vb: System.Collections.Generic.IEnumerable(Of TIn)
  name.vb: IEnumerable(Of TIn)
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TIn
    nameWithType: TIn
    fullName: TIn
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TIn
    nameWithType: TIn
    fullName: TIn
  - name: )
    nameWithType: )
    fullName: )
- uid: NMF.Transformations.TraceExtensions.ResolveMany*
  commentId: Overload:NMF.Transformations.TraceExtensions.ResolveMany
  name: ResolveMany
  nameWithType: TraceExtensions.ResolveMany
  fullName: NMF.Transformations.TraceExtensions.ResolveMany
- uid: System.Predicate{System.Object[]}
  commentId: T:System.Predicate{System.Object[]}
  parent: System
  definition: System.Predicate`1
  name: Predicate<Object[]>
  nameWithType: Predicate<Object[]>
  fullName: System.Predicate<System.Object[]>
  nameWithType.vb: Predicate(Of Object())
  fullName.vb: System.Predicate(Of System.Object())
  name.vb: Predicate(Of Object())
  spec.csharp:
  - uid: System.Predicate`1
    name: Predicate
    nameWithType: Predicate
    fullName: System.Predicate
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Predicate`1
    name: Predicate
    nameWithType: Predicate
    fullName: System.Predicate
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: ()
    nameWithType: ()
    fullName: ()
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Type[]
  isExternal: true
  name: Type[]
  nameWithType: Type[]
  fullName: System.Type[]
  nameWithType.vb: Type()
  fullName.vb: System.Type()
  name.vb: Type()
  spec.csharp:
  - uid: System.Type
    name: Type
    nameWithType: Type
    fullName: System.Type
    isExternal: true
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  spec.vb:
  - uid: System.Type
    name: Type
    nameWithType: Type
    fullName: System.Type
    isExternal: true
  - name: ()
    nameWithType: ()
    fullName: ()
- uid: NMF.Transformations.TraceExtensions.FindInWhere*
  commentId: Overload:NMF.Transformations.TraceExtensions.FindInWhere
  name: FindInWhere
  nameWithType: TraceExtensions.FindInWhere
  fullName: NMF.Transformations.TraceExtensions.FindInWhere
- uid: System.Predicate{{TOut}}
  commentId: T:System.Predicate{``1}
  parent: System
  definition: System.Predicate`1
  name: Predicate<TOut>
  nameWithType: Predicate<TOut>
  fullName: System.Predicate<TOut>
  nameWithType.vb: Predicate(Of TOut)
  fullName.vb: System.Predicate(Of TOut)
  name.vb: Predicate(Of TOut)
  spec.csharp:
  - uid: System.Predicate`1
    name: Predicate
    nameWithType: Predicate
    fullName: System.Predicate
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Predicate`1
    name: Predicate
    nameWithType: Predicate
    fullName: System.Predicate
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: )
    nameWithType: )
    fullName: )
- uid: NMF.Transformations.TraceExtensions.FindWhere*
  commentId: Overload:NMF.Transformations.TraceExtensions.FindWhere
  name: FindWhere
  nameWithType: TraceExtensions.FindWhere
  fullName: NMF.Transformations.TraceExtensions.FindWhere
- uid: NMF.Transformations.TraceExtensions.TraceInWhere*
  commentId: Overload:NMF.Transformations.TraceExtensions.TraceInWhere
  name: TraceInWhere
  nameWithType: TraceExtensions.TraceInWhere
  fullName: NMF.Transformations.TraceExtensions.TraceInWhere
- uid: NMF.Transformations.GeneralTransformationRule{{TIn}}
  commentId: T:NMF.Transformations.GeneralTransformationRule{`0}
  parent: NMF.Transformations
  definition: NMF.Transformations.GeneralTransformationRule`1
  name: GeneralTransformationRule<TIn>
  nameWithType: GeneralTransformationRule<TIn>
  fullName: NMF.Transformations.GeneralTransformationRule<TIn>
  nameWithType.vb: GeneralTransformationRule(Of TIn)
  fullName.vb: NMF.Transformations.GeneralTransformationRule(Of TIn)
  name.vb: GeneralTransformationRule(Of TIn)
  spec.csharp:
  - uid: NMF.Transformations.GeneralTransformationRule`1
    name: GeneralTransformationRule
    nameWithType: GeneralTransformationRule
    fullName: NMF.Transformations.GeneralTransformationRule
  - name: <
    nameWithType: <
    fullName: <
  - name: TIn
    nameWithType: TIn
    fullName: TIn
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: NMF.Transformations.GeneralTransformationRule`1
    name: GeneralTransformationRule
    nameWithType: GeneralTransformationRule
    fullName: NMF.Transformations.GeneralTransformationRule
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TIn
    nameWithType: TIn
    fullName: TIn
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Collections.Generic.IEnumerable{NMF.Transformations.Core.ITraceEntry}
  commentId: T:System.Collections.Generic.IEnumerable{NMF.Transformations.Core.ITraceEntry}
  parent: System.Collections.Generic
  definition: System.Collections.Generic.IEnumerable`1
  name: IEnumerable<ITraceEntry>
  nameWithType: IEnumerable<ITraceEntry>
  fullName: System.Collections.Generic.IEnumerable<NMF.Transformations.Core.ITraceEntry>
  nameWithType.vb: IEnumerable(Of ITraceEntry)
  fullName.vb: System.Collections.Generic.IEnumerable(Of NMF.Transformations.Core.ITraceEntry)
  name.vb: IEnumerable(Of ITraceEntry)
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: NMF.Transformations.Core.ITraceEntry
    name: ITraceEntry
    nameWithType: ITraceEntry
    fullName: NMF.Transformations.Core.ITraceEntry
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: NMF.Transformations.Core.ITraceEntry
    name: ITraceEntry
    nameWithType: ITraceEntry
    fullName: NMF.Transformations.Core.ITraceEntry
  - name: )
    nameWithType: )
    fullName: )
- uid: NMF.Transformations.GeneralTransformationRule`1
  commentId: T:NMF.Transformations.GeneralTransformationRule`1
  name: GeneralTransformationRule<TIn>
  nameWithType: GeneralTransformationRule<TIn>
  fullName: NMF.Transformations.GeneralTransformationRule<TIn>
  nameWithType.vb: GeneralTransformationRule(Of TIn)
  fullName.vb: NMF.Transformations.GeneralTransformationRule(Of TIn)
  name.vb: GeneralTransformationRule(Of TIn)
  spec.csharp:
  - uid: NMF.Transformations.GeneralTransformationRule`1
    name: GeneralTransformationRule
    nameWithType: GeneralTransformationRule
    fullName: NMF.Transformations.GeneralTransformationRule
  - name: <
    nameWithType: <
    fullName: <
  - name: TIn
    nameWithType: TIn
    fullName: TIn
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: NMF.Transformations.GeneralTransformationRule`1
    name: GeneralTransformationRule
    nameWithType: GeneralTransformationRule
    fullName: NMF.Transformations.GeneralTransformationRule
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TIn
    nameWithType: TIn
    fullName: TIn
  - name: )
    nameWithType: )
    fullName: )
- uid: NMF.Transformations.GeneralTransformationRule{{TIn1},{TIn2}}
  commentId: T:NMF.Transformations.GeneralTransformationRule{`0,`1}
  parent: NMF.Transformations
  definition: NMF.Transformations.GeneralTransformationRule`2
  name: GeneralTransformationRule<TIn1, TIn2>
  nameWithType: GeneralTransformationRule<TIn1, TIn2>
  fullName: NMF.Transformations.GeneralTransformationRule<TIn1, TIn2>
  nameWithType.vb: GeneralTransformationRule(Of TIn1, TIn2)
  fullName.vb: NMF.Transformations.GeneralTransformationRule(Of TIn1, TIn2)
  name.vb: GeneralTransformationRule(Of TIn1, TIn2)
  spec.csharp:
  - uid: NMF.Transformations.GeneralTransformationRule`2
    name: GeneralTransformationRule
    nameWithType: GeneralTransformationRule
    fullName: NMF.Transformations.GeneralTransformationRule
  - name: <
    nameWithType: <
    fullName: <
  - name: TIn1
    nameWithType: TIn1
    fullName: TIn1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TIn2
    nameWithType: TIn2
    fullName: TIn2
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: NMF.Transformations.GeneralTransformationRule`2
    name: GeneralTransformationRule
    nameWithType: GeneralTransformationRule
    fullName: NMF.Transformations.GeneralTransformationRule
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TIn1
    nameWithType: TIn1
    fullName: TIn1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TIn2
    nameWithType: TIn2
    fullName: TIn2
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Func{{TIn1},{TIn2},System.Boolean}
  commentId: T:System.Func{`0,`1,System.Boolean}
  parent: System
  definition: System.Func`3
  name: Func<TIn1, TIn2, Boolean>
  nameWithType: Func<TIn1, TIn2, Boolean>
  fullName: System.Func<TIn1, TIn2, System.Boolean>
  nameWithType.vb: Func(Of TIn1, TIn2, Boolean)
  fullName.vb: System.Func(Of TIn1, TIn2, System.Boolean)
  name.vb: Func(Of TIn1, TIn2, Boolean)
  spec.csharp:
  - uid: System.Func`3
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TIn1
    nameWithType: TIn1
    fullName: TIn1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TIn2
    nameWithType: TIn2
    fullName: TIn2
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Boolean
    name: Boolean
    nameWithType: Boolean
    fullName: System.Boolean
    isExternal: true
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`3
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TIn1
    nameWithType: TIn1
    fullName: TIn1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TIn2
    nameWithType: TIn2
    fullName: TIn2
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Boolean
    name: Boolean
    nameWithType: Boolean
    fullName: System.Boolean
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: NMF.Transformations.GeneralTransformationRule`2
  commentId: T:NMF.Transformations.GeneralTransformationRule`2
  parent: NMF.Transformations
  name: GeneralTransformationRule<TIn1, TIn2>
  nameWithType: GeneralTransformationRule<TIn1, TIn2>
  fullName: NMF.Transformations.GeneralTransformationRule<TIn1, TIn2>
  nameWithType.vb: GeneralTransformationRule(Of TIn1, TIn2)
  fullName.vb: NMF.Transformations.GeneralTransformationRule(Of TIn1, TIn2)
  name.vb: GeneralTransformationRule(Of TIn1, TIn2)
  spec.csharp:
  - uid: NMF.Transformations.GeneralTransformationRule`2
    name: GeneralTransformationRule
    nameWithType: GeneralTransformationRule
    fullName: NMF.Transformations.GeneralTransformationRule
  - name: <
    nameWithType: <
    fullName: <
  - name: TIn1
    nameWithType: TIn1
    fullName: TIn1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TIn2
    nameWithType: TIn2
    fullName: TIn2
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: NMF.Transformations.GeneralTransformationRule`2
    name: GeneralTransformationRule
    nameWithType: GeneralTransformationRule
    fullName: NMF.Transformations.GeneralTransformationRule
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TIn1
    nameWithType: TIn1
    fullName: TIn1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TIn2
    nameWithType: TIn2
    fullName: TIn2
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Func`3
  commentId: T:System.Func`3
  isExternal: true
  name: Func<T1, T2, TResult>
  nameWithType: Func<T1, T2, TResult>
  fullName: System.Func<T1, T2, TResult>
  nameWithType.vb: Func(Of T1, T2, TResult)
  fullName.vb: System.Func(Of T1, T2, TResult)
  name.vb: Func(Of T1, T2, TResult)
  spec.csharp:
  - uid: System.Func`3
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T1
    nameWithType: T1
    fullName: T1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: T2
    nameWithType: T2
    fullName: T2
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`3
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T1
    nameWithType: T1
    fullName: T1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: T2
    nameWithType: T2
    fullName: T2
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Predicate{NMF.Transformations.Core.ITraceEntry}
  commentId: T:System.Predicate{NMF.Transformations.Core.ITraceEntry}
  parent: System
  definition: System.Predicate`1
  name: Predicate<ITraceEntry>
  nameWithType: Predicate<ITraceEntry>
  fullName: System.Predicate<NMF.Transformations.Core.ITraceEntry>
  nameWithType.vb: Predicate(Of ITraceEntry)
  fullName.vb: System.Predicate(Of NMF.Transformations.Core.ITraceEntry)
  name.vb: Predicate(Of ITraceEntry)
  spec.csharp:
  - uid: System.Predicate`1
    name: Predicate
    nameWithType: Predicate
    fullName: System.Predicate
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: NMF.Transformations.Core.ITraceEntry
    name: ITraceEntry
    nameWithType: ITraceEntry
    fullName: NMF.Transformations.Core.ITraceEntry
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Predicate`1
    name: Predicate
    nameWithType: Predicate
    fullName: System.Predicate
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: NMF.Transformations.Core.ITraceEntry
    name: ITraceEntry
    nameWithType: ITraceEntry
    fullName: NMF.Transformations.Core.ITraceEntry
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Collections.Generic.IEnumerable{System.Object}
  commentId: T:System.Collections.Generic.IEnumerable{System.Object}
  parent: System.Collections.Generic
  definition: System.Collections.Generic.IEnumerable`1
  name: IEnumerable<Object>
  nameWithType: IEnumerable<Object>
  fullName: System.Collections.Generic.IEnumerable<System.Object>
  nameWithType.vb: IEnumerable(Of Object)
  fullName.vb: System.Collections.Generic.IEnumerable(Of System.Object)
  name.vb: IEnumerable(Of Object)
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: NMF.Transformations.TraceExtensions.FindAllIn*
  commentId: Overload:NMF.Transformations.TraceExtensions.FindAllIn
  name: FindAllIn
  nameWithType: TraceExtensions.FindAllIn
  fullName: NMF.Transformations.TraceExtensions.FindAllIn
- uid: NMF.Transformations.TraceExtensions.FindAll*
  commentId: Overload:NMF.Transformations.TraceExtensions.FindAll
  name: FindAll
  nameWithType: TraceExtensions.FindAll
  fullName: NMF.Transformations.TraceExtensions.FindAll
- uid: '{TIn}[]'
  isExternal: true
  name: TIn[]
  nameWithType: TIn[]
  fullName: TIn[]
  nameWithType.vb: TIn()
  fullName.vb: TIn()
  name.vb: TIn()
  spec.csharp:
  - name: TIn
    nameWithType: TIn
    fullName: TIn
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  spec.vb:
  - name: TIn
    nameWithType: TIn
    fullName: TIn
  - name: ()
    nameWithType: ()
    fullName: ()
- uid: NMF.Transformations.TraceExtensions.GetOrCreateUserItem*
  commentId: Overload:NMF.Transformations.TraceExtensions.GetOrCreateUserItem
  name: GetOrCreateUserItem
  nameWithType: TraceExtensions.GetOrCreateUserItem
  fullName: NMF.Transformations.TraceExtensions.GetOrCreateUserItem
- uid: NMF.Transformations.Core.ITransformationContext
  commentId: T:NMF.Transformations.Core.ITransformationContext
  parent: NMF.Transformations.Core
  name: ITransformationContext
  nameWithType: ITransformationContext
  fullName: NMF.Transformations.Core.ITransformationContext
- uid: System.Func{{TValue}}
  commentId: T:System.Func{``0}
  parent: System
  definition: System.Func`1
  name: Func<TValue>
  nameWithType: Func<TValue>
  fullName: System.Func<TValue>
  nameWithType.vb: Func(Of TValue)
  fullName.vb: System.Func(Of TValue)
  name.vb: Func(Of TValue)
  spec.csharp:
  - uid: System.Func`1
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TValue
    nameWithType: TValue
    fullName: TValue
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`1
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TValue
    nameWithType: TValue
    fullName: TValue
  - name: )
    nameWithType: )
    fullName: )
- uid: '{TValue}'
  commentId: '!:TValue'
  definition: TValue
  name: TValue
  nameWithType: TValue
  fullName: TValue
- uid: System.Func`1
  commentId: T:System.Func`1
  isExternal: true
  name: Func<TResult>
  nameWithType: Func<TResult>
  fullName: System.Func<TResult>
  nameWithType.vb: Func(Of TResult)
  fullName.vb: System.Func(Of TResult)
  name.vb: Func(Of TResult)
  spec.csharp:
  - uid: System.Func`1
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`1
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: )
    nameWithType: )
    fullName: )
- uid: TValue
  commentId: '!:TValue'
  name: TValue
  nameWithType: TValue
  fullName: TValue
